"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Block = void 0;
const codec_1 = require("@klayr/codec");
const tree_1 = require("@klayr/tree");
const block_assets_1 = require("./block_assets");
const block_header_1 = require("./block_header");
const schema_1 = require("./schema");
const transaction_1 = require("./transaction");
class Block {
    constructor(header, transactions, assets) {
        this.header = header;
        this.transactions = transactions;
        this.assets = assets;
    }
    static fromBytes(value) {
        const { header, transactions, assets } = codec_1.codec.decode(schema_1.blockSchema, value);
        return new Block(block_header_1.BlockHeader.fromBytes(header), transactions.map(v => transaction_1.Transaction.fromBytes(v)), block_assets_1.BlockAssets.fromBytes(assets));
    }
    static fromJSON(value) {
        const { header, transactions, assets } = value;
        return new Block(block_header_1.BlockHeader.fromJSON(header), transactions.map(v => transaction_1.Transaction.fromJSON(v)), block_assets_1.BlockAssets.fromJSON(assets));
    }
    getBytes() {
        return codec_1.codec.encode(schema_1.blockSchema, {
            header: this.header.getBytes(),
            transactions: this.transactions.map(p => p.getBytes()),
            assets: this.assets.getBytes(),
        });
    }
    toJSON() {
        return {
            header: this.header.toJSON(),
            transactions: this.transactions.map(p => p.toJSON()),
            assets: this.assets.toJSON(),
        };
    }
    validate() {
        var _a, _b;
        this.header.validate();
        for (const tx of this.transactions) {
            tx.validate();
        }
        this.assets.validate();
        if (!((_a = this.header.transactionRoot) === null || _a === void 0 ? void 0 : _a.equals(tree_1.regularMerkleTree.calculateMerkleRootWithLeaves(this.transactions.map(tx => tx.id))))) {
            throw new Error('Invalid transaction root');
        }
        if (!((_b = this.header.assetRoot) === null || _b === void 0 ? void 0 : _b.equals(tree_1.regularMerkleTree.calculateMerkleRootWithLeaves(this.assets.getBytes())))) {
            throw new Error('Invalid assets root');
        }
    }
    validateGenesis() {
        var _a;
        this.header.validateGenesis();
        if (this.transactions.length !== 0) {
            throw new Error('Transactions length must be zero');
        }
        this.assets.validateGenesis();
        if (!((_a = this.header.assetRoot) === null || _a === void 0 ? void 0 : _a.equals(tree_1.regularMerkleTree.calculateMerkleRootWithLeaves(this.assets.getBytes())))) {
            throw new Error('Invalid assets root');
        }
    }
}
exports.Block = Block;
//# sourceMappingURL=block.js.map