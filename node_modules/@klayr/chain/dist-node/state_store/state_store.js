"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateStore = void 0;
const codec_1 = require("@klayr/codec");
const lisk_db_1 = require("@liskhq/lisk-db");
const db_keys_1 = require("../db_keys");
const cache_db_1 = require("./cache_db");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
class StateStore {
    constructor(db, prefix, cache) {
        this._db = db;
        this._prefix = prefix !== null && prefix !== void 0 ? prefix : db_keys_1.DB_KEY_STATE_STORE;
        this._cache = cache !== null && cache !== void 0 ? cache : new cache_db_1.CacheDB();
        this._latestSnapshotId = -1;
    }
    getStore(storePrefix, subStorePrefix) {
        const subStore = new StateStore(this._db, Buffer.concat([db_keys_1.DB_KEY_STATE_STORE, storePrefix, subStorePrefix]), this._cache);
        return subStore;
    }
    async get(key) {
        const prefixedKey = this._getKey(key);
        const { value, deleted } = this._cache.get(prefixedKey);
        if (value) {
            return (0, utils_1.copyBuffer)(value);
        }
        if (deleted) {
            throw new errors_1.NotFoundError(`Specified key ${prefixedKey.toString('hex')} does not exist`);
        }
        let persistedValue;
        try {
            persistedValue = await this._db.get(prefixedKey);
        }
        catch (error) {
            if (error instanceof lisk_db_1.NotFoundError) {
                throw new errors_1.NotFoundError(`Specified key ${prefixedKey.toString('hex')} does not exist`);
            }
            throw error;
        }
        this._cache.cache(prefixedKey, persistedValue);
        return (0, utils_1.copyBuffer)(persistedValue);
    }
    async getWithSchema(key, schema) {
        const value = await this.get(key);
        return codec_1.codec.decode(schema, value);
    }
    async has(key) {
        try {
            await this.get(key);
            return true;
        }
        catch (error) {
            if (!(error instanceof errors_1.NotFoundError)) {
                throw error;
            }
            return false;
        }
    }
    async set(key, value) {
        const prefixedKey = this._getKey(key);
        if (this._cache.existAny(prefixedKey)) {
            this._cache.set(prefixedKey, value);
            return;
        }
        const dataExist = await this._ensureCache(prefixedKey);
        if (dataExist) {
            this._cache.set(prefixedKey, value);
            return;
        }
        this._cache.add(prefixedKey, value);
    }
    async setWithSchema(key, value, schema) {
        const encodedValue = codec_1.codec.encode(schema, value);
        await this.set(key, encodedValue);
    }
    async del(key) {
        const prefixedKey = this._getKey(key);
        if (!this._cache.existAny(prefixedKey)) {
            await this._ensureCache(prefixedKey);
        }
        this._cache.del(prefixedKey);
    }
    async iterate(options) {
        const start = this._getKey(options.gte);
        const end = this._getKey(options.lte);
        const stream = this._db.createReadStream({
            gte: start,
            lte: end,
            reverse: options.reverse,
            limit: options.limit,
        });
        const storedData = await new Promise((resolve, reject) => {
            const values = [];
            stream
                .on('data', ({ key: prefixedKey, value }) => {
                const { value: cachedValue, deleted } = this._cache.get(prefixedKey);
                if (cachedValue) {
                    values.push({
                        key: prefixedKey,
                        value: (0, utils_1.copyBuffer)(cachedValue),
                    });
                    return;
                }
                if (deleted) {
                    return;
                }
                this._cache.cache(prefixedKey, value);
                values.push({
                    key: prefixedKey,
                    value,
                });
            })
                .on('error', error => {
                reject(error);
            })
                .on('end', () => {
                resolve(values);
            });
        });
        const cachedValues = this._cache.getRange(start, end);
        const existingKey = {};
        const result = [];
        for (const data of cachedValues) {
            existingKey[data.key.toString('binary')] = true;
            result.push({
                key: data.key.subarray(this._prefix.length),
                value: data.value,
            });
        }
        for (const data of storedData) {
            if (existingKey[data.key.toString('binary')] === undefined) {
                result.push({
                    key: data.key.subarray(this._prefix.length),
                    value: data.value,
                });
            }
        }
        result.sort((a, b) => {
            if (options.reverse) {
                return b.key.compare(a.key);
            }
            return a.key.compare(b.key);
        });
        if (options.limit) {
            result.splice(options.limit);
        }
        return result;
    }
    async iterateWithSchema(options, schema) {
        const result = await this.iterate(options);
        return result.map(kv => ({
            key: kv.key,
            value: codec_1.codec.decode(schema, kv.value),
        }));
    }
    createSnapshot() {
        this._snapshot = this._cache.copy();
        this._latestSnapshotId += 1;
        if (this._latestSnapshotId === Number.MAX_SAFE_INTEGER) {
            this._latestSnapshotId = 0;
        }
        return this._latestSnapshotId;
    }
    restoreSnapshot(id) {
        if (id !== this._latestSnapshotId) {
            throw new Error('Invalid snapshot ID. Cannot revert to an older snapshot.');
        }
        if (!this._snapshot) {
            throw new Error('Snapshot must be taken first before reverting');
        }
        this._cache = this._snapshot;
        this._snapshot = undefined;
    }
    finalize(batch) {
        return this._cache.finalize(batch);
    }
    async _ensureCache(prefixedKey) {
        try {
            const value = await this._db.get(prefixedKey);
            this._cache.cache(prefixedKey, value);
            return true;
        }
        catch (error) {
            if (error instanceof lisk_db_1.NotFoundError) {
                return false;
            }
            throw error;
        }
    }
    _getKey(key) {
        return Buffer.concat([this._prefix, key]);
    }
}
exports.StateStore = StateStore;
//# sourceMappingURL=state_store.js.map