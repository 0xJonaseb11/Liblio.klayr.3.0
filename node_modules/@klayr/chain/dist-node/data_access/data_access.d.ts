/// <reference types="node" />
import { Database, Proof } from '@liskhq/lisk-db';
import { Transaction } from '../transaction';
import { BlockHeader } from '../block_header';
import { Block } from '../block';
import { Event } from '../event';
import { CurrentState } from '../state_store';
interface DAConstructor {
    readonly db: Database;
    readonly minBlockHeaderCache: number;
    readonly maxBlockHeaderCache: number;
    readonly keepEventsForHeights: number;
    readonly keepInclusionProofsForHeights: number;
}
export declare class DataAccess {
    private readonly _storage;
    private readonly _blocksCache;
    constructor({ db, minBlockHeaderCache, maxBlockHeaderCache, keepEventsForHeights, keepInclusionProofsForHeights, }: DAConstructor);
    addBlockHeader(blockHeader: BlockHeader): BlockHeader[];
    removeBlockHeader(id: Buffer): Promise<BlockHeader[]>;
    resetBlockHeaderCache(): void;
    getBlockHeaderByID(id: Buffer): Promise<BlockHeader>;
    blockHeaderExists(id: Buffer): Promise<boolean>;
    getBlockHeadersByIDs(arrayOfBlockIds: ReadonlyArray<Buffer>): Promise<BlockHeader[]>;
    getBlockHeaderByHeight(height: number): Promise<BlockHeader>;
    getBlockHeadersByHeightBetween(fromHeight: number, toHeight: number): Promise<BlockHeader[]>;
    getBlockHeadersWithHeights(heightList: ReadonlyArray<number>): Promise<BlockHeader[]>;
    getLastBlockHeader(): Promise<BlockHeader>;
    getHighestCommonBlockID(arrayOfBlockIds: ReadonlyArray<Buffer>): Promise<Buffer | undefined>;
    getBlockByID(id: Buffer): Promise<Block>;
    getBlocksByIDs(arrayOfBlockIds: ReadonlyArray<Buffer>): Promise<Block[]>;
    getBlockByHeight(height: number): Promise<Block>;
    getBlocksByHeightBetween(fromHeight: number, toHeight: number): Promise<Block[]>;
    getLastBlock(): Promise<Block>;
    getEvents(height: number): Promise<Event[]>;
    getInclusionProofs(height: number): Promise<Proof>;
    setInclusionProofs(proof: Proof, height: number): Promise<void>;
    isBlockPersisted(blockId: Buffer): Promise<boolean>;
    getTempBlocks(): Promise<Block[]>;
    isTempBlockEmpty(): Promise<boolean>;
    clearTempBlocks(): Promise<void>;
    getTransactionByID(id: Buffer): Promise<Transaction>;
    getTransactionsByIDs(arrayOfTransactionIds: ReadonlyArray<Buffer>): Promise<Transaction[]>;
    isTransactionPersisted(transactionId: Buffer): Promise<boolean>;
    getFinalizedHeight(): Promise<number>;
    saveBlock(block: Block, events: Event[], state: CurrentState, finalizedHeight: number, removeFromTemp?: boolean): Promise<void>;
    deleteBlock(block: Block, state: CurrentState, saveToTemp?: boolean): Promise<void>;
    private _decodeRawBlock;
}
export {};
