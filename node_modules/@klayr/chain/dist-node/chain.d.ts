/// <reference types="node" />
import { Database } from '@liskhq/lisk-db';
import { DataAccess } from './data_access';
import { Block } from './block';
import { Event } from './event';
import { CurrentState } from './state_store/smt_store';
interface ChainConstructor {
    readonly keepEventsForHeights: number;
    readonly maxTransactionsSize: number;
    readonly minBlockHeaderCache?: number;
    readonly maxBlockHeaderCache?: number;
    readonly keepInclusionProofsForHeights: number;
}
interface ChainInitArgs {
    readonly db: Database;
    readonly chainID: Buffer;
    readonly genesisBlock: Block;
}
interface BlockValidationInput {
    readonly version: number;
}
export declare class Chain {
    dataAccess: DataAccess;
    readonly constants: {
        readonly maxTransactionsSize: number;
        readonly minBlockHeaderCache: number;
        readonly maxBlockHeaderCache: number;
        readonly keepEventsForHeights: number;
        readonly keepInclusionProofsForHeights: number;
    };
    private _lastBlock?;
    private _finalizedHeight?;
    private _chainID;
    private _genesisHeight;
    constructor({ maxTransactionsSize, keepEventsForHeights, minBlockHeaderCache, maxBlockHeaderCache, keepInclusionProofsForHeights, }: ChainConstructor);
    get genesisHeight(): number;
    get lastBlock(): Block;
    get finalizedHeight(): number;
    get chainID(): Buffer;
    init(args: ChainInitArgs): void;
    loadLastBlocks(genesisBlock: Block): Promise<void>;
    resetBlockHeaderCache(): void;
    genesisBlockExist(genesisBlock: Block): Promise<boolean>;
    validateBlock(block: Block, inputs: BlockValidationInput): void;
    saveBlock(block: Block, events: Event[], state: CurrentState, finalizedHeight: number, { removeFromTempTable }?: {
        removeFromTempTable: boolean;
    }): Promise<void>;
    removeBlock(block: Block, state: CurrentState, { saveTempBlock }?: {
        saveTempBlock: boolean;
    }): Promise<void>;
    private _cacheBlockHeaders;
}
export {};
