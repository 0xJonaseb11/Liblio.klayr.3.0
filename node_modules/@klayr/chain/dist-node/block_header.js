"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockHeader = void 0;
const cryptography_1 = require("@klayr/cryptography");
const codec_1 = require("@klayr/codec");
const validator_1 = require("@klayr/validator");
const constants_1 = require("./constants");
const schema_1 = require("./schema");
class BlockHeader {
    constructor({ version, timestamp, height, generatorAddress, previousBlockID, maxHeightPrevoted, maxHeightGenerated, impliesMaxPrevotes, aggregateCommit, validatorsHash, stateRoot, eventRoot, assetRoot, transactionRoot, signature, id, }) {
        this.version = version;
        this.height = height;
        this.generatorAddress = generatorAddress;
        this.previousBlockID = previousBlockID;
        this.timestamp = timestamp;
        this.maxHeightPrevoted = maxHeightPrevoted;
        this.maxHeightGenerated = maxHeightGenerated;
        this.impliesMaxPrevotes = impliesMaxPrevotes;
        this._aggregateCommit = aggregateCommit;
        this._validatorsHash = validatorsHash;
        this._eventRoot = eventRoot;
        this._stateRoot = stateRoot;
        this._transactionRoot = transactionRoot;
        this._assetRoot = assetRoot;
        this._signature = signature;
        this._id = id;
    }
    static fromBytes(value) {
        return new BlockHeader(codec_1.codec.decode(schema_1.blockHeaderSchema, value));
    }
    static fromJSON(value) {
        return new BlockHeader(codec_1.codec.fromJSON(schema_1.blockHeaderSchema, value));
    }
    get stateRoot() {
        return this._stateRoot;
    }
    set stateRoot(val) {
        this._stateRoot = val;
        this._resetComputedValues();
    }
    get eventRoot() {
        return this._eventRoot;
    }
    set eventRoot(val) {
        this._eventRoot = val;
        this._resetComputedValues();
    }
    get assetRoot() {
        return this._assetRoot;
    }
    set assetRoot(val) {
        this._assetRoot = val;
        this._resetComputedValues();
    }
    get transactionRoot() {
        return this._transactionRoot;
    }
    set transactionRoot(val) {
        this._transactionRoot = val;
        this._resetComputedValues();
    }
    get validatorsHash() {
        return this._validatorsHash;
    }
    set validatorsHash(val) {
        this._validatorsHash = val;
        this._resetComputedValues();
    }
    get aggregateCommit() {
        return this._aggregateCommit;
    }
    set aggregateCommit(val) {
        this._aggregateCommit = val;
        this._resetComputedValues();
    }
    getBytes() {
        return codec_1.codec.encode(schema_1.blockHeaderSchema, this._getBlockHeaderProps());
    }
    toJSON() {
        return codec_1.codec.toJSON(schema_1.blockHeaderSchemaWithId, this._getAllProps());
    }
    toObject() {
        return this._getAllProps();
    }
    validate() {
        validator_1.validator.validate(schema_1.blockHeaderSchema, this._getBlockHeaderProps());
        if (this.previousBlockID.length === 0) {
            throw new Error('Previous block id must not be empty.');
        }
        if (this.signature.length !== constants_1.SIGNATURE_LENGTH_BYTES) {
            throw new Error('Signature length must be 64 bytes.');
        }
    }
    validateGenesis() {
        const header = this._getBlockHeaderProps();
        validator_1.validator.validate(schema_1.blockHeaderSchema, header);
        const errors = [];
        if (header.previousBlockID.length !== 32) {
            errors.push({
                message: 'Genesis block header previousBlockID must be 32 bytes',
                keyword: 'const',
                dataPath: 'header.previousBlockID',
                schemaPath: 'properties.previousBlockID',
                params: {},
            });
        }
        if (!header.generatorAddress.equals(Buffer.alloc(constants_1.LENGTH_ADDRESS))) {
            errors.push({
                message: 'Genesis block header generator address must only contain zero bytes',
                keyword: 'const',
                dataPath: 'header.generatorAddress',
                schemaPath: 'properties.generatorAddress',
                params: { allowedValue: Buffer.alloc(constants_1.LENGTH_ADDRESS) },
            });
        }
        if (!header.transactionRoot.equals(constants_1.EMPTY_HASH)) {
            errors.push({
                message: 'Genesis block header transaction root must be empty hash',
                keyword: 'const',
                dataPath: 'header.transactionRoot',
                schemaPath: 'properties.transactionRoot',
                params: { allowedValue: constants_1.EMPTY_HASH },
            });
        }
        if (header.maxHeightPrevoted !== header.height) {
            errors.push({
                message: 'Genesis block header maxHeightPrevoted must equal height',
                keyword: 'const',
                dataPath: 'header.maxHeightPrevoted',
                schemaPath: 'properties.maxHeightPrevoted',
                params: { allowedValue: header.height },
            });
        }
        if (header.maxHeightGenerated !== 0) {
            errors.push({
                message: 'Genesis block header maxHeightGenerated must equal 0',
                keyword: 'const',
                dataPath: 'header.maxHeightGenerated',
                schemaPath: 'properties.maxHeightGenerated',
                params: { allowedValue: 0 },
            });
        }
        if (!header.impliesMaxPrevotes) {
            errors.push({
                message: 'Genesis block header impliesMaxPrevotes must be true',
                keyword: 'const',
                dataPath: 'header.impliesMaxPrevotes',
                schemaPath: 'properties.impliesMaxPrevotes',
                params: { allowedValue: true },
            });
        }
        if (header.aggregateCommit.height !== header.height) {
            errors.push({
                message: 'Genesis block header aggregateCommit.height must equal to the genesis height',
                keyword: 'const',
                dataPath: 'aggregateCommit.height',
                schemaPath: 'properties.aggregateCommit.height',
                params: { allowedValue: header.height },
            });
        }
        if (!header.aggregateCommit.certificateSignature.equals(constants_1.EMPTY_BUFFER)) {
            errors.push({
                message: 'Genesis block header aggregateCommit.certificateSignature must be empty bytes',
                keyword: 'const',
                dataPath: 'aggregateCommit.certificateSignature',
                schemaPath: 'properties.aggregateCommit.certificateSignature',
                params: { allowedValue: constants_1.EMPTY_BUFFER },
            });
        }
        if (!header.aggregateCommit.aggregationBits.equals(constants_1.EMPTY_BUFFER)) {
            errors.push({
                message: 'Genesis block header aggregateCommit.aggregationBits must be empty bytes',
                keyword: 'const',
                dataPath: 'aggregateCommit.aggregationBits',
                schemaPath: 'properties.aggregateCommit.aggregationBits',
                params: { allowedValue: constants_1.EMPTY_BUFFER },
            });
        }
        if (!header.signature.equals(constants_1.EMPTY_BUFFER)) {
            errors.push({
                message: 'Genesis block header signature must be empty bytes',
                keyword: 'const',
                dataPath: 'header.signature',
                schemaPath: 'properties.signature',
                params: { allowedValue: constants_1.EMPTY_BUFFER },
            });
        }
        if (errors.length) {
            throw new validator_1.KlayrvalidationError(errors);
        }
    }
    validateSignature(publicKey, chainID) {
        const signingBytes = this.getSigningBytes();
        const valid = cryptography_1.ed.verifyData(constants_1.TAG_BLOCK_HEADER, chainID, signingBytes, this.signature, publicKey);
        if (!valid) {
            throw new Error('Invalid block signature.');
        }
    }
    getSigningBytes() {
        const blockHeaderBytes = codec_1.codec.encode(schema_1.signingBlockHeaderSchema, this._getSigningProps());
        return blockHeaderBytes;
    }
    sign(chainID, privateKey) {
        this._signature = cryptography_1.ed.signDataWithPrivateKey(constants_1.TAG_BLOCK_HEADER, chainID, this.getSigningBytes(), privateKey);
    }
    get signature() {
        if (!this._signature) {
            throw new Error('Block header is not signed.');
        }
        return this._signature;
    }
    get id() {
        if (!this._id && !this._signature) {
            throw new Error('Can not generate the id for unsigned block header.');
        }
        if (!this._id) {
            const blockHeaderBytes = codec_1.codec.encode(schema_1.blockHeaderSchema, {
                ...this._getSigningProps(),
                signature: this._signature,
            });
            this._id = cryptography_1.utils.hash(blockHeaderBytes);
        }
        return this._id;
    }
    _resetComputedValues() {
        this._id = undefined;
    }
    _getSigningProps() {
        if (!this.assetRoot) {
            throw new Error('Asset root is empty.');
        }
        if (!this.eventRoot) {
            throw new Error('Event root is empty.');
        }
        if (!this.stateRoot) {
            throw new Error('State root is empty.');
        }
        if (!this.transactionRoot) {
            throw new Error('Transaction root is empty.');
        }
        if (!this.validatorsHash) {
            throw new Error('Validators hash is empty.');
        }
        return {
            version: this.version,
            timestamp: this.timestamp,
            height: this.height,
            previousBlockID: this.previousBlockID,
            stateRoot: this.stateRoot,
            assetRoot: this.assetRoot,
            eventRoot: this.eventRoot,
            transactionRoot: this.transactionRoot,
            validatorsHash: this.validatorsHash,
            aggregateCommit: this.aggregateCommit,
            generatorAddress: this.generatorAddress,
            maxHeightPrevoted: this.maxHeightPrevoted,
            maxHeightGenerated: this.maxHeightGenerated,
            impliesMaxPrevotes: this.impliesMaxPrevotes,
        };
    }
    _getBlockHeaderProps() {
        return {
            ...this._getSigningProps(),
            signature: this.signature,
        };
    }
    _getAllProps() {
        return {
            ...this._getBlockHeaderProps(),
            id: this.id,
        };
    }
}
exports.BlockHeader = BlockHeader;
//# sourceMappingURL=block_header.js.map