"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signMultiSignatureTransactionWithPrivateKey = exports.signTransactionWithPrivateKey = exports.signMultiSignatureTransaction = exports.signTransaction = exports.getBytes = exports.getSigningBytes = void 0;
const codec_1 = require("@klayr/codec");
const cryptography_1 = require("@klayr/cryptography");
const validate_1 = require("./validate");
const schema_1 = require("./schema");
const constants_1 = require("./constants");
const encodeParams = (transaction, paramsSchema = codec_1.emptySchema) => {
    (0, validate_1.validateTransaction)(transaction, paramsSchema);
    const hasParams = typeof transaction.params === 'object' && transaction.params !== null && paramsSchema;
    return hasParams
        ? codec_1.codec.encode(paramsSchema, transaction.params)
        : Buffer.alloc(0);
};
const getSigningBytes = (transaction, paramsSchema) => {
    const params = encodeParams(transaction, paramsSchema);
    return codec_1.codec.encode(schema_1.baseTransactionSchema, { ...transaction, params, signatures: [] });
};
exports.getSigningBytes = getSigningBytes;
const getBytes = (transaction, paramsSchema) => {
    const params = encodeParams(transaction, paramsSchema);
    return codec_1.codec.encode(schema_1.baseTransactionSchema, { ...transaction, params });
};
exports.getBytes = getBytes;
const signTransaction = (transaction, chainID, privateKey, paramsSchema) => {
    if (!chainID.length) {
        throw new Error('ChainID is required to sign a transaction');
    }
    if (!privateKey.length || privateKey.length !== 64) {
        throw new Error('Private key must be 64 bytes');
    }
    (0, validate_1.validateTransaction)(transaction, paramsSchema);
    const signature = cryptography_1.ed.signDataWithPrivateKey(constants_1.TAG_TRANSACTION, chainID, (0, exports.getSigningBytes)(transaction, paramsSchema), privateKey);
    transaction.signatures = [signature];
    return { ...transaction, id: cryptography_1.utils.hash((0, exports.getBytes)(transaction, paramsSchema)) };
};
exports.signTransaction = signTransaction;
const signMultiSignatureTransaction = (transactionObject, chainID, privateKey, keys, paramsSchema) => {
    if (!chainID.length) {
        throw new Error('ChainID is required to sign a transaction');
    }
    if (!privateKey || privateKey.length !== 64) {
        throw new Error('Private key must be 64 bytes');
    }
    if (!Array.isArray(transactionObject.signatures)) {
        throw new Error('Signatures must be of type array');
    }
    (0, validate_1.validateTransaction)(transactionObject, paramsSchema);
    keys.mandatoryKeys.sort((publicKeyA, publicKeyB) => publicKeyA.compare(publicKeyB));
    keys.optionalKeys.sort((publicKeyA, publicKeyB) => publicKeyA.compare(publicKeyB));
    const signature = cryptography_1.ed.signDataWithPrivateKey(constants_1.TAG_TRANSACTION, chainID, (0, exports.getSigningBytes)(transactionObject, paramsSchema), privateKey);
    const publicKey = cryptography_1.ed.getPublicKeyFromPrivateKey(privateKey);
    const accountKeys = keys.mandatoryKeys.concat(keys.optionalKeys);
    for (let i = 0; i < accountKeys.length; i += 1) {
        if (accountKeys[i].equals(publicKey)) {
            transactionObject.signatures[i] = signature;
        }
        else if (transactionObject.signatures[i] === undefined) {
            transactionObject.signatures[i] = Buffer.alloc(0);
        }
    }
    return { ...transactionObject, id: cryptography_1.utils.hash((0, exports.getBytes)(transactionObject, paramsSchema)) };
};
exports.signMultiSignatureTransaction = signMultiSignatureTransaction;
exports.signTransactionWithPrivateKey = exports.signTransaction;
exports.signMultiSignatureTransactionWithPrivateKey = exports.signMultiSignatureTransaction;
//# sourceMappingURL=sign.js.map