"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoSEndpoint = void 0;
const cryptography_1 = require("@klayr/cryptography");
const codec_1 = require("@klayr/codec");
const lisk_db_1 = require("@liskhq/lisk-db");
const validator_1 = require("@klayr/validator");
const utils_1 = require("@klayr/utils");
const base_endpoint_1 = require("../base_endpoint");
const validator_2 = require("./stores/validator");
const staker_1 = require("./stores/staker");
const utils_2 = require("./utils");
const genesis_1 = require("./stores/genesis");
const constants_1 = require("./constants");
const eligible_validators_1 = require("./stores/eligible_validators");
const schemas_1 = require("./schemas");
const { q96 } = utils_1.math;
class PoSEndpoint extends base_endpoint_1.BaseEndpoint {
    init(moduleName, moduleConfig, internalMethod, tokenMethod, punishmentLockingPeriods) {
        this._moduleName = moduleName;
        this._moduleConfig = moduleConfig;
        this._tokenMethod = tokenMethod;
        this._internalMethod = internalMethod;
        this._punishmentLockingPeriods = punishmentLockingPeriods;
    }
    async getStaker(ctx) {
        const stakerSubStore = this.stores.get(staker_1.StakerStore);
        const { address } = ctx.params;
        if (typeof address !== 'string') {
            throw new Error('Parameter address must be a string.');
        }
        cryptography_1.address.validateKlayr32Address(address);
        const stakerData = await stakerSubStore.get(ctx, cryptography_1.address.getAddressFromKlayr32Address(address));
        return codec_1.codec.toJSON(staker_1.stakerStoreSchema, stakerData);
    }
    async getValidator(ctx) {
        const validatorSubStore = this.stores.get(validator_2.ValidatorStore);
        const { address } = ctx.params;
        if (typeof address !== 'string') {
            throw new Error('Parameter address must be a string.');
        }
        cryptography_1.address.validateKlayr32Address(address);
        const validatorAccount = await validatorSubStore.get(ctx, cryptography_1.address.getAddressFromKlayr32Address(address));
        return {
            ...codec_1.codec.toJSON(validator_2.validatorStoreSchema, validatorAccount),
            address,
            punishmentPeriods: this._calculatePunishmentPeriods(validatorAccount.reportMisbehaviorHeights),
        };
    }
    async getAllValidators(ctx) {
        const validatorSubStore = this.stores.get(validator_2.ValidatorStore);
        const startBuf = Buffer.alloc(20);
        const endBuf = Buffer.alloc(20, 255);
        const storeData = await validatorSubStore.iterate(ctx, { gte: startBuf, lte: endBuf });
        const response = [];
        for (const data of storeData) {
            const validatorAccount = await validatorSubStore.get(ctx, data.key);
            const validatorAccountJSON = {
                ...codec_1.codec.toJSON(validator_2.validatorStoreSchema, validatorAccount),
                address: cryptography_1.address.getKlayr32AddressFromAddress(data.key),
                punishmentPeriods: this._calculatePunishmentPeriods(validatorAccount.reportMisbehaviorHeights),
            };
            response.push(validatorAccountJSON);
        }
        return { validators: response };
    }
    async getLockedStakedAmount(ctx) {
        const { params } = ctx;
        validator_1.validator.validate(schemas_1.getLockedStakedAmountRequestSchema, params);
        const amount = await this._internalMethod.getLockedStakedAmount(ctx, cryptography_1.address.getAddressFromKlayr32Address(params.address));
        return {
            amount: amount.toString(),
        };
    }
    async getConstants() {
        return {
            factorSelfStakes: this._moduleConfig.factorSelfStakes,
            maxLengthName: this._moduleConfig.maxLengthName,
            maxNumberSentStakes: this._moduleConfig.maxNumberSentStakes,
            maxNumberPendingUnlocks: this._moduleConfig.maxNumberPendingUnlocks,
            failSafeMissedBlocks: this._moduleConfig.failSafeMissedBlocks,
            failSafeInactiveWindow: this._moduleConfig.failSafeInactiveWindow,
            punishmentWindowStaking: this._moduleConfig.punishmentWindowStaking,
            punishmentWindowSelfStaking: this._moduleConfig.punishmentWindowSelfStaking,
            roundLength: this._moduleConfig.roundLength,
            minWeightStandby: this._moduleConfig.minWeightStandby.toString(),
            numberActiveValidators: this._moduleConfig.numberActiveValidators,
            numberStandbyValidators: this._moduleConfig.numberStandbyValidators,
            posTokenID: this._moduleConfig.posTokenID.toString('hex'),
            validatorRegistrationFee: this._moduleConfig.validatorRegistrationFee.toString(),
            maxBFTWeightCap: this._moduleConfig.maxBFTWeightCap,
            commissionIncreasePeriod: this._moduleConfig.commissionIncreasePeriod,
            maxCommissionIncreaseRate: this._moduleConfig.maxCommissionIncreaseRate,
            useInvalidBLSKey: this._moduleConfig.useInvalidBLSKey,
            baseStakeAmount: this._moduleConfig.baseStakeAmount.toString(),
            lockingPeriodStaking: this._moduleConfig.lockingPeriodStaking,
            lockingPeriodSelfStaking: this._moduleConfig.lockingPeriodSelfStaking,
            reportMisbehaviorReward: this._moduleConfig.reportMisbehaviorReward.toString(),
            reportMisbehaviorLimitBanned: this._moduleConfig.reportMisbehaviorLimitBanned,
            weightScaleFactor: this._moduleConfig.weightScaleFactor.toString(),
            defaultCommission: constants_1.COMMISSION,
        };
    }
    async getPendingUnlocks(ctx) {
        const { address } = ctx.params;
        if (typeof address !== 'string') {
            throw new Error('Parameter address must be a string.');
        }
        cryptography_1.address.validateKlayr32Address(address);
        const addressBytes = cryptography_1.address.getAddressFromKlayr32Address(address);
        const stakerSubStore = this.stores.get(staker_1.StakerStore);
        let stakerData;
        try {
            stakerData = await stakerSubStore.get(ctx, addressBytes);
        }
        catch (error) {
            if (!(error instanceof lisk_db_1.NotFoundError)) {
                throw error;
            }
            return {
                pendingUnlocks: [],
            };
        }
        const genesisDataStore = this.stores.get(genesis_1.GenesisDataStore);
        const { height: genesisHeight } = await genesisDataStore.get(ctx, constants_1.EMPTY_KEY);
        const result = [];
        for (const unlock of stakerData.pendingUnlocks) {
            const expectedUnlockableHeight = await this._getExpectedUnlockHeight(ctx, addressBytes, unlock.validatorAddress, unlock.unstakeHeight);
            const isCertified = (0, utils_2.isCertificateGenerated)({
                maxHeightCertified: ctx.header.aggregateCommit.height,
                roundLength: this._moduleConfig.roundLength,
                unlockObject: unlock,
                genesisHeight,
            });
            result.push({
                ...unlock,
                unlockable: ctx.header.height > expectedUnlockableHeight && isCertified,
                amount: unlock.amount.toString(),
                validatorAddress: cryptography_1.address.getKlayr32AddressFromAddress(unlock.validatorAddress),
                expectedUnlockableHeight,
            });
        }
        return {
            pendingUnlocks: result,
        };
    }
    async getPoSTokenID(_ctx) {
        return {
            tokenID: this._moduleConfig.posTokenID.toString('hex'),
        };
    }
    async getValidatorsByStake(ctx) {
        var _a;
        validator_1.validator.validate(schemas_1.getValidatorsByStakeRequestSchema, ctx.params);
        const limit = (_a = ctx.params.limit) !== null && _a !== void 0 ? _a : 100;
        const eligibleValidatorStore = this.stores.get(eligible_validators_1.EligibleValidatorsStore);
        const validatorSubStore = this.stores.get(validator_2.ValidatorStore);
        const response = [];
        let validatorsList;
        if (limit < -1) {
            throw new Error(`Input parameter limit ${limit} is not valid.`);
        }
        if (limit === -1) {
            validatorsList = await eligibleValidatorStore.getAll(ctx);
        }
        else {
            validatorsList = await eligibleValidatorStore.getTop(ctx, limit);
        }
        for (const { key } of validatorsList) {
            const [address] = eligibleValidatorStore.splitKey(key);
            const validatorAccount = await validatorSubStore.get(ctx, address);
            const validatorAccountJSON = {
                ...codec_1.codec.toJSON(validator_2.validatorStoreSchema, validatorAccount),
                address: cryptography_1.address.getKlayr32AddressFromAddress(address),
                punishmentPeriods: this._calculatePunishmentPeriods(validatorAccount.reportMisbehaviorHeights),
            };
            response.push(validatorAccountJSON);
        }
        return { validators: response };
    }
    async getLockedReward(ctx) {
        validator_1.validator.validate(schemas_1.getLockedRewardRequestSchema, ctx.params);
        const tokenID = Buffer.from(ctx.params.tokenID, 'hex');
        const address = cryptography_1.address.getAddressFromKlayr32Address(ctx.params.address);
        let locked = await this._tokenMethod.getLockedAmount(ctx.getImmutableMethodContext(), address, tokenID, this._moduleName);
        if (!tokenID.equals(this._moduleConfig.posTokenID)) {
            return {
                reward: locked.toString(),
            };
        }
        const lockedAmountForStakes = await this._internalMethod.getLockedStakedAmount(ctx, address);
        locked -= lockedAmountForStakes;
        return {
            reward: locked.toString(),
        };
    }
    async getClaimableRewards(context) {
        var _a, _b;
        validator_1.validator.validate(schemas_1.getClaimableRewardsRequestSchema, context.params);
        const rewards = new utils_1.dataStructures.BufferMap();
        const address = cryptography_1.address.getAddressFromKlayr32Address(context.params.address);
        const { stakes } = await this.stores.get(staker_1.StakerStore).getOrDefault(context, address);
        for (const stake of stakes) {
            if (stake.validatorAddress.equals(address)) {
                continue;
            }
            const validatorAccount = await this.stores
                .get(validator_2.ValidatorStore)
                .get(context, stake.validatorAddress);
            for (const validatorSharingCoefficient of validatorAccount.sharingCoefficients) {
                const stakeSharingCoefficient = (_a = stake.sharingCoefficients.find(sc => sc.tokenID.equals(validatorSharingCoefficient.tokenID))) !== null && _a !== void 0 ? _a : {
                    tokenID: validatorSharingCoefficient.tokenID,
                    coefficient: q96(BigInt(0)).toBuffer(),
                };
                const reward = (0, utils_2.calculateStakeRewards)(stakeSharingCoefficient, stake.amount, validatorSharingCoefficient);
                const currentReward = (_b = rewards.get(validatorSharingCoefficient.tokenID)) !== null && _b !== void 0 ? _b : BigInt(0);
                rewards.set(validatorSharingCoefficient.tokenID, reward + currentReward);
            }
        }
        return {
            rewards: rewards.entries().map(([tokenID, reward]) => ({
                tokenID: tokenID.toString('hex'),
                reward: reward.toString(),
            })),
        };
    }
    getRegistrationFee() {
        return {
            fee: this._moduleConfig.validatorRegistrationFee.toString(),
        };
    }
    async getExpectedSharedRewards(ctx) {
        validator_1.validator.validate(schemas_1.getExpectedSharedRewardsRequestSchema, ctx.params);
        const validatorReward = q96(BigInt(ctx.params.validatorReward));
        const validatorAccount = await this.stores
            .get(validator_2.ValidatorStore)
            .get(ctx, cryptography_1.address.getAddressFromKlayr32Address(ctx.params.validatorAddress));
        const commission = q96(validatorAccount.commission).div(q96(BigInt(10000)));
        const rewardFraction = q96(BigInt(1)).sub(commission);
        const totalStake = q96(BigInt(validatorAccount.totalStake) + BigInt(ctx.params.stake));
        const rewardPerUnitStaked = validatorReward.muldiv(rewardFraction, totalStake);
        const reward = rewardPerUnitStaked.mul(q96(BigInt(ctx.params.stake)));
        return {
            reward: reward.floor().toString(),
        };
    }
    async _getExpectedUnlockHeight(ctx, callerAddress, validatorAddress, unstakeHeight) {
        const validatorSubStore = this.stores.get(validator_2.ValidatorStore);
        const validatorAccount = await validatorSubStore.get(ctx, validatorAddress);
        const waitTime = (0, utils_2.getWaitTime)(callerAddress, validatorAddress, this._punishmentLockingPeriods) + unstakeHeight;
        if (!validatorAccount.reportMisbehaviorHeights.length) {
            return waitTime;
        }
        const lastPomHeight = validatorAccount.reportMisbehaviorHeights[validatorAccount.reportMisbehaviorHeights.length - 1];
        if (lastPomHeight >= unstakeHeight + waitTime) {
            return waitTime;
        }
        return Math.max((0, utils_2.getPunishTime)(callerAddress, validatorAddress, this._punishmentLockingPeriods) +
            lastPomHeight, waitTime);
    }
    _calculatePunishmentPeriods(pomHeights, period = this._punishmentLockingPeriods.punishmentWindowSelfStaking) {
        const result = [];
        for (const pomHeight of pomHeights) {
            result.push({
                start: pomHeight,
                end: pomHeight + period,
            });
        }
        return result;
    }
}
exports.PoSEndpoint = PoSEndpoint;
//# sourceMappingURL=endpoint.js.map