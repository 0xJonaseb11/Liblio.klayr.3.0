"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoSModule = void 0;
const cryptography_1 = require("@klayr/cryptography");
const utils_1 = require("@klayr/utils");
const validator_1 = require("@klayr/validator");
const codec_1 = require("@klayr/codec");
const base_module_1 = require("../base_module");
const method_1 = require("./method");
const register_validator_1 = require("./commands/register_validator");
const report_misbehavior_1 = require("./commands/report_misbehavior");
const unlock_1 = require("./commands/unlock");
const update_generator_key_1 = require("./commands/update_generator_key");
const stake_1 = require("./commands/stake");
const change_commission_1 = require("./commands/change_commission");
const constants_1 = require("./constants");
const endpoint_1 = require("./endpoint");
const schemas_1 = require("./schemas");
const utils_2 = require("./utils");
const validator_2 = require("./stores/validator");
const genesis_1 = require("./stores/genesis");
const name_1 = require("./stores/name");
const previous_timestamp_1 = require("./stores/previous_timestamp");
const snapshot_1 = require("./stores/snapshot");
const staker_1 = require("./stores/staker");
const eligible_validators_1 = require("./stores/eligible_validators");
const validator_banned_1 = require("./events/validator_banned");
const validator_punished_1 = require("./events/validator_punished");
const validator_registered_1 = require("./events/validator_registered");
const validator_staked_1 = require("./events/validator_staked");
const internal_method_1 = require("./internal_method");
const commission_change_1 = require("./events/commission_change");
const claim_rewards_1 = require("./commands/claim_rewards");
const utils_3 = require("../interoperability/utils");
const rewards_assigned_1 = require("./events/rewards_assigned");
const utils_4 = require("../utils");
class PoSModule extends base_module_1.BaseModule {
    constructor() {
        super();
        this.method = new method_1.PoSMethod(this.stores, this.events);
        this.configSchema = schemas_1.configSchema;
        this.endpoint = new endpoint_1.PoSEndpoint(this.stores, this.offchainStores);
        this._registerValidatorCommand = new register_validator_1.RegisterValidatorCommand(this.stores, this.events);
        this._reportMisbehaviorCommand = new report_misbehavior_1.ReportMisbehaviorCommand(this.stores, this.events);
        this._unlockCommand = new unlock_1.UnlockCommand(this.stores, this.events);
        this._updateGeneratorKeyCommand = new update_generator_key_1.UpdateGeneratorKeyCommand(this.stores, this.events);
        this._stakeCommand = new stake_1.StakeCommand(this.stores, this.events);
        this._changeCommissionCommand = new change_commission_1.ChangeCommissionCommand(this.stores, this.events);
        this._claimRewardsCommand = new claim_rewards_1.ClaimRewardsCommand(this.stores, this.events);
        this.commands = [
            this._registerValidatorCommand,
            this._reportMisbehaviorCommand,
            this._unlockCommand,
            this._updateGeneratorKeyCommand,
            this._stakeCommand,
            this._changeCommissionCommand,
            this._claimRewardsCommand,
        ];
        this._internalMethod = new internal_method_1.InternalMethod(this.stores, this.events, this.name);
        this.stores.register(staker_1.StakerStore, new staker_1.StakerStore(this.name, 0));
        this.stores.register(validator_2.ValidatorStore, new validator_2.ValidatorStore(this.name, 1));
        this.stores.register(name_1.NameStore, new name_1.NameStore(this.name, 2));
        this.stores.register(snapshot_1.SnapshotStore, new snapshot_1.SnapshotStore(this.name, 3));
        this.stores.register(genesis_1.GenesisDataStore, new genesis_1.GenesisDataStore(this.name, 4));
        this.stores.register(previous_timestamp_1.PreviousTimestampStore, new previous_timestamp_1.PreviousTimestampStore(this.name, 5));
        this.stores.register(eligible_validators_1.EligibleValidatorsStore, new eligible_validators_1.EligibleValidatorsStore(this.name, 6));
        this.events.register(validator_banned_1.ValidatorBannedEvent, new validator_banned_1.ValidatorBannedEvent(this.name));
        this.events.register(validator_punished_1.ValidatorPunishedEvent, new validator_punished_1.ValidatorPunishedEvent(this.name));
        this.events.register(validator_registered_1.ValidatorRegisteredEvent, new validator_registered_1.ValidatorRegisteredEvent(this.name));
        this.events.register(validator_staked_1.ValidatorStakedEvent, new validator_staked_1.ValidatorStakedEvent(this.name));
        this.events.register(commission_change_1.CommissionChangeEvent, new commission_change_1.CommissionChangeEvent(this.name));
        this.events.register(rewards_assigned_1.RewardsAssignedEvent, new rewards_assigned_1.RewardsAssignedEvent(this.name));
    }
    get name() {
        return 'pos';
    }
    addDependencies(randomMethod, validatorsMethod, tokenMethod, feeMethod) {
        this._randomMethod = randomMethod;
        this._validatorsMethod = validatorsMethod;
        this._tokenMethod = tokenMethod;
        this._feeMethod = feeMethod;
        this._internalMethod.addDependencies(this._tokenMethod);
        this._registerValidatorCommand.addDependencies(this._validatorsMethod, this._feeMethod);
        this._reportMisbehaviorCommand.addDependencies({
            tokenMethod: this._tokenMethod,
            validatorsMethod: this._validatorsMethod,
        });
        this._unlockCommand.addDependencies({
            tokenMethod: this._tokenMethod,
        });
        this._updateGeneratorKeyCommand.addDependencies(this._validatorsMethod);
        this._stakeCommand.addDependencies({
            tokenMethod: this._tokenMethod,
            internalMethod: this._internalMethod,
        });
        this._claimRewardsCommand.addDependencies({
            internalMethod: this._internalMethod,
        });
    }
    metadata() {
        return {
            ...this.baseMetadata(),
            endpoints: [
                {
                    name: this.endpoint.getAllValidators.name,
                    response: schemas_1.getAllValidatorsResponseSchema,
                },
                {
                    name: this.endpoint.getValidator.name,
                    request: schemas_1.getValidatorRequestSchema,
                    response: schemas_1.getValidatorResponseSchema,
                },
                {
                    name: this.endpoint.getStaker.name,
                    request: schemas_1.getStakerRequestSchema,
                    response: schemas_1.getStakerResponseSchema,
                },
                {
                    name: this.endpoint.getConstants.name,
                    response: schemas_1.getConstantsResponseSchema,
                },
                {
                    name: this.endpoint.getPoSTokenID.name,
                    response: schemas_1.getPoSTokenIDResponseSchema,
                },
                {
                    name: this.endpoint.getClaimableRewards.name,
                    request: schemas_1.getClaimableRewardsRequestSchema,
                    response: schemas_1.getClaimableRewardsResponseSchema,
                },
                {
                    name: this.endpoint.getLockedReward.name,
                    request: schemas_1.getLockedRewardRequestSchema,
                    response: schemas_1.getLockedRewardResponseSchema,
                },
                {
                    name: this.endpoint.getLockedStakedAmount.name,
                    request: schemas_1.getLockedStakedAmountRequestSchema,
                    response: schemas_1.getLockedStakedAmountResponseSchema,
                },
                {
                    name: this.endpoint.getValidatorsByStake.name,
                    request: schemas_1.getValidatorsByStakeRequestSchema,
                    response: schemas_1.getValidatorsByStakeResponseSchema,
                },
                {
                    name: this.endpoint.getPendingUnlocks.name,
                    request: schemas_1.getPendingUnlocksRequestSchema,
                    response: schemas_1.getPendingUnlocksResponseSchema,
                },
                {
                    name: this.endpoint.getRegistrationFee.name,
                    response: schemas_1.getRegistrationFeeResponseSchema,
                },
                {
                    name: this.endpoint.getExpectedSharedRewards.name,
                    request: schemas_1.getExpectedSharedRewardsRequestSchema,
                    response: schemas_1.getExpectedSharedRewardsResponseSchema,
                },
            ],
            assets: [
                {
                    version: 0,
                    data: schemas_1.genesisStoreSchema,
                },
            ],
        };
    }
    async init(args) {
        const { moduleConfig } = args;
        const config = utils_1.objects.mergeDeep({}, {
            ...constants_1.defaultConfig,
            posTokenID: `${args.genesisConfig.chainID}${Buffer.alloc(4).toString('hex')}`,
        }, moduleConfig);
        validator_1.validator.validate(this._getConfigSchema(args.genesisConfig.blockTime), config);
        this._moduleConfig = (0, utils_2.getModuleConfig)(config);
        const punishmentLockingPeriods = {
            punishmentWindowStaking: this._moduleConfig.punishmentWindowStaking,
            punishmentWindowSelfStaking: this._moduleConfig.punishmentWindowSelfStaking,
            lockingPeriodStaking: this._moduleConfig.lockingPeriodStaking,
            lockingPeriodSelfStaking: this._moduleConfig.lockingPeriodSelfStaking,
        };
        this.method.init(this.name, this._moduleConfig, this._internalMethod, this._tokenMethod);
        this.endpoint.init(this.name, this._moduleConfig, this._internalMethod, this._tokenMethod, punishmentLockingPeriods);
        this._reportMisbehaviorCommand.init({
            posTokenID: this._moduleConfig.posTokenID,
            factorSelfStakes: this._moduleConfig.factorSelfStakes,
            lockingPeriodSelfStaking: this._moduleConfig.lockingPeriodSelfStaking,
            reportMisbehaviorReward: this._moduleConfig.reportMisbehaviorReward,
            reportMisbehaviorLimitBanned: this._moduleConfig.reportMisbehaviorLimitBanned,
            punishmentLockingPeriods,
        });
        this._registerValidatorCommand.init({
            validatorRegistrationFee: this._moduleConfig.validatorRegistrationFee,
        });
        this._unlockCommand.init({
            posTokenID: this._moduleConfig.posTokenID,
            roundLength: this._moduleConfig.roundLength,
            punishmentLockingPeriods,
        });
        this._stakeCommand.init({
            posTokenID: this._moduleConfig.posTokenID,
            factorSelfStakes: this._moduleConfig.factorSelfStakes,
            baseStakeAmount: this._moduleConfig.baseStakeAmount,
            maxNumberPendingUnlocks: this._moduleConfig.maxNumberPendingUnlocks,
            maxNumberSentStakes: this._moduleConfig.maxNumberSentStakes,
        });
        this._changeCommissionCommand.init({
            commissionIncreasePeriod: this._moduleConfig.commissionIncreasePeriod,
            maxCommissionIncreaseRate: this._moduleConfig.maxCommissionIncreaseRate,
        });
        this.stores.get(eligible_validators_1.EligibleValidatorsStore).init(this._moduleConfig);
    }
    async initGenesisState(context) {
        var _a, _b;
        const assetBytes = context.assets.getAsset(this.name);
        if (!assetBytes) {
            return;
        }
        const genesisStore = codec_1.codec.decode(schemas_1.genesisStoreSchema, assetBytes);
        validator_1.validator.validate(schemas_1.genesisStoreSchema, genesisStore);
        const posValidatorAddresses = [];
        const posValidatorNames = [];
        const posValidatorAddressMap = new utils_1.dataStructures.BufferMap();
        for (const posValidator of genesisStore.validators) {
            if (!(0, utils_2.isUsername)(posValidator.name)) {
                throw new Error(`Invalid validator name ${posValidator.name}.`);
            }
            if (posValidator.lastCommissionIncreaseHeight > context.header.height) {
                throw new Error(`Invalid lastCommissionIncreaseHeight ${posValidator.lastCommissionIncreaseHeight} for ${cryptography_1.address.getKlayr32AddressFromAddress(posValidator.address)}.`);
            }
            if (!(0, utils_2.isSharingCoefficientSorted)(posValidator.sharingCoefficients)) {
                throw new Error('SharingCoefficients must be sorted by tokenID.');
            }
            posValidatorAddressMap.set(posValidator.address, posValidator);
            posValidatorAddresses.push(posValidator.address);
            posValidatorNames.push(posValidator.name);
        }
        if (!utils_1.objects.bufferArrayUniqueItems(posValidatorAddresses)) {
            throw new Error('Validator address is not unique.');
        }
        if (new Set(posValidatorNames).size !== posValidatorNames.length) {
            throw new Error('Validator name is not unique.');
        }
        const stakerAddresses = [];
        for (const staker of genesisStore.stakers) {
            if (staker.stakes.length > constants_1.MAX_NUMBER_SENT_STAKES) {
                throw new Error(`Sent stake exceeds max stake ${constants_1.MAX_NUMBER_SENT_STAKES}.`);
            }
            if (!utils_1.objects.bufferArrayUniqueItems(staker.stakes.map(v => v.validatorAddress))) {
                throw new Error('Sent stake validator address is not unique.');
            }
            if (!utils_1.objects.isBufferArrayOrdered(staker.stakes.map(v => v.validatorAddress))) {
                throw new Error('Sent stake validator address is not lexicographically ordered.');
            }
            for (const stakes of staker.stakes) {
                const posValidator = posValidatorAddressMap.get(stakes.validatorAddress);
                if (!posValidator) {
                    throw new Error('Sent stake includes non existing validator address.');
                }
                for (const sharingCoefficient of stakes.sharingCoefficients) {
                    const targetCoefficient = posValidator.sharingCoefficients.find(co => co.tokenID.equals(sharingCoefficient.tokenID));
                    if (!targetCoefficient ||
                        sharingCoefficient.coefficient.compare(targetCoefficient.coefficient) > 0) {
                        throw new Error('Validator does not have corresponding sharing coefficient or the coefficient value is not consistent.');
                    }
                }
                if (!(0, utils_2.isSharingCoefficientSorted)(stakes.sharingCoefficients)) {
                    throw new Error('stakeSharingCoefficients must be sorted by tokenID.');
                }
            }
            if (staker.pendingUnlocks.length > this._moduleConfig.maxNumberPendingUnlocks) {
                throw new Error(`PendingUnlocks exceeds max unlocking ${this._moduleConfig.maxNumberPendingUnlocks}.`);
            }
            const sortingPendingUnlocks = [...staker.pendingUnlocks];
            (0, utils_2.sortUnlocking)(sortingPendingUnlocks);
            for (let i = 0; i < staker.pendingUnlocks.length; i += 1) {
                const original = staker.pendingUnlocks[i];
                const target = sortingPendingUnlocks[i];
                if (!(0, utils_2.equalUnlocking)(original, target)) {
                    throw new Error('PendingUnlocks are not lexicographically ordered.');
                }
            }
            if (staker.pendingUnlocks.some(v => !posValidatorAddressMap.has(v.validatorAddress))) {
                throw new Error('Pending unlocks includes non existing validator address.');
            }
            stakerAddresses.push(staker.address);
        }
        if (!utils_1.objects.bufferArrayUniqueItems(stakerAddresses)) {
            throw new Error('Staker address is not unique.');
        }
        if (!utils_1.objects.bufferArrayUniqueItems(genesisStore.genesisData.initValidators)) {
            throw new Error('Init validators address is not unique.');
        }
        if (genesisStore.genesisData.initValidators.some(v => !posValidatorAddressMap.has(v))) {
            throw new Error('Init validators includes non existing validator address.');
        }
        if (genesisStore.genesisData.initValidators.length > this._moduleConfig.numberActiveValidators) {
            throw new Error(`Init validators is greater than number of active validators ${this._moduleConfig.numberActiveValidators}.`);
        }
        const stakerStore = this.stores.get(staker_1.StakerStore);
        const stakeMap = new utils_1.dataStructures.BufferMap();
        for (const staker of genesisStore.stakers) {
            for (const sentStake of staker.stakes) {
                const validatorData = (_a = stakeMap.get(sentStake.validatorAddress)) !== null && _a !== void 0 ? _a : {
                    selfStake: BigInt(0),
                    stakeReceived: BigInt(0),
                };
                validatorData.stakeReceived += sentStake.amount;
                if (!(0, validator_1.isUInt64)(validatorData.stakeReceived)) {
                    throw new Error('Stakes received out of range.');
                }
                if (sentStake.validatorAddress.equals(staker.address)) {
                    validatorData.selfStake += sentStake.amount;
                    if (!(0, validator_1.isUInt64)(validatorData.selfStake)) {
                        throw new Error('Self stake out of range.');
                    }
                }
                stakeMap.set(sentStake.validatorAddress, validatorData);
            }
            await stakerStore.set(context, staker.address, {
                stakes: staker.stakes,
                pendingUnlocks: staker.pendingUnlocks,
            });
        }
        const validatorStore = this.stores.get(validator_2.ValidatorStore);
        const nameSubstore = this.stores.get(name_1.NameStore);
        for (const posValidator of genesisStore.validators) {
            const stakeInfo = (_b = stakeMap.get(posValidator.address)) !== null && _b !== void 0 ? _b : {
                selfStake: BigInt(0),
                stakeReceived: BigInt(0),
            };
            await validatorStore.set(context, posValidator.address, {
                name: posValidator.name,
                totalStake: stakeInfo.stakeReceived,
                selfStake: stakeInfo.selfStake,
                lastGeneratedHeight: posValidator.lastGeneratedHeight,
                isBanned: posValidator.isBanned,
                reportMisbehaviorHeights: posValidator.reportMisbehaviorHeights,
                consecutiveMissedBlocks: posValidator.consecutiveMissedBlocks,
                commission: posValidator.commission,
                lastCommissionIncreaseHeight: posValidator.lastCommissionIncreaseHeight,
                sharingCoefficients: posValidator.sharingCoefficients,
            });
            await nameSubstore.set(context, Buffer.from(posValidator.name, 'utf-8'), {
                validatorAddress: posValidator.address,
            });
        }
        const previousTimestampStore = this.stores.get(previous_timestamp_1.PreviousTimestampStore);
        await previousTimestampStore.set(context, constants_1.EMPTY_KEY, {
            timestamp: context.header.timestamp,
        });
        const genesisDataStore = this.stores.get(genesis_1.GenesisDataStore);
        await genesisDataStore.set(context, constants_1.EMPTY_KEY, {
            height: context.header.height,
            initRounds: genesisStore.genesisData.initRounds,
            initValidators: genesisStore.genesisData.initValidators,
        });
    }
    async finalizeGenesisState(context) {
        const assetBytes = context.assets.getAsset(this.name);
        if (!assetBytes) {
            return;
        }
        const genesisStore = codec_1.codec.decode(schemas_1.genesisStoreSchema, assetBytes);
        const methodContext = context.getMethodContext();
        if (this._moduleConfig.useInvalidBLSKey &&
            context.chainID.equals((0, utils_3.getMainchainID)(context.chainID))) {
            for (const posValidator of genesisStore.validators) {
                await this._validatorsMethod.registerValidatorWithoutBLSKey(methodContext, posValidator.address, posValidator.generatorKey);
            }
        }
        else {
            for (const posValidator of genesisStore.validators) {
                await this._validatorsMethod.registerValidatorKeys(methodContext, posValidator.address, posValidator.blsKey, posValidator.generatorKey, posValidator.proofOfPossession);
            }
        }
        const stakerStore = this.stores.get(staker_1.StakerStore);
        const allStakers = await stakerStore.iterate(context, {
            gte: Buffer.alloc(20),
            lte: Buffer.alloc(20, 255),
        });
        for (const stakerData of allStakers) {
            let stakedAmount = BigInt(0);
            for (const sentStakes of stakerData.value.stakes) {
                stakedAmount += sentStakes.amount;
            }
            for (const pendingUnlock of stakerData.value.pendingUnlocks) {
                stakedAmount += pendingUnlock.amount;
            }
            const lockedAmount = await this._tokenMethod.getLockedAmount(methodContext, stakerData.key, this._moduleConfig.posTokenID, this.name);
            if (lockedAmount !== stakedAmount) {
                throw new Error('Staked amount is not locked');
            }
        }
        const initValidators = [...genesisStore.genesisData.initValidators];
        initValidators.sort((a, b) => a.compare(b));
        const validators = [];
        let aggregateBFTWeight = BigInt(0);
        for (const validatorAddress of initValidators) {
            validators.push({
                address: validatorAddress,
                bftWeight: BigInt(1),
            });
            aggregateBFTWeight += BigInt(1);
        }
        const precommitThreshold = (BigInt(2) * aggregateBFTWeight) / BigInt(3) + BigInt(1);
        const certificateThreshold = precommitThreshold;
        await this._validatorsMethod.setValidatorsParams(context.getMethodContext(), context, precommitThreshold, certificateThreshold, validators);
    }
    async afterTransactionsExecute(context) {
        const { header } = context;
        const isLastBlockOfRound = await this.method.isEndOfRound(context.getMethodContext(), header.height);
        const previousTimestampStore = this.stores.get(previous_timestamp_1.PreviousTimestampStore);
        const previousTimestampData = await previousTimestampStore.get(context, constants_1.EMPTY_KEY);
        const { timestamp: previousTimestamp } = previousTimestampData;
        await this._updateProductivity(context, previousTimestamp);
        if (isLastBlockOfRound) {
            await this._createStakeWeightSnapshot(context);
        }
        const didBootstrapRoundsEnd = await this._didBootstrapRoundsEnd(context);
        if (isLastBlockOfRound && didBootstrapRoundsEnd) {
            await this._updateValidators(context);
        }
        await previousTimestampStore.set(context, constants_1.EMPTY_KEY, { timestamp: header.timestamp });
    }
    async _createStakeWeightSnapshot(context) {
        const snapshotHeight = context.header.height + 1;
        const round = await this.method.getRoundNumberFromHeight(context.getMethodContext(), snapshotHeight);
        const snapshotRound = round + constants_1.VALIDATOR_LIST_ROUND_OFFSET;
        context.logger.debug(`Creating stake weight snapshot for round: ${snapshotRound.toString()}`);
        const eligibleValidatorStore = this.stores.get(eligible_validators_1.EligibleValidatorsStore);
        const eligibleValidatorsList = await eligibleValidatorStore.getAll(context);
        const validatorWeightSnapshot = [];
        for (const { key, value } of eligibleValidatorsList) {
            if (value.lastReportMisbehaviorHeight === 0 ||
                value.lastReportMisbehaviorHeight <
                    snapshotHeight - this._moduleConfig.punishmentWindowSelfStaking) {
                const [address, weight] = eligibleValidatorStore.splitKey(key);
                validatorWeightSnapshot.push({ address, weight });
            }
        }
        const snapshotData = {
            validatorWeightSnapshot,
        };
        const snapshotStore = this.stores.get(snapshot_1.SnapshotStore);
        const storeKey = cryptography_1.utils.intToBuffer(snapshotRound, 4);
        await snapshotStore.set(context, storeKey, snapshotData);
        const oldData = await snapshotStore.iterate(context, {
            gte: cryptography_1.utils.intToBuffer(0, 4),
            lte: cryptography_1.utils.intToBuffer(Math.max(0, snapshotRound - constants_1.VALIDATOR_LIST_ROUND_OFFSET - 1), 4),
        });
        for (const { key } of oldData) {
            await snapshotStore.del(context, key);
        }
    }
    async _updateValidators(context) {
        const { height } = context.header;
        const round = await this.method.getRoundNumberFromHeight(context.getMethodContext(), height);
        const nextRound = round + 1;
        context.logger.debug(nextRound, 'Updating validator list for');
        const snapshotStore = this.stores.get(snapshot_1.SnapshotStore);
        const snapshot = await snapshotStore.get(context, cryptography_1.utils.intToBuffer(nextRound, 4));
        const genesisData = await this.stores.get(genesis_1.GenesisDataStore).get(context, constants_1.EMPTY_KEY);
        const methodContext = context.getMethodContext();
        const activeValidators = await this._getActiveValidators(context, snapshot.validatorWeightSnapshot, nextRound);
        const validators = [];
        const activeValidatorMap = new utils_1.dataStructures.BufferMap();
        for (const v of activeValidators) {
            activeValidatorMap.set(v.address, true);
            validators.push(v);
        }
        const randomSeed1 = await this._randomMethod.getRandomBytes(methodContext, height + 1 - Math.floor((this._moduleConfig.roundLength * 3) / 2), this._moduleConfig.roundLength);
        let standbyValidators = [];
        if (nextRound >= genesisData.initRounds + this._moduleConfig.numberActiveValidators) {
            const candidates = snapshot.validatorWeightSnapshot.filter(v => !activeValidatorMap.has(v.address));
            if (this._moduleConfig.numberStandbyValidators === 2) {
                const randomSeed2 = await this._randomMethod.getRandomBytes(methodContext, height + 1 - 2 * this._moduleConfig.roundLength, this._moduleConfig.roundLength);
                standbyValidators = (0, utils_2.selectStandbyValidators)(candidates, randomSeed1, randomSeed2);
                validators.push(...standbyValidators);
            }
            else if (this._moduleConfig.numberStandbyValidators === 1) {
                standbyValidators = (0, utils_2.selectStandbyValidators)(candidates, randomSeed1);
                validators.push(...standbyValidators);
            }
        }
        if (validators.length === 0) {
            return;
        }
        const shuffledValidators = (0, utils_4.shuffleValidatorList)(randomSeed1, validators);
        let aggregateBFTWeight = BigInt(0);
        const bftValidators = [];
        for (const v of shuffledValidators) {
            aggregateBFTWeight += v.weight;
            bftValidators.push({
                address: v.address,
                bftWeight: v.weight,
            });
        }
        const precommitThreshold = (BigInt(2) * aggregateBFTWeight) / BigInt(3) + BigInt(1);
        const certificateThreshold = precommitThreshold;
        await this._validatorsMethod.setValidatorsParams(context.getMethodContext(), context, precommitThreshold, certificateThreshold, bftValidators);
    }
    async _updateProductivity(context, previousTimestamp) {
        const { logger, header, getMethodContext } = context;
        const methodContext = getMethodContext();
        const round = await this.method.getRoundNumberFromHeight(methodContext, header.height);
        logger.debug({ round }, 'Updating validators productivity for round');
        const newHeight = header.height;
        const missedBlocks = await this._validatorsMethod.getGeneratorsBetweenTimestamps(methodContext, previousTimestamp, header.timestamp);
        const validatorStore = this.stores.get(validator_2.ValidatorStore);
        const eligibleValidatorStore = this.stores.get(eligible_validators_1.EligibleValidatorsStore);
        for (const addressString of Object.keys(missedBlocks)) {
            const address = Buffer.from(addressString, 'binary');
            const validatorData = await validatorStore.get(context, address);
            validatorData.consecutiveMissedBlocks += missedBlocks[addressString];
            if (validatorData.consecutiveMissedBlocks > this._moduleConfig.failSafeMissedBlocks &&
                newHeight - validatorData.lastGeneratedHeight > this._moduleConfig.failSafeInactiveWindow) {
                validatorData.isBanned = true;
                await eligibleValidatorStore.update(context, address, (0, utils_2.getValidatorWeight)(this._moduleConfig.factorSelfStakes, validatorData.selfStake, validatorData.totalStake), validatorData);
            }
            await validatorStore.set(context, address, validatorData);
        }
        const generator = await validatorStore.get(context, header.generatorAddress);
        generator.consecutiveMissedBlocks = 0;
        generator.lastGeneratedHeight = newHeight;
        await validatorStore.set(context, header.generatorAddress, generator);
    }
    async _didBootstrapRoundsEnd(context) {
        const { header } = context;
        const genesisDataStore = this.stores.get(genesis_1.GenesisDataStore);
        const genesisData = await genesisDataStore.get(context, constants_1.EMPTY_KEY);
        const { initRounds } = genesisData;
        const nextHeightRound = await this.method.getRoundNumberFromHeight(context.getMethodContext(), header.height + 1);
        return nextHeightRound > initRounds;
    }
    async _getActiveValidators(context, snapshotValidators, round) {
        const genesisData = await this.stores.get(genesis_1.GenesisDataStore).get(context, constants_1.EMPTY_KEY);
        if (round < genesisData.initRounds + this._moduleConfig.numberActiveValidators) {
            const numInitValidators = genesisData.initRounds + this._moduleConfig.numberActiveValidators - round;
            const numElectedValidators = this._moduleConfig.numberActiveValidators - numInitValidators;
            let weightSum = BigInt(0);
            const activeValidators = snapshotValidators.slice(0, numElectedValidators).map(v => {
                const scaledWeight = this._ceiling(v.weight, this._moduleConfig.weightScaleFactor);
                weightSum += scaledWeight;
                return {
                    ...v,
                    weight: scaledWeight,
                };
            });
            if (activeValidators.length === 0) {
                return genesisData.initValidators.slice(0, numInitValidators).map(v => ({
                    address: v,
                    weight: BigInt(1),
                }));
            }
            const averageWeight = weightSum / BigInt(activeValidators.length);
            let addedInitValidators = 0;
            for (const address of genesisData.initValidators) {
                if (addedInitValidators === numInitValidators) {
                    break;
                }
                if (activeValidators.findIndex(d => d.address.equals(address)) > -1) {
                    continue;
                }
                activeValidators.push({ address, weight: averageWeight });
                addedInitValidators += 1;
            }
            return this._capWeightIfNeeded(activeValidators);
        }
        const activeValidators = snapshotValidators.length > this._moduleConfig.numberActiveValidators
            ? snapshotValidators.slice(0, this._moduleConfig.numberActiveValidators)
            : snapshotValidators;
        return this._capWeightIfNeeded(activeValidators.map(v => ({
            ...v,
            weight: this._ceiling(v.weight, this._moduleConfig.weightScaleFactor),
        })));
    }
    _capWeightIfNeeded(activeValidators) {
        const capValue = this._moduleConfig.maxBFTWeightCap;
        if (activeValidators.length < Math.ceil(constants_1.MAX_CAP / capValue)) {
            return activeValidators;
        }
        return this._capWeight(activeValidators, this._moduleConfig.maxBFTWeightCap);
    }
    _capWeight(validators, capValue) {
        const maxCappedElements = Math.ceil(constants_1.MAX_CAP / capValue) - 1;
        let partialSum = BigInt(0);
        for (let i = maxCappedElements + 1; i < validators.length; i += 1) {
            partialSum += validators[i].weight;
        }
        for (let i = maxCappedElements; i > 0; i -= 1) {
            partialSum += validators[i].weight;
            const cappedWeightRemainingElements = (BigInt(capValue) * partialSum) /
                BigInt(100) /
                (BigInt(100) - BigInt(capValue * i) / BigInt(100));
            if (cappedWeightRemainingElements < validators[i - 1].weight) {
                for (let j = 0; j < i; j += 1) {
                    validators[j].weight = cappedWeightRemainingElements;
                }
                return validators;
            }
        }
        return validators;
    }
    _ceiling(x, y) {
        if (y === BigInt(0)) {
            throw new Error('Cannot divide by zero.');
        }
        return (x + y - BigInt(1)) / y;
    }
    _getConfigSchema(blockTime = 10) {
        const SECONDS_IN_A_DAY = 60 * 60 * 24;
        const blocksPerDay = SECONDS_IN_A_DAY / blockTime;
        const posSchema = { ...schemas_1.configSchema };
        posSchema.properties.failSafeInactiveWindow.minimum = Math.floor(5 * blocksPerDay);
        posSchema.properties.failSafeInactiveWindow.maximum = Math.floor(365 * blocksPerDay);
        posSchema.properties.punishmentWindowSelfStaking.minimum = Math.floor(5 * blocksPerDay);
        posSchema.properties.punishmentWindowSelfStaking.maximum = Math.floor(365 * blocksPerDay);
        return posSchema;
    }
}
exports.PoSModule = PoSModule;
//# sourceMappingURL=module.js.map