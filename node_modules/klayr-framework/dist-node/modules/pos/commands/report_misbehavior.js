"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReportMisbehaviorCommand = void 0;
const chain_1 = require("@klayr/chain");
const state_machine_1 = require("../../../state_machine");
const base_command_1 = require("../../base_command");
const constants_1 = require("../constants");
const schemas_1 = require("../schemas");
const utils_1 = require("../utils");
const errors_1 = require("../../../errors");
const utils_2 = require("../../../engine/bft/utils");
const validator_1 = require("../stores/validator");
const validator_punished_1 = require("../events/validator_punished");
const validator_banned_1 = require("../events/validator_banned");
const eligible_validators_1 = require("../stores/eligible_validators");
const staker_1 = require("../stores/staker");
class ReportMisbehaviorCommand extends base_command_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.schema = schemas_1.reportMisbehaviorCommandParamsSchema;
    }
    addDependencies(args) {
        this._tokenMethod = args.tokenMethod;
        this._validatorsMethod = args.validatorsMethod;
    }
    init(args) {
        this._posTokenID = args.posTokenID;
        this._factorSelfStakes = args.factorSelfStakes;
        this._lockingPeriodSelfStaking = args.lockingPeriodSelfStaking;
        this._reportMisbehaviorReward = args.reportMisbehaviorReward;
        this._reportMisbehaviorLimitBanned = args.reportMisbehaviorLimitBanned;
        this._punishmentLockingPeriods = args.punishmentLockingPeriods;
    }
    async verify(context) {
        const { chainID, getMethodContext, params, header } = context;
        const currentHeight = header.height;
        const header1 = chain_1.BlockHeader.fromBytes(params.header1);
        const header2 = chain_1.BlockHeader.fromBytes(params.header2);
        if (!header1.generatorAddress.equals(header2.generatorAddress)) {
            throw new Error('Different generator address never contradict to each other.');
        }
        const validatorAddress = header1.generatorAddress;
        const validatorSubStore = this.stores.get(validator_1.ValidatorStore);
        const validatorAccount = await validatorSubStore.get(context, validatorAddress);
        const { generatorKey } = await this._validatorsMethod.getValidatorKeys(getMethodContext(), header1.generatorAddress);
        header1.validateSignature(generatorKey, chainID);
        header2.validateSignature(generatorKey, chainID);
        const maxPunishableHeight = Math.max(Math.abs(header1.height - currentHeight), Math.abs(header2.height - currentHeight));
        if (maxPunishableHeight >= this._lockingPeriodSelfStaking) {
            throw new Error('Locking period has expired.');
        }
        if ((0, utils_1.getPunishmentPeriod)(validatorAddress, validatorAddress, validatorAccount.reportMisbehaviorHeights, header.height, this._punishmentLockingPeriods) > 0) {
            throw new Error('Validator is already punished.');
        }
        if (validatorAccount.isBanned) {
            throw new Error('Validator is already banned.');
        }
        if (header1.id.equals(header2.id) || !(0, utils_2.areDistinctHeadersContradicting)(header1, header2)) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new errors_1.ValidationError('BlockHeaders are not contradicting as per BFT violation rules.', ''),
            };
        }
        return {
            status: state_machine_1.VerifyStatus.OK,
        };
    }
    async execute(context) {
        const { getMethodContext, params, transaction, header } = context;
        const currentHeight = header.height;
        const header1 = chain_1.BlockHeader.fromBytes(params.header1);
        const punishedAddress = header1.generatorAddress;
        const validatorSubStore = this.stores.get(validator_1.ValidatorStore);
        const validatorAccount = await validatorSubStore.get(context, punishedAddress);
        validatorAccount.reportMisbehaviorHeights.push(currentHeight);
        this.events.get(validator_punished_1.ValidatorPunishedEvent).log(context, {
            address: punishedAddress,
            height: currentHeight,
        });
        if (validatorAccount.reportMisbehaviorHeights.length === this._reportMisbehaviorLimitBanned) {
            validatorAccount.isBanned = true;
            this.events.get(validator_banned_1.ValidatorBannedEvent).log(context, {
                address: punishedAddress,
                height: currentHeight,
            });
        }
        const reward = this._reportMisbehaviorReward > validatorAccount.selfStake
            ? validatorAccount.selfStake
            : this._reportMisbehaviorReward;
        if (reward > BigInt(0)) {
            await this._tokenMethod.unlock(getMethodContext(), punishedAddress, constants_1.MODULE_NAME_POS, this._posTokenID, reward);
            await this._tokenMethod.transfer(getMethodContext(), punishedAddress, transaction.senderAddress, this._posTokenID, reward);
        }
        const oldWeight = (0, utils_1.getValidatorWeight)(this._factorSelfStakes, validatorAccount.selfStake, validatorAccount.totalStake);
        validatorAccount.selfStake -= reward;
        validatorAccount.totalStake -= reward;
        await validatorSubStore.set(context, punishedAddress, validatorAccount);
        const eligibleValidatorStore = this.stores.get(eligible_validators_1.EligibleValidatorsStore);
        await eligibleValidatorStore.update(context, punishedAddress, oldWeight, validatorAccount);
        const stakerSubStore = this.stores.get(staker_1.StakerStore);
        const stakerData = await stakerSubStore.get(context, punishedAddress);
        const existingStakeIndex = stakerData.stakes.findIndex(senderStake => senderStake.validatorAddress.equals(punishedAddress));
        stakerData.stakes[existingStakeIndex].amount -= reward;
        await stakerSubStore.set(context, punishedAddress, stakerData);
    }
}
exports.ReportMisbehaviorCommand = ReportMisbehaviorCommand;
//# sourceMappingURL=report_misbehavior.js.map