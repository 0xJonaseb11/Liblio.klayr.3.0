"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegisterValidatorCommand = void 0;
const state_machine_1 = require("../../../state_machine");
const base_command_1 = require("../../base_command");
const constants_1 = require("../constants");
const validator_registered_1 = require("../events/validator_registered");
const schemas_1 = require("../schemas");
const validator_1 = require("../stores/validator");
const name_1 = require("../stores/name");
const utils_1 = require("../utils");
class RegisterValidatorCommand extends base_command_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.schema = schemas_1.validatorRegistrationCommandParamsSchema;
    }
    addDependencies(validatorsMethod, feeMethod) {
        this._validatorsMethod = validatorsMethod;
        this._feeMethod = feeMethod;
    }
    init(args) {
        this._validatorRegistrationFee = args.validatorRegistrationFee;
    }
    async verify(context) {
        const { transaction, params } = context;
        if (!(0, utils_1.isUsername)(params.name)) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error(`'name' is in an unsupported format: ${params.name}`),
            };
        }
        const nameSubstore = this.stores.get(name_1.NameStore);
        const nameExists = await nameSubstore.has(context, Buffer.from(params.name, 'utf8'));
        if (nameExists) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error('Name substore must not have an entry for the store key name'),
            };
        }
        const validatorSubstore = this.stores.get(validator_1.ValidatorStore);
        const validatorExists = await validatorSubstore.has(context, transaction.senderAddress);
        if (validatorExists) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error('Validator substore must not have an entry for the store key address'),
            };
        }
        if (transaction.fee < this._validatorRegistrationFee) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error('Insufficient transaction fee.'),
            };
        }
        return {
            status: state_machine_1.VerifyStatus.OK,
        };
    }
    async execute(context) {
        const { transaction, params: { name, blsKey, generatorKey, proofOfPossession }, header: { height }, } = context;
        const methodContext = context.getMethodContext();
        await this._validatorsMethod.registerValidatorKeys(methodContext, transaction.senderAddress, blsKey, generatorKey, proofOfPossession);
        this._feeMethod.payFee(context, this._validatorRegistrationFee);
        const validatorSubstore = this.stores.get(validator_1.ValidatorStore);
        await validatorSubstore.set(context, transaction.senderAddress, {
            name,
            totalStake: BigInt(0),
            selfStake: BigInt(0),
            lastGeneratedHeight: height,
            isBanned: false,
            reportMisbehaviorHeights: [],
            consecutiveMissedBlocks: 0,
            commission: constants_1.COMMISSION,
            lastCommissionIncreaseHeight: height,
            sharingCoefficients: [],
        });
        const nameSubstore = this.stores.get(name_1.NameStore);
        await nameSubstore.set(context, Buffer.from(name, 'utf8'), {
            validatorAddress: transaction.senderAddress,
        });
        this.events.get(validator_registered_1.ValidatorRegisteredEvent).log(context, {
            address: transaction.senderAddress,
            name,
        });
    }
}
exports.RegisterValidatorCommand = RegisterValidatorCommand;
//# sourceMappingURL=register_validator.js.map