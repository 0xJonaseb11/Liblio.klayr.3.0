"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EligibleValidatorsStore = exports.eligibleValidatorsStoreSchema = void 0;
const base_store_1 = require("../../base_store");
const utils_1 = require("../utils");
exports.eligibleValidatorsStoreSchema = {
    $id: '/pos/eligibleValidators',
    type: 'object',
    required: ['lastReportMisbehaviorHeight'],
    properties: {
        lastReportMisbehaviorHeight: {
            dataType: 'uint32',
            fieldNumber: 1,
        },
    },
};
const KEY_LENGTH = 8 + 20;
class EligibleValidatorsStore extends base_store_1.BaseStore {
    constructor() {
        super(...arguments);
        this.schema = exports.eligibleValidatorsStoreSchema;
    }
    init(config) {
        this._config = config;
    }
    getKey(address, validatorWeight) {
        const buffer = Buffer.alloc(8);
        buffer.writeBigUInt64BE(validatorWeight);
        return Buffer.concat([buffer, address]);
    }
    async getTop(context, count) {
        return this.iterate(context, {
            gte: Buffer.alloc(KEY_LENGTH, 0),
            lte: Buffer.alloc(KEY_LENGTH, 255),
            limit: count,
            reverse: true,
        });
    }
    async getAll(context) {
        return this.iterate(context, {
            gte: Buffer.alloc(KEY_LENGTH, 0),
            lte: Buffer.alloc(KEY_LENGTH, 255),
            reverse: true,
        });
    }
    splitKey(key) {
        const weightBytes = key.subarray(0, 8);
        const address = key.subarray(8);
        return [address, weightBytes.readBigUInt64BE()];
    }
    async update(context, address, oldWeight, validator) {
        const oldKey = this.getKey(address, oldWeight);
        await this.del(context, oldKey);
        if (validator.isBanned) {
            return;
        }
        const newWeight = (0, utils_1.getValidatorWeight)(this._config.factorSelfStakes, validator.selfStake, validator.totalStake);
        if (newWeight < this._config.minWeightStandby) {
            return;
        }
        const lastReportMisbehaviorHeight = validator.reportMisbehaviorHeights.length
            ? validator.reportMisbehaviorHeights[validator.reportMisbehaviorHeights.length - 1]
            : 0;
        await this.set(context, this.getKey(address, newWeight), { lastReportMisbehaviorHeight });
    }
}
exports.EligibleValidatorsStore = EligibleValidatorsStore;
//# sourceMappingURL=eligible_validators.js.map