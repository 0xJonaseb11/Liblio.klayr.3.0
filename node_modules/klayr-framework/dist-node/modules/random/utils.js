"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bitwiseXOR = exports.getRandomSeed = exports.isSeedValidInput = void 0;
const cryptography_1 = require("@klayr/cryptography");
const constants_1 = require("./constants");
const isSeedValidInput = (generatorAddress, seedReveal, validatorReveals, previousSeedRequired = true) => {
    let lastSeed;
    for (let i = validatorReveals.length - 1; i >= 0; i -= 1) {
        const validatorReveal = validatorReveals[i];
        if (validatorReveal.generatorAddress.equals(generatorAddress)) {
            lastSeed = validatorReveal;
            break;
        }
    }
    if (!lastSeed) {
        return !previousSeedRequired;
    }
    return lastSeed.seedReveal.equals(cryptography_1.utils.hash(seedReveal).subarray(0, constants_1.SEED_LENGTH));
};
exports.isSeedValidInput = isSeedValidInput;
const getRandomSeed = (height, numberOfSeeds, validatorsReveal) => {
    if (!Number.isInteger(height) || !Number.isInteger(numberOfSeeds)) {
        throw new Error('Height or number of seeds cannot be non integer.');
    }
    if (height < 0 || numberOfSeeds < 0) {
        throw new Error('Height or number of seeds cannot be negative.');
    }
    const initRandomBuffer = cryptography_1.utils.intToBuffer(height + numberOfSeeds, 4);
    const currentSeeds = [cryptography_1.utils.hash(initRandomBuffer).subarray(0, 16)];
    let isInFuture = true;
    for (const validatorReveal of validatorsReveal) {
        if (validatorReveal.height >= height) {
            isInFuture = false;
            if (validatorReveal.height < height + numberOfSeeds && validatorReveal.valid) {
                currentSeeds.push(validatorReveal.seedReveal);
            }
        }
    }
    if (isInFuture) {
        throw new Error('Height is in the future.');
    }
    return (0, exports.bitwiseXOR)(currentSeeds);
};
exports.getRandomSeed = getRandomSeed;
const bitwiseXOR = (bufferArray) => {
    if (bufferArray.length === 0) {
        throw new Error('bitwiseXOR requires at least one buffer for the input.');
    }
    if (bufferArray.length === 1) {
        return bufferArray[0];
    }
    const size = bufferArray[0].length;
    for (let i = 1; i < bufferArray.length; i += 1) {
        if (bufferArray[i].length !== size) {
            throw new Error('All input for XOR should be same size');
        }
    }
    const result = Buffer.alloc(size);
    for (let i = 0; i < size; i += 1) {
        result[i] = bufferArray.map(b => b[i]).reduce((a, b) => a ^ b, 0);
    }
    return result;
};
exports.bitwiseXOR = bitwiseXOR;
//# sourceMappingURL=utils.js.map