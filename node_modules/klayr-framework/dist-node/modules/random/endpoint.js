"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RandomEndpoint = void 0;
const validator_1 = require("@klayr/validator");
const cryptography = require("@klayr/cryptography");
const lisk_db_1 = require("@liskhq/lisk-db");
const base_endpoint_1 = require("../base_endpoint");
const constants_1 = require("./constants");
const schemas_1 = require("./schemas");
const validator_reveals_1 = require("./stores/validator_reveals");
const utils_1 = require("./utils");
const hash_onion_1 = require("./stores/hash_onion");
const used_hash_onions_1 = require("./stores/used_hash_onions");
class RandomEndpoint extends base_endpoint_1.BaseEndpoint {
    async isSeedRevealValid(ctx) {
        validator_1.validator.validate(schemas_1.isSeedRevealValidRequestSchema, ctx.params);
        const { generatorAddress, seedReveal } = ctx.params;
        const randomDataStore = this.stores.get(validator_reveals_1.ValidatorRevealsStore);
        const { validatorReveals } = await randomDataStore.get(ctx, constants_1.EMPTY_KEY);
        return {
            valid: (0, utils_1.isSeedValidInput)(cryptography.address.getAddressFromKlayr32Address(generatorAddress), Buffer.from(seedReveal, 'hex'), validatorReveals, false),
        };
    }
    async setHashOnion(ctx) {
        var _a, _b;
        validator_1.validator.validate(schemas_1.hashOnionSchema, ctx.params);
        const address = cryptography.address.getAddressFromKlayr32Address(ctx.params.address);
        const seed = ctx.params.seed
            ? Buffer.from(ctx.params.seed, 'hex')
            : cryptography.utils.generateHashOnionSeed();
        const count = (_a = ctx.params.count) !== null && _a !== void 0 ? _a : constants_1.MAX_HASH_COMPUTATION;
        const distance = (_b = ctx.params.distance) !== null && _b !== void 0 ? _b : 1000;
        if (count % distance !== 0) {
            throw new Error('Invalid count. Count must be multiple of distance.');
        }
        let hashes;
        if (ctx.params.hashes) {
            if (!ctx.params.count || !ctx.params.distance) {
                throw new Error('Hashes must be provided with count and distance.');
            }
            const expectedLength = count / distance + 1;
            if (ctx.params.hashes.length !== expectedLength) {
                throw new Error(`Invalid length of hashes. hashes must have ${expectedLength} elements.`);
            }
            hashes = ctx.params.hashes.map(h => Buffer.from(h, 'hex'));
        }
        else {
            if (count > constants_1.MAX_HASH_COMPUTATION) {
                throw new Error(`Count is too big. In order to set count greater than ${constants_1.MAX_HASH_COMPUTATION}, please compute locally and request with "hashes".`);
            }
            hashes = cryptography.utils.hashOnion(seed, count, distance);
        }
        const hashOnion = { count, distance, hashes };
        const hashOnionStore = this.offchainStores.get(hash_onion_1.HashOnionStore);
        await hashOnionStore.set(ctx, address, hashOnion);
        const usedHashOnionStore = this.offchainStores.get(used_hash_onions_1.UsedHashOnionsStore);
        await usedHashOnionStore.set(ctx, address, { usedHashOnions: [{ count: 0, height: 0 }] });
    }
    async getHashOnionSeeds(ctx) {
        const hashOnionStore = this.offchainStores.get(hash_onion_1.HashOnionStore);
        const hashOnions = await hashOnionStore.iterate(ctx, {
            gte: Buffer.alloc(constants_1.ADDRESS_LENGTH, 0),
            lte: Buffer.alloc(constants_1.ADDRESS_LENGTH, 255),
        });
        const seeds = hashOnions.map(({ key, value }) => ({
            address: cryptography.address.getKlayr32AddressFromAddress(key),
            seed: value.hashes[value.hashes.length - 1].toString('hex'),
            count: value.count,
            distance: value.distance,
        }));
        return { seeds };
    }
    async hasHashOnion(ctx) {
        validator_1.validator.validate(schemas_1.addressSchema, ctx.params);
        const address = cryptography.address.getAddressFromKlayr32Address(ctx.params.address);
        const hashOnionStore = this.offchainStores.get(hash_onion_1.HashOnionStore);
        const hasSeed = await hashOnionStore.has(ctx, address);
        if (!hasSeed) {
            return {
                hasSeed: false,
                remaining: 0,
            };
        }
        const hashOnion = await hashOnionStore.get(ctx, address);
        const usedHashOnionStore = this.offchainStores.get(used_hash_onions_1.UsedHashOnionsStore);
        const usedHashOnion = await usedHashOnionStore.getLatest(ctx, address);
        if (!usedHashOnion) {
            return {
                hasSeed: true,
                remaining: hashOnion.count,
            };
        }
        if (usedHashOnion.count === hashOnion.count) {
            return {
                hasSeed: false,
                remaining: 0,
            };
        }
        const remaining = hashOnion.count - usedHashOnion.count;
        return {
            hasSeed: true,
            remaining,
        };
    }
    async getHashOnionUsage(ctx) {
        validator_1.validator.validate(schemas_1.addressSchema, ctx.params);
        const address = cryptography.address.getAddressFromKlayr32Address(ctx.params.address);
        const hashOnionStore = this.offchainStores.get(hash_onion_1.HashOnionStore);
        const hashOnion = await hashOnionStore.get(ctx, address);
        const seed = hashOnion.hashes[hashOnion.hashes.length - 1].toString('hex');
        const usedHashOnionStore = this.offchainStores.get(used_hash_onions_1.UsedHashOnionsStore);
        let usedHashOnion;
        try {
            usedHashOnion = await usedHashOnionStore.get(ctx, address);
        }
        catch (error) {
            if (error instanceof lisk_db_1.NotFoundError) {
                return {
                    usedHashOnions: [{ count: 0, height: 0 }],
                    seed,
                };
            }
            throw error;
        }
        return { usedHashOnions: usedHashOnion.usedHashOnions, seed };
    }
    async setHashOnionUsage(ctx) {
        validator_1.validator.validate(schemas_1.setHashOnionUsageRequest, ctx.params);
        const { address, usedHashOnions } = ctx.params;
        const generatorAddress = cryptography.address.getAddressFromKlayr32Address(address);
        const usedHashOnionStore = this.offchainStores.get(used_hash_onions_1.UsedHashOnionsStore);
        await usedHashOnionStore.set(ctx, generatorAddress, { usedHashOnions });
    }
}
exports.RandomEndpoint = RandomEndpoint;
//# sourceMappingURL=endpoint.js.map