/// <reference types="node" />
import { CCMsg, CrossChainUpdateTransactionParams, ChainValidators } from './types';
import { NamedRegistry } from '../named_registry';
import { TerminatedOutboxAccount } from './stores/terminated_outbox';
import { BaseInternalMethod } from '../BaseInternalMethod';
import { MethodContext, ImmutableMethodContext, CommandExecuteContext } from '../../state_machine';
import { TokenMethod } from '../token';
import { BaseCCMethod } from './base_cc_method';
export declare abstract class BaseInteroperabilityInternalMethod extends BaseInternalMethod {
    protected readonly interoperableModuleMethods: Map<string, BaseCCMethod>;
    protected _tokenMethod: TokenMethod;
    constructor(stores: NamedRegistry, events: NamedRegistry, interoperableModuleMethods: Map<string, BaseCCMethod>);
    addDependencies(tokenMethod: TokenMethod): void;
    appendToInboxTree(context: MethodContext, chainID: Buffer, appendData: Buffer): Promise<void>;
    appendToOutboxTree(context: MethodContext, chainID: Buffer, appendData: Buffer): Promise<void>;
    addToOutbox(context: MethodContext, chainID: Buffer, ccm: CCMsg): Promise<void>;
    createTerminatedOutboxAccount(context: MethodContext, chainID: Buffer, outboxRoot: Buffer, outboxSize: number, partnerChainInboxSize: number): Promise<void>;
    setTerminatedOutboxAccount(context: MethodContext, chainID: Buffer, params: Partial<TerminatedOutboxAccount>): Promise<boolean>;
    createTerminatedStateAccount(context: MethodContext, chainID: Buffer, stateRoot?: Buffer): Promise<void>;
    terminateChainInternal(context: MethodContext, chainID: Buffer): Promise<void>;
    updateValidators(context: MethodContext, ccu: CrossChainUpdateTransactionParams): Promise<void>;
    updateCertificate(context: MethodContext, ccu: CrossChainUpdateTransactionParams): Promise<void>;
    updatePartnerChainOutboxRoot(context: MethodContext, ccu: CrossChainUpdateTransactionParams): Promise<void>;
    verifyValidatorsUpdate(context: ImmutableMethodContext, ccu: CrossChainUpdateTransactionParams): Promise<void>;
    verifyCertificate(context: ImmutableMethodContext, params: CrossChainUpdateTransactionParams, blockTimestamp: number): Promise<void>;
    verifyCertificateSignature(context: MethodContext, params: CrossChainUpdateTransactionParams): Promise<void>;
    sendInternal(context: MethodContext, sendingAddress: Buffer, module: string, crossChainCommand: string, receivingChainID: Buffer, fee: bigint, status: number, params: Buffer, timestamp?: number): Promise<void>;
    getChainValidators(context: ImmutableMethodContext, chainID: Buffer): Promise<ChainValidators>;
    verifyOutboxRootWitness(_context: ImmutableMethodContext, params: CrossChainUpdateTransactionParams): void;
    verifyPartnerChainOutboxRoot(context: CommandExecuteContext<CrossChainUpdateTransactionParams>, params: CrossChainUpdateTransactionParams): Promise<void>;
    abstract isLive(context: ImmutableMethodContext, chainID: Buffer, timestamp?: number): Promise<boolean>;
}
