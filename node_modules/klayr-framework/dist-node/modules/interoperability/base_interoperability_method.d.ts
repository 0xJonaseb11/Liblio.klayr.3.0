/// <reference types="node" />
import { BaseMethod } from '../base_method';
import { BaseCCMethod } from './base_cc_method';
import { NamedRegistry } from '../named_registry';
import { ImmutableMethodContext, MethodContext } from '../../state_machine';
import { ChainAccount } from './stores/chain_account';
import { CCMsg } from './types';
import { BaseInteroperabilityInternalMethod } from './base_interoperability_internal_methods';
import { TokenMethod } from '../token';
export declare abstract class BaseInteroperabilityMethod<T extends BaseInteroperabilityInternalMethod> extends BaseMethod {
    protected readonly interoperableCCMethods: Map<string, BaseCCMethod>;
    protected internalMethod: T;
    protected _tokenMethod: TokenMethod;
    constructor(stores: NamedRegistry, events: NamedRegistry, interoperableCCMethods: Map<string, BaseCCMethod>, internalMethod: T);
    addDependencies(tokenMethod: TokenMethod): void;
    getChainAccount(context: ImmutableMethodContext, chainID: Buffer): Promise<ChainAccount>;
    getChannel(context: ImmutableMethodContext, chainID: Buffer): Promise<import("./types").ChannelData>;
    getOwnChainAccount(context: ImmutableMethodContext): Promise<import("./stores/own_chain_account").OwnChainAccount>;
    getTerminatedStateAccount(context: ImmutableMethodContext, chainID: Buffer): Promise<import("./stores/terminated_state").TerminatedStateAccount>;
    getTerminatedOutboxAccount(context: ImmutableMethodContext, chainID: Buffer): Promise<import("./stores/terminated_outbox").TerminatedOutboxAccount>;
    private _getChannelCommon;
    getMessageFeeTokenID(context: ImmutableMethodContext, chainID: Buffer): Promise<Buffer>;
    getMessageFeeTokenIDFromCCM(context: ImmutableMethodContext, ccm: CCMsg): Promise<Buffer>;
    getMinReturnFeePerByte(context: ImmutableMethodContext, chainID: Buffer): Promise<bigint>;
    send(context: MethodContext, sendingAddress: Buffer, module: string, crossChainCommand: string, receivingChainID: Buffer, fee: bigint, params: Buffer, timestamp?: number): Promise<void>;
    error(context: MethodContext, ccm: CCMsg, errorStatus: number): Promise<void>;
    terminateChain(context: MethodContext, chainID: Buffer): Promise<void>;
}
