"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenEndpoint = void 0;
const validator_1 = require("@klayr/validator");
const cryptography = require("@klayr/cryptography");
const state_machine_1 = require("../../state_machine");
const base_endpoint_1 = require("../base_endpoint");
const constants_1 = require("./constants");
const schemas_1 = require("./schemas");
const escrow_1 = require("./stores/escrow");
const supply_1 = require("./stores/supply");
const user_1 = require("./stores/user");
const supported_tokens_1 = require("./stores/supported_tokens");
class TokenEndpoint extends base_endpoint_1.BaseEndpoint {
    init(moduleConfig) {
        this._moduleConfig = moduleConfig;
    }
    async getBalances(context) {
        validator_1.validator.validate(schemas_1.getBalancesRequestSchema, context.params);
        const address = cryptography.address.getAddressFromKlayr32Address(context.params.address);
        const userStore = this.stores.get(user_1.UserStore);
        const userData = await userStore.iterate(context, {
            gte: Buffer.concat([address, Buffer.alloc(constants_1.TOKEN_ID_LENGTH, 0)]),
            lte: Buffer.concat([address, Buffer.alloc(constants_1.TOKEN_ID_LENGTH, 255)]),
        });
        return {
            balances: userData.map(({ key, value: user }) => ({
                tokenID: key.subarray(20).toString('hex'),
                availableBalance: user.availableBalance.toString(),
                lockedBalances: user.lockedBalances.map(b => ({
                    amount: b.amount.toString(),
                    module: b.module,
                })),
            })),
        };
    }
    async getBalance(context) {
        validator_1.validator.validate(schemas_1.getBalanceRequestSchema, context.params);
        const address = cryptography.address.getAddressFromKlayr32Address(context.params.address);
        const tokenID = Buffer.from(context.params.tokenID, 'hex');
        const userStore = this.stores.get(user_1.UserStore);
        try {
            const user = await userStore.get(context, userStore.getKey(address, tokenID));
            return {
                availableBalance: user.availableBalance.toString(),
                lockedBalances: user.lockedBalances.map(b => ({
                    amount: b.amount.toString(),
                    module: b.module,
                })),
            };
        }
        catch (error) {
            if (!(error instanceof state_machine_1.NotFoundError)) {
                throw error;
            }
            return {
                availableBalance: '0',
                lockedBalances: [],
            };
        }
    }
    async getTotalSupply(context) {
        const supplyStore = this.stores.get(supply_1.SupplyStore);
        const supplyData = await supplyStore.getAll(context);
        return {
            totalSupply: supplyData.map(({ key: tokenID, value: supply }) => ({
                tokenID: tokenID.toString('hex'),
                totalSupply: supply.totalSupply.toString(),
            })),
        };
    }
    async getSupportedTokens(context) {
        const supportedTokensStore = this.stores.get(supported_tokens_1.SupportedTokensStore);
        if (await supportedTokensStore.allSupported(context)) {
            return {
                supportedTokens: ['*'],
            };
        }
        const supportedTokens = [];
        const mainchainTokenID = Buffer.concat([
            context.chainID.subarray(0, 1),
            Buffer.alloc(constants_1.TOKEN_ID_LENGTH - 1, 0),
        ]);
        supportedTokens.push(mainchainTokenID.toString('hex'));
        const supplyStore = this.stores.get(supply_1.SupplyStore);
        const supplyData = await supplyStore.getAll(context);
        for (const tokenSupply of supplyData) {
            supportedTokens.push(tokenSupply.key.toString('hex'));
        }
        const supportedTokensData = await supportedTokensStore.getAll(context);
        for (const supportedToken of supportedTokensData) {
            if (!supportedToken.value.supportedTokenIDs.length) {
                supportedTokens.push(`${supportedToken.key.toString('hex')}${'********'}`);
            }
            else {
                for (const token of supportedToken.value.supportedTokenIDs) {
                    supportedTokens.push(token.toString('hex'));
                }
            }
        }
        return { supportedTokens };
    }
    async isSupported(context) {
        validator_1.validator.validate(schemas_1.isSupportedRequestSchema, context.params);
        const tokenID = Buffer.from(context.params.tokenID, 'hex');
        const supportedTokensStore = this.stores.get(supported_tokens_1.SupportedTokensStore);
        return { supported: await supportedTokensStore.isSupported(context, tokenID) };
    }
    async getEscrowedAmounts(context) {
        const escrowStore = this.stores.get(escrow_1.EscrowStore);
        const escrowData = await escrowStore.iterate(context, {
            gte: Buffer.concat([Buffer.alloc(constants_1.TOKEN_ID_LENGTH, 0)]),
            lte: Buffer.concat([Buffer.alloc(constants_1.TOKEN_ID_LENGTH, 255)]),
        });
        return {
            escrowedAmounts: escrowData.map(({ key, value: escrow }) => {
                const escrowChainID = key.subarray(0, constants_1.CHAIN_ID_LENGTH);
                const tokenID = key.subarray(constants_1.CHAIN_ID_LENGTH);
                return {
                    escrowChainID: escrowChainID.toString('hex'),
                    amount: escrow.amount.toString(),
                    tokenID: tokenID.toString('hex'),
                };
            }),
        };
    }
    getInitializationFees() {
        return {
            userAccount: this._moduleConfig.userAccountInitializationFee.toString(),
            escrowAccount: this._moduleConfig.escrowAccountInitializationFee.toString(),
        };
    }
    async hasUserAccount(context) {
        validator_1.validator.validate(schemas_1.hasUserAccountRequestSchema, context.params);
        const address = cryptography.address.getAddressFromKlayr32Address(context.params.address);
        const tokenID = Buffer.from(context.params.tokenID, 'hex');
        const userStore = this.stores.get(user_1.UserStore);
        return { exists: await userStore.has(context, userStore.getKey(address, tokenID)) };
    }
    async hasEscrowAccount(context) {
        validator_1.validator.validate(schemas_1.hasEscrowAccountRequestSchema, context.params);
        const escrowChainID = Buffer.from(context.params.escrowChainID, 'hex');
        const tokenID = Buffer.from(context.params.tokenID, 'hex');
        const escrowStore = this.stores.get(escrow_1.EscrowStore);
        return { exists: await escrowStore.has(context, escrowStore.getKey(escrowChainID, tokenID)) };
    }
}
exports.TokenEndpoint = TokenEndpoint;
//# sourceMappingURL=endpoint.js.map