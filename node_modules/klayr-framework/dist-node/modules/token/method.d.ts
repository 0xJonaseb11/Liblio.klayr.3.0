/// <reference types="node" />
import { ImmutableMethodContext, MethodContext } from '../../state_machine';
import { BaseMethod } from '../base_method';
import { InteroperabilityMethod, ModuleConfig } from './types';
import { SupplyStoreData } from './stores/supply';
import { NamedRegistry } from '../named_registry';
import { InternalMethod } from './internal_method';
interface MethodConfig extends ModuleConfig {
    ownChainID: Buffer;
}
export declare class TokenMethod extends BaseMethod {
    private readonly _moduleName;
    private _config;
    private _interoperabilityMethod;
    private _internalMethod;
    constructor(stores: NamedRegistry, events: NamedRegistry, moduleName: string);
    init(config: MethodConfig): void;
    addDependencies(interoperabilityMethod: InteroperabilityMethod, internalMethod: InternalMethod): void;
    isNativeToken(tokenID: Buffer): boolean;
    getTokenIDKLY(): Buffer;
    userSubstoreExists(methodContext: ImmutableMethodContext, address: Buffer, tokenID: Buffer): Promise<boolean>;
    getAvailableBalance(methodContext: ImmutableMethodContext, address: Buffer, tokenID: Buffer): Promise<bigint>;
    getLockedAmount(methodContext: ImmutableMethodContext, address: Buffer, tokenID: Buffer, module: string): Promise<bigint>;
    getEscrowedAmount(methodContext: ImmutableMethodContext, escrowChainID: Buffer, tokenID: Buffer): Promise<bigint>;
    isTokenIDAvailable(methodContext: ImmutableMethodContext, tokenID: Buffer): Promise<boolean>;
    initializeToken(methodContext: MethodContext, tokenID: Buffer): Promise<void>;
    mint(methodContext: MethodContext, address: Buffer, tokenID: Buffer, amount: bigint): Promise<void>;
    burn(methodContext: MethodContext, address: Buffer, tokenID: Buffer, amount: bigint): Promise<void>;
    initializeUserAccount(methodContext: MethodContext, address: Buffer, tokenID: Buffer): Promise<void>;
    initializeEscrowAccount(methodContext: MethodContext, chainID: Buffer, tokenID: Buffer): Promise<void>;
    transfer(methodContext: MethodContext, senderAddress: Buffer, recipientAddress: Buffer, tokenID: Buffer, amount: bigint): Promise<void>;
    transferCrossChain(methodContext: MethodContext, senderAddress: Buffer, receivingChainID: Buffer, recipientAddress: Buffer, tokenID: Buffer, amount: bigint, messageFee: bigint, data: string): Promise<void>;
    lock(methodContext: MethodContext, address: Buffer, module: string, tokenID: Buffer, amount: bigint): Promise<void>;
    unlock(methodContext: MethodContext, address: Buffer, module: string, tokenID: Buffer, amount: bigint): Promise<void>;
    payMessageFee(methodContext: MethodContext, payFromAddress: Buffer, receivingChainID: Buffer, fee: bigint): Promise<void>;
    isTokenSupported(methodContext: ImmutableMethodContext, tokenID: Buffer): Promise<boolean>;
    supportAllTokens(methodContext: MethodContext): Promise<void>;
    removeAllTokensSupport(methodContext: MethodContext): Promise<void>;
    supportAllTokensFromChainID(methodContext: MethodContext, chainID: Buffer): Promise<void>;
    removeAllTokensSupportFromChainID(methodContext: MethodContext, chainID: Buffer): Promise<void>;
    supportTokenID(methodContext: MethodContext, tokenID: Buffer): Promise<void>;
    removeSupport(methodContext: MethodContext, tokenID: Buffer): Promise<void>;
    getTotalSupply(context: MethodContext): Promise<{
        totalSupply: (SupplyStoreData & {
            tokenID: Buffer;
        })[];
    }>;
    escrowSubstoreExists(methodContext: MethodContext, chainID: Buffer, tokenID: Buffer): Promise<boolean>;
}
export {};
