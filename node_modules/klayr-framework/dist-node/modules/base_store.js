"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseStore = exports.computeSubstorePrefix = exports.computeStorePrefix = void 0;
const codec_1 = require("@klayr/codec");
const cryptography_1 = require("@klayr/cryptography");
const computeStorePrefix = (name) => {
    const prefix = cryptography_1.utils.hash(Buffer.from(name, 'utf-8')).subarray(0, 4);
    prefix[0] &= 0x7f;
    return prefix;
};
exports.computeStorePrefix = computeStorePrefix;
const computeSubstorePrefix = (index) => {
    const binaryIndex = `${'0'.repeat(16)}${index.toString(2)}`;
    const val = parseInt(binaryIndex
        .substring(binaryIndex.length - 16)
        .split('')
        .reverse()
        .join(''), 2);
    const result = Buffer.alloc(2);
    result.writeUint16BE(val);
    return result;
};
exports.computeSubstorePrefix = computeSubstorePrefix;
class BaseStore {
    get storePrefix() {
        return this._storePrefix;
    }
    get subStorePrefix() {
        return this._subStorePrefix;
    }
    get key() {
        return Buffer.concat([this.storePrefix, this.subStorePrefix]);
    }
    get name() {
        const name = this.constructor.name.replace('Store', '');
        return name.charAt(0).toLowerCase() + name.substr(1);
    }
    constructor(moduleName, index) {
        this.schema = codec_1.emptySchema;
        this._storePrefix = (0, exports.computeStorePrefix)(moduleName);
        this._subStorePrefix = (0, exports.computeSubstorePrefix)(index);
    }
    async get(ctx, key) {
        if (!this.schema) {
            throw new Error('Schema is not set');
        }
        const subStore = ctx.getStore(this.storePrefix, this.subStorePrefix);
        return subStore.getWithSchema(key, this.schema);
    }
    async has(ctx, key) {
        if (!this.schema) {
            throw new Error('Schema is not set');
        }
        const subStore = ctx.getStore(this.storePrefix, this.subStorePrefix);
        return subStore.has(key);
    }
    async iterate(ctx, options) {
        if (!this.schema) {
            throw new Error('Schema is not set');
        }
        const subStore = ctx.getStore(this.storePrefix, this.subStorePrefix);
        return subStore.iterateWithSchema(options, this.schema);
    }
    async set(ctx, key, value) {
        if (!this.schema) {
            throw new Error('Schema is not set');
        }
        const subStore = ctx.getStore(this.storePrefix, this.subStorePrefix);
        return subStore.setWithSchema(key, value, this.schema);
    }
    async del(ctx, key) {
        if (!this.schema) {
            throw new Error('Schema is not set');
        }
        const subStore = ctx.getStore(this.storePrefix, this.subStorePrefix);
        return subStore.del(key);
    }
}
exports.BaseStore = BaseStore;
//# sourceMappingURL=base_store.js.map