"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateAuthorityCommand = void 0;
const validator_1 = require("@klayr/validator");
const cryptography_1 = require("@klayr/cryptography");
const codec_1 = require("@klayr/codec");
const utils_1 = require("@klayr/utils");
const base_command_1 = require("../../base_command");
const schemas_1 = require("../schemas");
const constants_1 = require("../constants");
const state_machine_1 = require("../../../state_machine");
const stores_1 = require("../stores");
const authority_update_1 = require("../events/authority_update");
class UpdateAuthorityCommand extends base_command_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.schema = schemas_1.updateAuthoritySchema;
    }
    get name() {
        return constants_1.COMMAND_UPDATE_AUTHORITY;
    }
    addDependencies(validatorsMethod) {
        this._validatorsMethod = validatorsMethod;
    }
    async verify(context) {
        const { newValidators, threshold, validatorsUpdateNonce } = context.params;
        const newValidatorsAddresses = newValidators.map(newValidator => newValidator.address);
        if (!utils_1.objects.isBufferArrayOrdered(newValidatorsAddresses)) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error('Addresses in newValidators are not lexicographically ordered.'),
            };
        }
        if (!utils_1.objects.bufferArrayUniqueItems(newValidatorsAddresses)) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error('Addresses in newValidators are not unique.'),
            };
        }
        const validatorStore = this.stores.get(stores_1.ValidatorStore);
        let totalWeight = BigInt(0);
        for (const newValidator of newValidators) {
            const validatorExists = await validatorStore.has(context, newValidator.address);
            if (!validatorExists) {
                return {
                    status: state_machine_1.VerifyStatus.FAIL,
                    error: new Error(`No validator found for given address ${newValidator.address.toString('hex')}.`),
                };
            }
            if (newValidator.weight === BigInt(0)) {
                return {
                    status: state_machine_1.VerifyStatus.FAIL,
                    error: new Error(`Validator weight cannot be zero.`),
                };
            }
            totalWeight += newValidator.weight;
        }
        if (totalWeight === BigInt(0)) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error(`Validators total weight cannot be zero.`),
            };
        }
        if (totalWeight > validator_1.MAX_UINT64) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error(`Validators total weight exceeds ${validator_1.MAX_UINT64}.`),
            };
        }
        const minThreshold = totalWeight / BigInt(3) + BigInt(1);
        if (threshold < minThreshold || threshold > totalWeight) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error(`Threshold must be between ${minThreshold} and ${totalWeight} (inclusive).`),
            };
        }
        const chainPropertiesStore = await this.stores
            .get(stores_1.ChainPropertiesStore)
            .get(context, constants_1.EMPTY_BYTES);
        if (validatorsUpdateNonce !== chainPropertiesStore.validatorsUpdateNonce) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error(`validatorsUpdateNonce must be equal to ${chainPropertiesStore.validatorsUpdateNonce}.`),
            };
        }
        return {
            status: state_machine_1.VerifyStatus.OK,
        };
    }
    async execute(context) {
        const { newValidators, threshold, validatorsUpdateNonce, aggregationBits, signature } = context.params;
        const message = codec_1.codec.encode(schemas_1.validatorSignatureMessageSchema, {
            newValidators,
            threshold,
            validatorsUpdateNonce,
        });
        const validatorsInfos = [];
        const snapshotStore = this.stores.get(stores_1.SnapshotStore);
        const snapshot0 = await snapshotStore.get(context, constants_1.KEY_SNAPSHOT_0);
        for (const snapshotValidator of snapshot0.validators) {
            const keys = await this._validatorsMethod.getValidatorKeys(context, snapshotValidator.address);
            validatorsInfos.push({
                key: keys.blsKey,
                weight: snapshotValidator.weight,
            });
        }
        validatorsInfos.sort((a, b) => a.key.compare(b.key));
        const verified = cryptography_1.bls.verifyWeightedAggSig(validatorsInfos.map(validatorInfo => validatorInfo.key), aggregationBits, signature, constants_1.MESSAGE_TAG_POA, context.chainID, message, validatorsInfos.map(validatorInfo => validatorInfo.weight), snapshot0.threshold);
        const authorityUpdateEvent = this.events.get(authority_update_1.AuthorityUpdateEvent);
        if (!verified) {
            authorityUpdateEvent.log(context, {
                result: constants_1.UpdateAuthorityResult.FAIL_INVALID_SIGNATURE,
            }, true);
            throw new Error('Invalid weighted aggregated signature.');
        }
        await snapshotStore.set(context, constants_1.KEY_SNAPSHOT_2, {
            validators: newValidators,
            threshold,
        });
        const chainPropertiesStore = this.stores.get(stores_1.ChainPropertiesStore);
        const chainProperties = await chainPropertiesStore.get(context, constants_1.EMPTY_BYTES);
        await chainPropertiesStore.set(context, constants_1.EMPTY_BYTES, {
            ...chainProperties,
            validatorsUpdateNonce: chainProperties.validatorsUpdateNonce + 1,
        });
        authorityUpdateEvent.log(context, {
            result: constants_1.UpdateAuthorityResult.SUCCESS,
        }, false);
    }
}
exports.UpdateAuthorityCommand = UpdateAuthorityCommand;
//# sourceMappingURL=update_authority.js.map