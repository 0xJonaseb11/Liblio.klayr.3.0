"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegisterAuthorityCommand = void 0;
const base_command_1 = require("../../base_command");
const schemas_1 = require("../schemas");
const state_machine_1 = require("../../../state_machine");
const constants_1 = require("../constants");
const stores_1 = require("../stores");
class RegisterAuthorityCommand extends base_command_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.schema = schemas_1.registerAuthoritySchema;
    }
    get name() {
        return constants_1.COMMAND_REGISTER_AUTHORITY;
    }
    init(args) {
        this._authorityRegistrationFee = args.authorityRegistrationFee;
    }
    addDependencies(validatorsMethod, feeMethod) {
        this._validatorsMethod = validatorsMethod;
        this._feeMethod = feeMethod;
    }
    async verify(context) {
        const { name } = context.params;
        if (!constants_1.POA_VALIDATOR_NAME_REGEX.test(name)) {
            throw new Error(`Name does not comply with format ${constants_1.POA_VALIDATOR_NAME_REGEX.toString()}.`);
        }
        const nameExists = await this.stores.get(stores_1.NameStore).has(context, Buffer.from(name, 'utf-8'));
        if (nameExists) {
            throw new Error('Name already exists.');
        }
        const validatorExists = await this.stores
            .get(stores_1.ValidatorStore)
            .has(context, context.transaction.senderAddress);
        if (validatorExists) {
            throw new Error('Validator already exists.');
        }
        return {
            status: state_machine_1.VerifyStatus.OK,
        };
    }
    async execute(context) {
        const { params } = context;
        this._feeMethod.payFee(context, this._authorityRegistrationFee);
        await this.stores.get(stores_1.ValidatorStore).set(context, context.transaction.senderAddress, {
            name: params.name,
        });
        await this.stores.get(stores_1.NameStore).set(context, Buffer.from(params.name, 'utf-8'), {
            address: context.transaction.senderAddress,
        });
        await this._validatorsMethod.registerValidatorKeys(context, context.transaction.senderAddress, params.blsKey, params.generatorKey, params.proofOfPossession);
    }
}
exports.RegisterAuthorityCommand = RegisterAuthorityCommand;
//# sourceMappingURL=register_authority.js.map