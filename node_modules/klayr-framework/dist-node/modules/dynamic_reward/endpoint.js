"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DynamicRewardEndpoint = void 0;
const cryptography_1 = require("@klayr/cryptography");
const endpoint_1 = require("../reward/endpoint");
const calculate_reward_1 = require("../reward/calculate_reward");
const utils_1 = require("./utils");
class DynamicRewardEndpoint extends endpoint_1.RewardEndpoint {
    init(config, blockTime) {
        super.init(config, blockTime);
        this._config = config;
    }
    addDependencies(validatorMethod, posMethod) {
        this._validatorMethod = validatorMethod;
        this._posMethod = posMethod;
    }
    async getExpectedValidatorRewards(context) {
        const { validatorAddress } = context.params;
        if (typeof validatorAddress !== 'string') {
            throw new Error('Parameter validatorAddress must be a string.');
        }
        cryptography_1.address.validateKlayr32Address(validatorAddress);
        const address = cryptography_1.address.getAddressFromKlayr32Address(validatorAddress);
        const validatorParams = await this._validatorMethod.getValidatorsParams(context);
        const totalBFTWeight = validatorParams.validators.reduce((prev, curr) => prev + curr.bftWeight, BigInt(0));
        const validator = validatorParams.validators.find(v => v.address.equals(address));
        if (!validator) {
            return {
                blockReward: '0',
                dailyReward: '0',
                monthlyReward: '0',
                yearlyReward: '0',
            };
        }
        const defaultReward = (0, calculate_reward_1.calculateDefaultReward)(this._config, context.header.height);
        const minimalRewardActiveValidators = (0, utils_1.getMinimalRewardActiveValidators)(this._config, defaultReward);
        const stakeRewardActiveValidators = await (0, utils_1.getStakeRewardActiveValidators)(context, this._validatorMethod, defaultReward, minimalRewardActiveValidators);
        const additionalReward = (validator.bftWeight * stakeRewardActiveValidators) / totalBFTWeight;
        const blockReward = validator.bftWeight > BigInt(0)
            ? minimalRewardActiveValidators + additionalReward
            : defaultReward;
        const roundLength = this._posMethod.getRoundLength(context);
        const rewardPerSec = blockReward / BigInt(roundLength * this._blockTime);
        return {
            blockReward: blockReward.toString(),
            dailyReward: (BigInt(86400) * rewardPerSec).toString(),
            monthlyReward: (BigInt(2592000) * rewardPerSec).toString(),
            yearlyReward: (BigInt(31536000) * rewardPerSec).toString(),
        };
    }
}
exports.DynamicRewardEndpoint = DynamicRewardEndpoint;
//# sourceMappingURL=endpoint.js.map