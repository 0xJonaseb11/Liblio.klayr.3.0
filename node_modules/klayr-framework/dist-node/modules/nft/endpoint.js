"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NFTEndpoint = void 0;
const cryptography = require("@klayr/cryptography");
const validator_1 = require("@klayr/validator");
const base_endpoint_1 = require("../base_endpoint");
const schemas_1 = require("./schemas");
const nft_1 = require("./stores/nft");
const constants_1 = require("./constants");
const user_1 = require("./stores/user");
const supported_nfts_1 = require("./stores/supported_nfts");
class NFTEndpoint extends base_endpoint_1.BaseEndpoint {
    addDependencies(nftMethod) {
        this._nftMethod = nftMethod;
    }
    async getNFTs(context) {
        validator_1.validator.validate(schemas_1.getNFTsRequestSchema, context.params);
        const nftStore = this.stores.get(nft_1.NFTStore);
        const owner = cryptography.address.getAddressFromKlayr32Address(context.params.address);
        const allNFTs = await nftStore.iterate(context.getImmutableMethodContext(), {
            gte: Buffer.alloc(constants_1.LENGTH_NFT_ID, 0),
            lte: Buffer.alloc(constants_1.LENGTH_NFT_ID, 255),
        });
        const ownedNFTs = allNFTs.filter(nft => nft.value.owner.equals(owner));
        const userStore = this.stores.get(user_1.UserStore);
        const nfts = [];
        for (const ownedNFT of ownedNFTs) {
            const ownedNFTUserData = await userStore.get(context.getImmutableMethodContext(), userStore.getKey(owner, ownedNFT.key));
            nfts.push({
                id: ownedNFT.key.toString('hex'),
                attributesArray: ownedNFT.value.attributesArray.map(attribute => ({
                    module: attribute.module,
                    attributes: attribute.attributes.toString('hex'),
                })),
                lockingModule: ownedNFTUserData.lockingModule,
            });
        }
        return { nfts };
    }
    async hasNFT(context) {
        const { params } = context;
        validator_1.validator.validate(schemas_1.hasNFTRequestSchema, params);
        const nftID = Buffer.from(params.id, 'hex');
        const owner = cryptography.address.getAddressFromKlayr32Address(params.address);
        const nftStore = this.stores.get(nft_1.NFTStore);
        const nftExists = await nftStore.has(context.getImmutableMethodContext(), nftID);
        if (!nftExists) {
            return { hasNFT: nftExists };
        }
        const nftData = await nftStore.get(context.getImmutableMethodContext(), nftID);
        return { hasNFT: nftData.owner.equals(owner) };
    }
    async getNFT(context) {
        const { params } = context;
        validator_1.validator.validate(schemas_1.getNFTRequestSchema, params);
        const nftID = Buffer.from(params.id, 'hex');
        const nftStore = this.stores.get(nft_1.NFTStore);
        const nftExists = await nftStore.has(context.getImmutableMethodContext(), nftID);
        if (!nftExists) {
            throw new Error('NFT substore entry does not exist');
        }
        const userStore = this.stores.get(user_1.UserStore);
        const nftData = await nftStore.get(context.getImmutableMethodContext(), nftID);
        const owner = nftData.owner.toString('hex');
        const attributesArray = nftData.attributesArray.map(attribute => ({
            module: attribute.module,
            attributes: attribute.attributes.toString('hex'),
        }));
        if (nftData.owner.length === constants_1.LENGTH_ADDRESS) {
            const userExists = await userStore.has(context.getImmutableMethodContext(), userStore.getKey(nftData.owner, nftID));
            if (!userExists) {
                throw new Error('User substore entry does not exist');
            }
            const userData = await userStore.get(context.getImmutableMethodContext(), userStore.getKey(nftData.owner, nftID));
            return {
                owner,
                attributesArray,
                lockingModule: userData.lockingModule,
            };
        }
        return {
            owner,
            attributesArray,
        };
    }
    async getSupportedCollectionIDs(context) {
        const supportedNFTsStore = this.stores.get(supported_nfts_1.SupportedNFTsStore);
        if (await supportedNFTsStore.has(context, constants_1.ALL_SUPPORTED_NFTS_KEY)) {
            return { supportedCollectionIDs: ['*'] };
        }
        const supportedCollectionIDs = [];
        supportedCollectionIDs.push(`${context.chainID.toString('hex')}********`);
        const supportedNFTsStoreData = await supportedNFTsStore.getAll(context);
        for (const { key, value } of supportedNFTsStoreData) {
            if (!value.supportedCollectionIDArray.length) {
                supportedCollectionIDs.push(`${key.toString('hex')}********`);
            }
            else {
                const collectionIDs = value.supportedCollectionIDArray.map(supportedCollectionID => key.toString('hex') + supportedCollectionID.collectionID.toString('hex'));
                supportedCollectionIDs.push(...collectionIDs);
            }
        }
        return { supportedCollectionIDs };
    }
    async isCollectionIDSupported(context) {
        const { params } = context;
        validator_1.validator.validate(schemas_1.isCollectionIDSupportedRequestSchema, params);
        const chainID = Buffer.from(params.chainID, 'hex');
        const collectionID = Buffer.from(params.collectionID, 'hex');
        const nftID = Buffer.concat([chainID, collectionID, Buffer.alloc(8)]);
        const isNFTSupported = await this._nftMethod.isNFTSupported(context.getImmutableMethodContext(), nftID);
        if (!isNFTSupported) {
            return { isCollectionIDSupported: false };
        }
        const supportedNFTsStore = this.stores.get(supported_nfts_1.SupportedNFTsStore);
        const supportedNFTsData = await supportedNFTsStore.get(context.getImmutableMethodContext(), chainID);
        return {
            isCollectionIDSupported: supportedNFTsData.supportedCollectionIDArray.some(supportedCollection => supportedCollection.collectionID.equals(collectionID)),
        };
    }
    async getEscrowedNFTIDs(context) {
        const { params } = context;
        validator_1.validator.validate(schemas_1.getEscrowedNFTIDsRequestSchema, params);
        const chainD = Buffer.from(params.chainID, 'hex');
        const nftStore = this.stores.get(nft_1.NFTStore);
        const allNFTs = await nftStore.iterate(context.getImmutableMethodContext(), {
            gte: Buffer.alloc(constants_1.LENGTH_NFT_ID, 0),
            lte: Buffer.alloc(constants_1.LENGTH_NFT_ID, 255),
        });
        return {
            escrowedNFTIDs: allNFTs
                .filter(nft => nft.value.owner.equals(chainD))
                .map(nft => nft.key.toString('hex')),
        };
    }
    async isNFTSupported(context) {
        const { params } = context;
        validator_1.validator.validate(schemas_1.isNFTSupportedRequestSchema, params);
        const nftID = Buffer.from(params.nftID, 'hex');
        let isNFTSupported = false;
        try {
            isNFTSupported = await this._nftMethod.isNFTSupported(context.getImmutableMethodContext(), nftID);
        }
        catch (err) {
            return { isNFTSupported };
        }
        return { isNFTSupported };
    }
    async getSupportedNFTs(context) {
        const supportedNFTsStore = this.stores.get(supported_nfts_1.SupportedNFTsStore);
        const areAllNFTsSupported = await supportedNFTsStore.has(context, constants_1.ALL_SUPPORTED_NFTS_KEY);
        if (areAllNFTsSupported) {
            return {
                supportedNFTs: ['*'],
            };
        }
        const supportedNFTs = [];
        const storeData = await supportedNFTsStore.getAll(context);
        for (const { key, value } of storeData) {
            if (!value.supportedCollectionIDArray.length) {
                supportedNFTs.push(`${key.toString('hex')}********`);
            }
            else {
                for (const supportedCollectionID of value.supportedCollectionIDArray) {
                    supportedNFTs.push(key.toString('hex') + supportedCollectionID.collectionID.toString('hex'));
                }
            }
        }
        return { supportedNFTs };
    }
}
exports.NFTEndpoint = NFTEndpoint;
//# sourceMappingURL=endpoint.js.map