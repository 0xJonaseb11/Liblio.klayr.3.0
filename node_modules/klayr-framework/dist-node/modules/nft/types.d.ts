/// <reference types="node" />
import { ImmutableMethodContext, MethodContext } from '../../state_machine';
import { JSONObject } from '../../types';
import { CCMsg } from '../interoperability';
export interface ModuleConfig {
    ownChainID: Buffer;
}
export interface InteroperabilityMethod {
    send(methodContext: MethodContext, feeAddress: Buffer, module: string, crossChainCommand: string, receivingChainID: Buffer, fee: bigint, parameters: Buffer, timestamp?: number): Promise<void>;
    error(methodContext: MethodContext, ccm: CCMsg, code: number): Promise<void>;
    terminateChain(methodContext: MethodContext, chainID: Buffer): Promise<void>;
    getMessageFeeTokenID(methodContext: ImmutableMethodContext, chainID: Buffer): Promise<Buffer>;
}
export interface FeeMethod {
    payFee(methodContext: MethodContext, amount: bigint): void;
}
export interface TokenMethod {
    getAvailableBalance(methodContext: ImmutableMethodContext, address: Buffer, tokenID: Buffer): Promise<bigint>;
}
export interface NFTMethod {
    getChainID(nftID: Buffer): Buffer;
    destroy(methodContext: MethodContext, address: Buffer, nftID: Buffer): Promise<void>;
    getNFT(methodContext: ImmutableMethodContext, nftID: Buffer): Promise<NFT>;
    isNFTEscrowed(nft: NFT): boolean;
    isNFTLocked(nft: NFT): boolean;
}
export interface NFTAttributes {
    module: string;
    attributes: Buffer;
}
export interface NFT {
    owner: Buffer;
    attributesArray: NFTAttributes[];
    lockingModule?: string;
}
export type NFTJSON = JSONObject<NFT>;
export interface NFTOutputEndpoint {
    owner: string;
    attributesArray: NFTAttributes[];
    lockingModule?: string;
}
export interface GenesisNFTStore {
    nftSubstore: {
        nftID: Buffer;
        owner: Buffer;
        attributesArray: {
            module: string;
            attributes: Buffer;
        }[];
    }[];
    supportedNFTsSubstore: {
        chainID: Buffer;
        supportedCollectionIDArray: {
            collectionID: Buffer;
        }[];
    }[];
}
