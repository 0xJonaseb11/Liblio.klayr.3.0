"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RewardModule = void 0;
const utils_1 = require("@klayr/utils");
const validator_1 = require("@klayr/validator");
const base_module_1 = require("../base_module");
const constants_1 = require("./constants");
const state_machine_1 = require("../../state_machine");
const method_1 = require("./method");
const endpoint_1 = require("./endpoint");
const schemas_1 = require("./schemas");
const reward_minted_1 = require("./events/reward_minted");
class RewardModule extends base_module_1.BaseModule {
    constructor() {
        super();
        this.method = new method_1.RewardMethod(this.stores, this.events);
        this.configSchema = schemas_1.configSchema;
        this.endpoint = new endpoint_1.RewardEndpoint(this.stores, this.offchainStores);
        this.events.register(reward_minted_1.RewardMintedEvent, new reward_minted_1.RewardMintedEvent(this.name));
    }
    addDependencies(tokenMethod, randomMethod) {
        this._tokenMethod = tokenMethod;
        this._randomMethod = randomMethod;
        this.method.addDependencies(this._randomMethod);
    }
    metadata() {
        return {
            ...this.baseMetadata(),
            endpoints: [
                {
                    name: this.endpoint.getDefaultRewardAtHeight.name,
                    request: schemas_1.getDefaultRewardAtHeightRequestSchema,
                    response: schemas_1.getDefaultRewardAtHeightResponseSchema,
                },
                {
                    name: this.endpoint.getAnnualInflation.name,
                    request: schemas_1.getAnnualInflationRequestSchema,
                    response: schemas_1.getAnnualInflationResponseSchema,
                },
                {
                    name: this.endpoint.getRewardTokenID.name,
                    response: schemas_1.getRewardTokenIDResponseSchema,
                },
            ],
        };
    }
    async init(args) {
        const { moduleConfig } = args;
        const tokenID = `${args.genesisConfig.chainID}${Buffer.alloc(4).toString('hex')}`;
        const config = utils_1.objects.mergeDeep({}, { ...constants_1.defaultConfig, tokenID }, moduleConfig);
        validator_1.validator.validate(schemas_1.configSchema, config);
        this._moduleConfig = {
            ...config,
            tokenID: Buffer.from(config.tokenID, 'hex'),
            brackets: config.brackets.map(bracket => BigInt(bracket)),
            rewardReductionFactorBFT: BigInt(config.rewardReductionFactorBFT),
        };
        this.method.init({
            config: this._moduleConfig,
        });
        this.endpoint.init(this._moduleConfig, args.genesisConfig.blockTime);
    }
    async beforeTransactionsExecute(context) {
        const [blockReward, reduction] = await this.method.getBlockReward(context.getMethodContext(), context.header, context.assets);
        context.contextStore.set(constants_1.CONTEXT_STORE_KEY_BLOCK_REWARD, blockReward);
        context.contextStore.set(constants_1.CONTEXT_STORE_KEY_BLOCK_REDUCTION, reduction);
    }
    async afterTransactionsExecute(context) {
        let blockReward = (0, state_machine_1.getContextStoreBigInt)(context.contextStore, constants_1.CONTEXT_STORE_KEY_BLOCK_REWARD);
        let reduction = (0, state_machine_1.getContextStoreNumber)(context.contextStore, constants_1.CONTEXT_STORE_KEY_BLOCK_REDUCTION);
        if (blockReward < BigInt(0)) {
            throw new Error("Block reward can't be negative.");
        }
        const userSubstoreExists = await this._tokenMethod.userSubstoreExists(context, context.header.generatorAddress, this._moduleConfig.tokenID);
        if (blockReward !== BigInt(0)) {
            if (userSubstoreExists) {
                await this._tokenMethod.mint(context.getMethodContext(), context.header.generatorAddress, this._moduleConfig.tokenID, blockReward);
            }
            else {
                blockReward = BigInt(0);
                reduction = constants_1.REWARD_REDUCTION_NO_ACCOUNT;
            }
        }
        this.events.get(reward_minted_1.RewardMintedEvent).log(context, context.header.generatorAddress, {
            amount: blockReward,
            reduction,
        });
    }
}
exports.RewardModule = RewardModule;
//# sourceMappingURL=module.js.map