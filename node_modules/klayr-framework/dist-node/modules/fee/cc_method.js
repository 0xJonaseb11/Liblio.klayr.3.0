"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeeInteroperableMethod = void 0;
const base_cc_method_1 = require("../interoperability/base_cc_method");
const constants_1 = require("./constants");
const state_machine_1 = require("../../state_machine");
const relayer_fee_processed_1 = require("./events/relayer_fee_processed");
const utils_1 = require("../interoperability/utils");
class FeeInteroperableMethod extends base_cc_method_1.BaseCCMethod {
    constructor(stores, events, moduleName) {
        super(stores, events);
        this._moduleName = moduleName;
    }
    init(config) {
        this._feePoolAddress = config.feePoolAddress;
    }
    addDependencies(interoperabilityMethod, tokenMethod) {
        this._interopMethod = interoperabilityMethod;
        this._tokenMethod = tokenMethod;
    }
    async beforeCrossChainCommandExecute(ctx) {
        const messageTokenID = await this._interopMethod.getMessageFeeTokenIDFromCCM(ctx, ctx.ccm);
        await this._tokenMethod.lock(ctx.getMethodContext(), ctx.transaction.senderAddress, this._moduleName, messageTokenID, ctx.ccm.fee);
        ctx.contextStore.set(constants_1.CONTEXT_STORE_KEY_AVAILABLE_CCM_FEE, ctx.ccm.fee);
    }
    async afterCrossChainCommandExecute(ctx) {
        const messageTokenID = await this._interopMethod.getMessageFeeTokenIDFromCCM(ctx, ctx.ccm);
        await this._tokenMethod.unlock(ctx.getMethodContext(), ctx.transaction.senderAddress, this._moduleName, messageTokenID, ctx.ccm.fee);
        const availableFee = (0, state_machine_1.getContextStoreBigInt)(ctx.contextStore, constants_1.CONTEXT_STORE_KEY_AVAILABLE_CCM_FEE);
        const burntAmount = ctx.ccm.fee - availableFee;
        if (this._feePoolAddress &&
            (await this._tokenMethod.userSubstoreExists(ctx, this._feePoolAddress, messageTokenID))) {
            await this._tokenMethod.transfer(ctx.getMethodContext(), ctx.transaction.senderAddress, this._feePoolAddress, messageTokenID, burntAmount);
        }
        else {
            await this._tokenMethod.burn(ctx.getMethodContext(), ctx.transaction.senderAddress, messageTokenID, burntAmount);
        }
        const { ccmID } = (0, utils_1.getEncodedCCMAndID)(ctx.ccm);
        this.events.get(relayer_fee_processed_1.RelayerFeeProcessedEvent).log(ctx, {
            burntAmount,
            relayerAddress: ctx.transaction.senderAddress,
            relayerAmount: availableFee,
            ccmID,
        });
        ctx.contextStore.delete(constants_1.CONTEXT_STORE_KEY_AVAILABLE_CCM_FEE);
    }
}
exports.FeeInteroperableMethod = FeeInteroperableMethod;
//# sourceMappingURL=cc_method.js.map