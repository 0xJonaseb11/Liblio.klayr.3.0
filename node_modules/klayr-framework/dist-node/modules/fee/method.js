"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeeMethod = void 0;
const state_machine_1 = require("../../state_machine");
const base_method_1 = require("../base_method");
const constants_1 = require("../interoperability/constants");
const constants_2 = require("./constants");
const insufficient_fee_1 = require("./events/insufficient_fee");
class FeeMethod extends base_method_1.BaseMethod {
    init(config) {
        this._config = config;
    }
    getFeeTokenID() {
        return this._config.feeTokenID;
    }
    payFee(methodContext, amount) {
        const isCCMProcessing = (0, state_machine_1.getContextStoreBool)(methodContext.contextStore, constants_1.CONTEXT_STORE_KEY_CCM_PROCESSING);
        if (isCCMProcessing) {
            this._deductFeeFromKey(methodContext, constants_2.CONTEXT_STORE_KEY_AVAILABLE_CCM_FEE, amount, 'Cross-chain message ran out of fee.');
            return;
        }
        this._deductFeeFromKey(methodContext, constants_2.CONTEXT_STORE_KEY_AVAILABLE_FEE, amount, 'Transaction ran out of fee.');
    }
    _deductFeeFromKey(methodContext, key, amount, outOfFeeMsg) {
        const availableFee = (0, state_machine_1.getContextStoreBigInt)(methodContext.contextStore, key);
        if (availableFee < amount) {
            this.events.get(insufficient_fee_1.InsufficientFeeEvent).error(methodContext);
            methodContext.contextStore.delete(key);
            throw new Error(outOfFeeMsg);
        }
        methodContext.contextStore.set(key, availableFee - amount);
    }
}
exports.FeeMethod = FeeMethod;
//# sourceMappingURL=method.js.map