"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryChannel = void 0;
const lisk_db_1 = require("@liskhq/lisk-db");
const chain_1 = require("@klayr/chain");
const event_1 = require("../event");
const request_1 = require("../request");
const base_channel_1 = require("./base_channel");
const types_1 = require("../../types");
const state_machine_1 = require("../../state_machine");
const prefixed_state_read_writer_1 = require("../../state_machine/prefixed_state_read_writer");
class InMemoryChannel extends base_channel_1.BaseChannel {
    constructor(logger, db, moduleDB, namespace, events, endpoints, chainID) {
        super(logger, namespace, events, endpoints);
        this._db = db;
        this._moduleDB = moduleDB;
        this._chainID = chainID;
    }
    async registerToBus(bus) {
        this.bus = bus;
        const endpointInfo = [...this.endpointHandlers.keys()].reduce((prev, methodName) => ({
            ...prev,
            [methodName]: {
                namespace: this.namespace,
                methodName,
            },
        }), {});
        await this.bus.registerChannel(this.namespace, this.eventsList, endpointInfo, {
            type: types_1.ChannelType.InMemory,
            channel: this,
        });
    }
    subscribe(eventName, cb) {
        this.bus.subscribe(eventName, (notificationObject) => setImmediate(cb, event_1.Event.fromJSONRPCNotification(notificationObject).data));
    }
    unsubscribe(eventName, cb) {
        this.bus.unsubscribe(eventName, cb);
    }
    once(eventName, cb) {
        this.bus.once(eventName, (notificationObject) => setImmediate(cb, event_1.Event.fromJSONRPCNotification(notificationObject).data));
    }
    publish(eventName, data) {
        const event = new event_1.Event(eventName, data);
        if (event.module !== this.namespace) {
            throw new Error(`Event "${eventName}" not registered in "${this.namespace}" module.`);
        }
        this.bus.publish(event.toJSONRPCNotification());
    }
    async invoke(req) {
        var _a;
        const request = new request_1.Request(this._getNextRequestId(), req.methodName, req.params);
        if (request.namespace === this.namespace) {
            const handler = this.endpointHandlers.get(request.name);
            if (!handler) {
                throw new Error(`The action '${request.name}' on module '${this.namespace}' does not exist.`);
            }
            const offchainStore = new chain_1.StateStore(this._moduleDB);
            const stateStore = new prefixed_state_read_writer_1.PrefixedStateReadWriter(this._db.newReadWriter());
            try {
                const result = (await handler({
                    logger: this._logger,
                    params: (_a = request.params) !== null && _a !== void 0 ? _a : {},
                    getStore: (moduleID, storePrefix) => stateStore.getStore(moduleID, storePrefix),
                    header: req.context.header,
                    getOffchainStore: (moduleID, storePrefix) => offchainStore.getStore(moduleID, storePrefix),
                    getImmutableMethodContext: () => (0, state_machine_1.createImmutableMethodContext)(stateStore),
                    chainID: this._chainID,
                }));
                const batch = new lisk_db_1.Batch();
                offchainStore.finalize(batch);
                await this._moduleDB.write(batch);
                return result;
            }
            finally {
                stateStore.inner.close();
            }
        }
        const resp = await this.bus.invoke(request.toJSONRPCRequest(), req.context);
        return resp.result;
    }
}
exports.InMemoryChannel = InMemoryChannel;
//# sourceMappingURL=in_memory_channel.js.map