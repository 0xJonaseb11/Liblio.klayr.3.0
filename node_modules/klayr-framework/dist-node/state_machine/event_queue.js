"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventQueue = void 0;
const chain_1 = require("@klayr/chain");
class EventQueue {
    constructor(height, events, defaultTopics) {
        this._height = height;
        this._events = events !== null && events !== void 0 ? events : [];
        this._defaultTopics = defaultTopics !== null && defaultTopics !== void 0 ? defaultTopics : [];
    }
    add(module, name, data, topics, noRevert) {
        const allTopics = [...this._defaultTopics, ...(topics !== null && topics !== void 0 ? topics : [])];
        if (data.length > chain_1.EVENT_MAX_EVENT_SIZE_BYTES) {
            throw new Error(`Max size of event data is ${chain_1.EVENT_MAX_EVENT_SIZE_BYTES} but received ${data.length}`);
        }
        if (allTopics.length > chain_1.EVENT_MAX_TOPICS_PER_EVENT) {
            throw new Error(`Max topics per event is ${chain_1.EVENT_MAX_TOPICS_PER_EVENT} but received ${allTopics.length}`);
        }
        this.unsafeAdd(module, name, data, topics, noRevert);
    }
    unsafeAdd(module, name, data, topics, noRevert) {
        const allTopics = [...this._defaultTopics, ...(topics !== null && topics !== void 0 ? topics : [])];
        this._events.push({
            event: new chain_1.Event({
                module,
                name,
                index: this._events.length,
                data,
                topics: allTopics,
                height: this._height,
            }),
            noRevert: noRevert !== null && noRevert !== void 0 ? noRevert : false,
        });
    }
    getChildQueue(topicID) {
        return new EventQueue(this._height, this._events, [topicID]);
    }
    createSnapshot() {
        return this._events.length;
    }
    restoreSnapshot(snapshotID) {
        const newEvents = this._events.splice(snapshotID);
        const nonRevertableEvents = newEvents
            .filter(eventData => eventData.noRevert)
            .map((eventData, i) => ({
            event: new chain_1.Event({
                ...eventData.event.toObject(),
                index: snapshotID + i,
            }),
            noRevert: false,
        }));
        this._events.push(...nonRevertableEvents);
    }
    getEvents() {
        return this._events.map(e => e.event);
    }
}
exports.EventQueue = EventQueue;
//# sourceMappingURL=event_queue.js.map