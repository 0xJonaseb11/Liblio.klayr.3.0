"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockContext = void 0;
const method_context_1 = require("./method_context");
const constants_1 = require("./constants");
const transaction_context_1 = require("./transaction_context");
class BlockContext {
    constructor(params) {
        this._logger = params.logger;
        this._chainID = params.chainID;
        this._stateStore = params.stateStore;
        this._eventQueue = params.eventQueue;
        this._header = params.header;
        this._assets = params.assets;
        this._transactions = params.transactions;
        this._contextStore = params.contextStore;
    }
    get transactions() {
        if (!this._transactions) {
            throw new Error('Transactions are not set');
        }
        return this._transactions;
    }
    setTransactions(transactions) {
        this._transactions = transactions;
    }
    getBlockVerifyExecuteContext() {
        return {
            logger: this._logger,
            chainID: this._chainID,
            getMethodContext: () => (0, method_context_1.createImmutableMethodContext)(this._stateStore),
            stateStore: this._stateStore,
            contextStore: this._contextStore,
            getStore: (moduleID, storePrefix) => this._stateStore.getStore(moduleID, storePrefix),
            header: this._header,
            assets: this._assets,
        };
    }
    getBlockExecuteContext() {
        const childQueue = this._eventQueue.getChildQueue(constants_1.EVENT_INDEX_BEFORE_TRANSACTIONS);
        return {
            logger: this._logger,
            chainID: this._chainID,
            eventQueue: childQueue,
            stateStore: this._stateStore,
            contextStore: this._contextStore,
            getMethodContext: () => (0, method_context_1.createMethodContext)({
                stateStore: this._stateStore,
                eventQueue: childQueue,
                contextStore: this._contextStore,
            }),
            getStore: (moduleID, storePrefix) => this._stateStore.getStore(moduleID, storePrefix),
            header: this._header,
            assets: this._assets,
        };
    }
    getBlockAfterExecuteContext() {
        if (!this._transactions) {
            throw new Error('Cannot create block after execute context without transactions');
        }
        const childQueue = this._eventQueue.getChildQueue(constants_1.EVENT_INDEX_AFTER_TRANSACTIONS);
        return {
            logger: this._logger,
            chainID: this._chainID,
            eventQueue: childQueue,
            contextStore: this._contextStore,
            stateStore: this._stateStore,
            getMethodContext: () => (0, method_context_1.createMethodContext)({
                stateStore: this._stateStore,
                eventQueue: childQueue,
                contextStore: this._contextStore,
            }),
            getStore: (moduleID, storePrefix) => this._stateStore.getStore(moduleID, storePrefix),
            header: this._header,
            assets: this._assets,
            transactions: this._transactions,
            setNextValidators: (precommitThreshold, certificateThreshold, validators) => {
                if (this._nextValidators) {
                    throw new Error('Next validators can be set only once');
                }
                this._nextValidators = {
                    precommitThreshold,
                    certificateThreshold,
                    validators: [...validators],
                };
            },
        };
    }
    getTransactionContext(tx) {
        return new transaction_context_1.TransactionContext({
            chainID: this._chainID,
            logger: this._logger,
            stateStore: this._stateStore,
            contextStore: this._contextStore,
            transaction: tx,
            eventQueue: this._eventQueue,
            header: this._header,
            assets: this._assets,
        });
    }
    get eventQueue() {
        return this._eventQueue;
    }
    get nextValidators() {
        var _a;
        return ((_a = this._nextValidators) !== null && _a !== void 0 ? _a : {
            certificateThreshold: BigInt(0),
            precommitThreshold: BigInt(0),
            validators: [],
        });
    }
    get assets() {
        return this._assets;
    }
}
exports.BlockContext = BlockContext;
//# sourceMappingURL=block_context.js.map