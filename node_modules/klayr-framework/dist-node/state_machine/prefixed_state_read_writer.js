"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrefixedStateReadWriter = void 0;
const codec_1 = require("@klayr/codec");
class PrefixedStateReadWriter {
    constructor(stateDB, prefix) {
        this._readWriter = stateDB;
        this._prefix = prefix !== null && prefix !== void 0 ? prefix : Buffer.alloc(0);
    }
    get inner() {
        return this._readWriter;
    }
    getStore(moduleID, prefixBytes) {
        const nextPrefix = Buffer.concat([this._prefix, moduleID, prefixBytes]);
        return new PrefixedStateReadWriter(this._readWriter, nextPrefix);
    }
    async get(key) {
        const prefixedKey = this._getKey(key);
        return this._readWriter.get(prefixedKey);
    }
    async getWithSchema(key, schema) {
        const value = await this.get(key);
        return codec_1.codec.decode(schema, value);
    }
    async has(key) {
        return this._readWriter.has(this._getKey(key));
    }
    async set(key, value) {
        return this._readWriter.set(this._getKey(key), value);
    }
    async setWithSchema(key, value, schema) {
        const encodedValue = codec_1.codec.encode(schema, value);
        await this.set(key, encodedValue);
    }
    async del(key) {
        await this._readWriter.del(this._getKey(key));
    }
    async iterate(options) {
        const optionsWithKey = {
            ...options,
            gte: options.gte ? this._getKey(options.gte) : undefined,
            lte: options.lte ? this._getKey(options.lte) : undefined,
        };
        const result = await this._readWriter.range(optionsWithKey);
        return result.map(kv => ({
            key: kv.key.subarray(this._prefix.length),
            value: kv.value,
        }));
    }
    async iterateWithSchema(options, schema) {
        const optionsWithKey = {
            ...options,
            gte: options.gte ? this._getKey(options.gte) : undefined,
            lte: options.lte ? this._getKey(options.lte) : undefined,
        };
        const result = await this._readWriter.range(optionsWithKey);
        return result.map(kv => ({
            key: kv.key.subarray(this._prefix.length),
            value: codec_1.codec.decode(schema, kv.value),
        }));
    }
    createSnapshot() {
        return this._readWriter.snapshot();
    }
    restoreSnapshot(snapshotID) {
        this._readWriter.restoreSnapshot(snapshotID);
    }
    _getKey(key) {
        return Buffer.concat([this._prefix, key]);
    }
}
exports.PrefixedStateReadWriter = PrefixedStateReadWriter;
//# sourceMappingURL=prefixed_state_read_writer.js.map