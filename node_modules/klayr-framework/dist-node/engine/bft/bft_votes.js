"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateMaxHeightCertified = exports.updateMaxHeightPrecommitted = exports.updateMaxHeightPrevoted = exports.updatePrevotesPrecommits = exports.getHeightNotPrevoted = exports.insertBlockBFTInfo = void 0;
const utils_1 = require("./utils");
const insertBlockBFTInfo = (bftVotes, header, maxLength) => {
    bftVotes.blockBFTInfos = [(0, utils_1.getBlockBFTProperties)(header), ...bftVotes.blockBFTInfos].slice(0, maxLength);
};
exports.insertBlockBFTInfo = insertBlockBFTInfo;
const getHeightNotPrevoted = (bftVotes) => {
    const [newBlockBFTInfo] = bftVotes.blockBFTInfos;
    const { height: currentHeight } = newBlockBFTInfo;
    let heightPreviousBlock = newBlockBFTInfo.maxHeightGenerated;
    while (currentHeight - heightPreviousBlock < bftVotes.blockBFTInfos.length) {
        const blockBFTInfo = bftVotes.blockBFTInfos[currentHeight - heightPreviousBlock];
        if (!blockBFTInfo.generatorAddress.equals(newBlockBFTInfo.generatorAddress) ||
            blockBFTInfo.maxHeightGenerated >= heightPreviousBlock) {
            return heightPreviousBlock;
        }
        heightPreviousBlock = blockBFTInfo.maxHeightGenerated;
    }
    return bftVotes.blockBFTInfos[bftVotes.blockBFTInfos.length - 1].height - 1;
};
exports.getHeightNotPrevoted = getHeightNotPrevoted;
const updatePrevotesPrecommits = async (bftVotes, paramsCache) => {
    if (bftVotes.blockBFTInfos.length === 0) {
        return;
    }
    const [newBlockBFTInfo] = bftVotes.blockBFTInfos;
    if (newBlockBFTInfo.maxHeightGenerated >= newBlockBFTInfo.height) {
        return;
    }
    const validatorInfo = bftVotes.activeValidatorsVoteInfo.find(v => v.address.equals(newBlockBFTInfo.generatorAddress));
    if (!validatorInfo) {
        return;
    }
    const heightNotPrevoted = (0, exports.getHeightNotPrevoted)(bftVotes);
    const minPrecommitHeight = Math.max(validatorInfo.minActiveHeight, heightNotPrevoted + 1, validatorInfo.largestHeightPrecommit + 1);
    let hasPrecommitted = false;
    for (const blockBFTInfo of bftVotes.blockBFTInfos) {
        if (blockBFTInfo.height < minPrecommitHeight) {
            break;
        }
        const params = await paramsCache.getParameters(blockBFTInfo.height);
        if (blockBFTInfo.prevoteWeight >= params.prevoteThreshold) {
            const bftValidator = params.validators.find(v => v.address.equals(newBlockBFTInfo.generatorAddress));
            if (!bftValidator) {
                throw new Error(`Invalid state. Validator ${newBlockBFTInfo.generatorAddress.toString('hex')} must be in the BFT parameters at height ${newBlockBFTInfo.height}`);
            }
            blockBFTInfo.precommitWeight += bftValidator.bftWeight;
            if (!hasPrecommitted) {
                const activeValidatorIndex = bftVotes.activeValidatorsVoteInfo.findIndex(v => v.address.equals(newBlockBFTInfo.generatorAddress));
                if (activeValidatorIndex > -1) {
                    bftVotes.activeValidatorsVoteInfo[activeValidatorIndex].largestHeightPrecommit =
                        blockBFTInfo.height;
                }
                hasPrecommitted = true;
            }
        }
    }
    const minPrevoteHeight = Math.max(newBlockBFTInfo.maxHeightGenerated + 1, validatorInfo.minActiveHeight);
    for (const blockBFTInfo of bftVotes.blockBFTInfos) {
        if (blockBFTInfo.height < minPrevoteHeight) {
            break;
        }
        const params = await paramsCache.getParameters(blockBFTInfo.height);
        const bftValidator = params.validators.find(v => v.address.equals(newBlockBFTInfo.generatorAddress));
        if (!bftValidator) {
            throw new Error(`Invalid state. Validator ${newBlockBFTInfo.generatorAddress.toString('hex')} must be in the BFT parameters at height ${newBlockBFTInfo.height}`);
        }
        blockBFTInfo.prevoteWeight += bftValidator.bftWeight;
    }
};
exports.updatePrevotesPrecommits = updatePrevotesPrecommits;
const updateMaxHeightPrevoted = async (bftVotes, paramsCache) => {
    for (const blockBFTInfo of bftVotes.blockBFTInfos) {
        const params = await paramsCache.getParameters(blockBFTInfo.height);
        if (blockBFTInfo.prevoteWeight >= params.prevoteThreshold) {
            bftVotes.maxHeightPrevoted = blockBFTInfo.height;
            return;
        }
    }
};
exports.updateMaxHeightPrevoted = updateMaxHeightPrevoted;
const updateMaxHeightPrecommitted = async (bftVotes, paramsCache) => {
    for (const blockBFTInfo of bftVotes.blockBFTInfos) {
        const params = await paramsCache.getParameters(blockBFTInfo.height);
        if (blockBFTInfo.precommitWeight >= params.precommitThreshold) {
            bftVotes.maxHeightPrecommitted = blockBFTInfo.height;
            return;
        }
    }
};
exports.updateMaxHeightPrecommitted = updateMaxHeightPrecommitted;
const updateMaxHeightCertified = (bftVotes, header) => {
    if (header.aggregateCommit.aggregationBits.length === 0 &&
        header.aggregateCommit.certificateSignature.length === 0) {
        return;
    }
    bftVotes.maxHeightCertified = header.aggregateCommit.height;
};
exports.updateMaxHeightCertified = updateMaxHeightCertified;
//# sourceMappingURL=bft_votes.js.map