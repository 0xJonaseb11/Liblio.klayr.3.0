"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSynchronizer = void 0;
const chain_1 = require("@klayr/chain");
const validator_1 = require("@klayr/validator");
const codec_1 = require("@klayr/codec");
const errors_1 = require("./errors");
const schema_1 = require("../schema");
const constants_1 = require("../constants");
class BaseSynchronizer {
    constructor(logger, chain, network) {
        this._stop = false;
        this._logger = logger;
        this._chain = chain;
        this._network = network;
    }
    stop() {
        this._stop = true;
    }
    async _getLastBlockFromNetwork(peerId) {
        const { data } = (await this._network.requestFromPeer({
            procedure: constants_1.NETWORK_RPC_GET_LAST_BLOCK,
            peerId,
        }));
        if (!(data === null || data === void 0 ? void 0 : data.length)) {
            throw new errors_1.ApplyPenaltyAndRestartError(peerId, 'Peer did not provide its last block');
        }
        return chain_1.Block.fromBytes(data);
    }
    async _getHighestCommonBlockFromNetwork(peerId, ids) {
        const blockIds = codec_1.codec.encode(schema_1.getHighestCommonBlockRequestSchema, { ids });
        const { data } = (await this._network.requestFromPeer({
            procedure: constants_1.NETWORK_RPC_GET_HIGHEST_COMMON_BLOCK,
            peerId,
            data: blockIds,
        }));
        const decodedResp = codec_1.codec.decode(schema_1.getHighestCommonBlockResponseSchema, data);
        if (!decodedResp.id.length) {
            return undefined;
        }
        try {
            validator_1.validator.validate(schema_1.getHighestCommonBlockResponseSchema, decodedResp);
        }
        catch {
            throw new errors_1.ApplyPenaltyAndAbortError(peerId, 'Invalid common block response format');
        }
        return this._chain.dataAccess.getBlockHeaderByID(decodedResp.id);
    }
    async _getBlocksFromNetwork(peerId, fromID) {
        const blockId = codec_1.codec.encode(schema_1.getBlocksFromIdRequestSchema, { blockId: fromID });
        const { data } = (await this._network.requestFromPeer({
            procedure: constants_1.NETWORK_RPC_GET_BLOCKS_FROM_ID,
            data: blockId,
            peerId,
        }));
        if (!(data === null || data === void 0 ? void 0 : data.length)) {
            throw new Error(`Peer ${peerId} did not respond with block`);
        }
        const decodedData = codec_1.codec.decode(schema_1.getBlocksFromIdResponseSchema, data);
        return decodedData.blocks.map(block => chain_1.Block.fromBytes(block));
    }
}
exports.BaseSynchronizer = BaseSynchronizer;
//# sourceMappingURL=base_synchronizer.js.map