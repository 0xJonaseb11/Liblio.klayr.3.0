"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSortedWeightsAndValidatorKeys = exports.verifyAggregateCertificateSignature = exports.verifySingleCertificateSignature = exports.signCertificate = exports.computeUnsignedCertificateFromBlockHeader = void 0;
const cryptography_1 = require("@klayr/cryptography");
const codec_1 = require("@klayr/codec");
const schema_1 = require("./schema");
const constants_1 = require("./constants");
const computeUnsignedCertificateFromBlockHeader = (blockHeader) => {
    if (!blockHeader.stateRoot) {
        throw new Error('stateRoot is not defined.');
    }
    if (!blockHeader.validatorsHash) {
        throw new Error('validatorsHash is not defined.');
    }
    return {
        blockID: blockHeader.id,
        height: blockHeader.height,
        stateRoot: blockHeader.stateRoot,
        timestamp: blockHeader.timestamp,
        validatorsHash: blockHeader.validatorsHash,
    };
};
exports.computeUnsignedCertificateFromBlockHeader = computeUnsignedCertificateFromBlockHeader;
const signCertificate = (sk, chainID, unsignedCertificate) => cryptography_1.bls.signData(constants_1.MESSAGE_TAG_CERTIFICATE, chainID, codec_1.codec.encode(schema_1.unsignedCertificateSchema, unsignedCertificate), sk);
exports.signCertificate = signCertificate;
const verifySingleCertificateSignature = (pk, signature, chainID, unsignedCertificate) => cryptography_1.bls.verifyData(constants_1.MESSAGE_TAG_CERTIFICATE, chainID, codec_1.codec.encode(schema_1.unsignedCertificateSchema, unsignedCertificate), signature, pk);
exports.verifySingleCertificateSignature = verifySingleCertificateSignature;
const verifyAggregateCertificateSignature = (validators, threshold, chainID, certificate) => {
    if (!certificate.aggregationBits || !certificate.signature) {
        return false;
    }
    const { weights, validatorKeys } = (0, exports.getSortedWeightsAndValidatorKeys)(validators);
    const { aggregationBits, signature, ...unsignedCertificate } = certificate;
    return cryptography_1.bls.verifyWeightedAggSig(validatorKeys, aggregationBits, signature, constants_1.MESSAGE_TAG_CERTIFICATE, chainID, codec_1.codec.encode(schema_1.unsignedCertificateSchema, unsignedCertificate), weights, threshold);
};
exports.verifyAggregateCertificateSignature = verifyAggregateCertificateSignature;
const getSortedWeightsAndValidatorKeys = (validators) => {
    validators.sort((a, b) => a.blsKey.compare(b.blsKey));
    const weights = [];
    const validatorKeys = [];
    for (const validator of validators) {
        weights.push(validator.bftWeight);
        validatorKeys.push(validator.blsKey);
    }
    return { weights, validatorKeys };
};
exports.getSortedWeightsAndValidatorKeys = getSortedWeightsAndValidatorKeys;
//# sourceMappingURL=utils.js.map