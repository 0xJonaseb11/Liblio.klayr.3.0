"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatorKeysExist = exports.setGeneratorKey = exports.getGeneratorKeys = exports.getAllGeneratorKeys = exports.isEqualGeneratedInfo = exports.isZeroValueGeneratedInfo = exports.getOrDefaultLastGeneratedInfo = exports.getLastGeneratedInfo = exports.setLastGeneratedInfo = exports.getGeneratedInfo = void 0;
const codec_1 = require("@klayr/codec");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const schemas_1 = require("./schemas");
const getGeneratedInfo = async (store) => {
    const subStore = store.getGeneratorStore(constants_1.GENERATOR_STORE_INFO_PREFIX);
    const encodedGeneratedInfoList = await subStore.iterate({
        gte: Buffer.alloc(20, 0),
        lte: Buffer.alloc(20, 255),
    });
    const generatedInfoList = [];
    for (const { key, value } of encodedGeneratedInfoList) {
        const info = codec_1.codec.decode(schemas_1.previouslyGeneratedInfoSchema, value);
        generatedInfoList.push({
            address: key,
            ...info,
        });
    }
    return generatedInfoList;
};
exports.getGeneratedInfo = getGeneratedInfo;
const setLastGeneratedInfo = async (store, generatorAddress, header) => {
    const subStore = store.getGeneratorStore(constants_1.GENERATOR_STORE_INFO_PREFIX);
    const generatedInfo = {
        height: header.height,
        maxHeightGenerated: header.maxHeightGenerated,
        maxHeightPrevoted: header.maxHeightPrevoted,
    };
    const encodedGeneratedInfo = codec_1.codec.encode(schemas_1.previouslyGeneratedInfoSchema, generatedInfo);
    await subStore.set(generatorAddress, encodedGeneratedInfo);
};
exports.setLastGeneratedInfo = setLastGeneratedInfo;
const getLastGeneratedInfo = async (store, generatorAddress) => {
    const subStore = store.getGeneratorStore(constants_1.GENERATOR_STORE_INFO_PREFIX);
    const encodedGeneratedInfo = await subStore.get(generatorAddress);
    return codec_1.codec.decode(schemas_1.previouslyGeneratedInfoSchema, encodedGeneratedInfo);
};
exports.getLastGeneratedInfo = getLastGeneratedInfo;
const getOrDefaultLastGeneratedInfo = async (store, generatorAddress) => {
    try {
        const info = await (0, exports.getLastGeneratedInfo)(store, generatorAddress);
        return info;
    }
    catch (error) {
        if (!(error instanceof errors_1.NotFoundError)) {
            throw error;
        }
        return {
            height: 0,
            maxHeightGenerated: 0,
            maxHeightPrevoted: 0,
        };
    }
};
exports.getOrDefaultLastGeneratedInfo = getOrDefaultLastGeneratedInfo;
const isZeroValueGeneratedInfo = (info) => info.height === 0 && info.maxHeightGenerated === 0 && info.maxHeightPrevoted === 0;
exports.isZeroValueGeneratedInfo = isZeroValueGeneratedInfo;
const isEqualGeneratedInfo = (g1, g2) => g1.height === g2.height &&
    g1.maxHeightGenerated === g2.maxHeightGenerated &&
    g1.maxHeightPrevoted === g2.maxHeightPrevoted;
exports.isEqualGeneratedInfo = isEqualGeneratedInfo;
const getAllGeneratorKeys = async (store) => {
    const subStore = store.getGeneratorStore(constants_1.GENERATOR_STORE_KEY_PREFIX);
    const encodedGeneratorKeysList = await subStore.iterate({
        gte: Buffer.alloc(20, 0),
        lte: Buffer.alloc(20, 255),
    });
    const result = [];
    for (const { key, value } of encodedGeneratorKeysList) {
        const encodedGeneratorKeys = codec_1.codec.decode(schemas_1.generatorKeysSchema, value);
        if (encodedGeneratorKeys.type === 'plain') {
            result.push({
                type: encodedGeneratorKeys.type,
                address: key,
                data: codec_1.codec.decode(schemas_1.plainGeneratorKeysSchema, encodedGeneratorKeys.data),
            });
            continue;
        }
        result.push({
            type: encodedGeneratorKeys.type,
            address: key,
            data: codec_1.codec.decode(schemas_1.encryptedMessageSchema, encodedGeneratorKeys.data),
        });
    }
    return result;
};
exports.getAllGeneratorKeys = getAllGeneratorKeys;
const getGeneratorKeys = async (store, address) => {
    const subStore = store.getGeneratorStore(constants_1.GENERATOR_STORE_KEY_PREFIX);
    const encodedKeysBytes = await subStore.get(address);
    const encodedKeys = codec_1.codec.decode(schemas_1.generatorKeysSchema, encodedKeysBytes);
    if (encodedKeys.type === 'plain') {
        return {
            address,
            type: encodedKeys.type,
            data: codec_1.codec.decode(schemas_1.plainGeneratorKeysSchema, encodedKeys.data),
        };
    }
    return {
        address,
        type: encodedKeys.type,
        data: codec_1.codec.decode(schemas_1.encryptedMessageSchema, encodedKeys.data),
    };
};
exports.getGeneratorKeys = getGeneratorKeys;
const setGeneratorKey = async (store, address, keys) => {
    const subStore = store.getGeneratorStore(constants_1.GENERATOR_STORE_KEY_PREFIX);
    const schema = keys.type === 'plain' ? schemas_1.plainGeneratorKeysSchema : schemas_1.encryptedMessageSchema;
    const data = codec_1.codec.encode(schema, keys.data);
    const encodedGeneratorKeys = codec_1.codec.encode(schemas_1.generatorKeysSchema, { type: keys.type, data });
    await subStore.set(address, encodedGeneratorKeys);
};
exports.setGeneratorKey = setGeneratorKey;
const generatorKeysExist = async (store, address) => {
    const subStore = store.getGeneratorStore(constants_1.GENERATOR_STORE_KEY_PREFIX);
    try {
        await subStore.get(address);
        return true;
    }
    catch (error) {
        if (error instanceof errors_1.NotFoundError) {
            return false;
        }
        throw error;
    }
};
exports.generatorKeysExist = generatorKeysExist;
//# sourceMappingURL=generated_info.js.map