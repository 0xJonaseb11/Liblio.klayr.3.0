"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HighFeeGenerationStrategy = void 0;
const utils_1 = require("@klayr/utils");
const chain_1 = require("@klayr/chain");
const cryptography_1 = require("@klayr/cryptography");
const abi_1 = require("../../abi");
class HighFeeGenerationStrategy {
    constructor({ abi, pool, maxTransactionsSize, }) {
        this._abi = abi;
        this._pool = pool;
        this._constants = { maxTransactionsSize };
    }
    async getTransactionsForBlock(contextID, header, assets) {
        var _a;
        const readyTransactions = [];
        const transactionsMappedBySender = this._pool.getProcessableTransactions();
        let blockTransactionsSize = 0;
        const feePriorityHeap = new utils_1.dataStructures.MaxHeap();
        for (const transactions of transactionsMappedBySender.values()) {
            const lowestNonceTrx = transactions[0];
            feePriorityHeap.push(lowestNonceTrx.feePriority, lowestNonceTrx);
        }
        const events = [];
        while (transactionsMappedBySender.size > 0) {
            const lowestNonceHighestFeeTrx = (_a = feePriorityHeap.pop()) === null || _a === void 0 ? void 0 : _a.value;
            if (!lowestNonceHighestFeeTrx) {
                throw new Error('lowest nonce tx must exist');
            }
            const trsByteSize = lowestNonceHighestFeeTrx.getBytes().length;
            if (blockTransactionsSize + trsByteSize > this._constants.maxTransactionsSize) {
                break;
            }
            const senderId = cryptography_1.address.getAddressFromPublicKey(lowestNonceHighestFeeTrx.senderPublicKey);
            try {
                const { result: verifyResult } = await this._abi.verifyTransaction({
                    contextID,
                    transaction: lowestNonceHighestFeeTrx.toObject(),
                    header: header.toObject(),
                    onlyCommand: false,
                });
                if (verifyResult !== abi_1.TransactionVerifyResult.OK) {
                    throw new Error('Transaction is not valid');
                }
                const { events: executedEvents, result: executeResult } = await this._abi.executeTransaction({
                    contextID,
                    header: header.toObject(),
                    transaction: lowestNonceHighestFeeTrx.toObject(),
                    assets: assets.getAll(),
                    dryRun: false,
                });
                if (executeResult === abi_1.TransactionExecutionResult.INVALID) {
                    this._pool.remove(lowestNonceHighestFeeTrx);
                    throw new Error('Transaction is not valid');
                }
                events.push(...executedEvents.map(e => new chain_1.Event(e)));
            }
            catch (error) {
                transactionsMappedBySender.delete(senderId);
                continue;
            }
            readyTransactions.push(lowestNonceHighestFeeTrx);
            blockTransactionsSize += trsByteSize;
            const [, ...choppedArray] = transactionsMappedBySender.get(senderId);
            transactionsMappedBySender.set(senderId, choppedArray);
            const remainingTransactions = transactionsMappedBySender.get(senderId);
            if (!remainingTransactions || remainingTransactions.length === 0) {
                transactionsMappedBySender.delete(senderId);
                continue;
            }
            const nextLowestNonceTransactions = transactionsMappedBySender.get(senderId);
            feePriorityHeap.push(nextLowestNonceTransactions[0].feePriority, nextLowestNonceTransactions[0]);
        }
        return { transactions: readyTransactions, events };
    }
}
exports.HighFeeGenerationStrategy = HighFeeGenerationStrategy;
//# sourceMappingURL=strategies.js.map