"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Storage = void 0;
const lisk_db_1 = require("@liskhq/lisk-db");
const cryptography_1 = require("@klayr/cryptography");
const codec_1 = require("@klayr/codec");
const codec_2 = require("./codec");
const utils_1 = require("./utils");
const schemas_1 = require("./schemas");
class Storage {
    constructor(db) {
        this._db = db;
    }
    async getTransactionByID(id) {
        return this._db.get((0, utils_1.buildTxIDDbKey)(id));
    }
    async getBlockByID(id) {
        const blockHeader = await this._db.get((0, utils_1.buildBlockIDDbKey)(id));
        let payload = [];
        try {
            payload = await this.getTransactionsByBlockID(id);
        }
        catch (error) {
            if (!(error instanceof lisk_db_1.NotFoundError)) {
                throw error;
            }
        }
        return codec_1.codec.encode(schemas_1.blockSchemaV2, {
            header: blockHeader,
            payload,
        });
    }
    async getBlockByHeight(height) {
        const id = await this._db.get((0, utils_1.buildBlockHeightDbKey)(height));
        return this.getBlockByID(id);
    }
    async getBlocksByHeightBetween(fromHeight, toHeight) {
        const ids = await this._getBlockIDsBetweenHeights(fromHeight, toHeight);
        return Promise.all(ids.map(async (id) => this.getBlockByID(id)));
    }
    async isBlockPersisted(blockID) {
        return this._db.has((0, utils_1.buildBlockIDDbKey)(blockID));
    }
    async isBlockHeightPersisted(height) {
        return this._db.has((0, utils_1.buildBlockHeightDbKey)(height));
    }
    async getTransactionsByBlockID(blockID) {
        const txIdsBuffer = await this._db.get((0, utils_1.buildTxsBlockIDDbKey)(blockID));
        if (!txIdsBuffer.length) {
            return [];
        }
        const txIds = [];
        const idLength = 32;
        for (let i = 0; i < txIdsBuffer.length; i += idLength) {
            const txId = txIdsBuffer.subarray(i, i + idLength);
            txIds.push(txId);
        }
        return Promise.all(txIds.map(async (id) => this.getTransactionByID(id)));
    }
    async saveBlock(blockID, height, block, payload) {
        const batch = new lisk_db_1.Batch();
        const blockIDDbKey = (0, utils_1.buildBlockIDDbKey)(blockID);
        batch.set(blockIDDbKey, block);
        batch.set((0, utils_1.buildBlockHeightDbKey)(height), blockID);
        const txIds = payload.map(tx => cryptography_1.utils.hash(tx));
        for (let index = 0; index < payload.length; index += 1) {
            batch.set((0, utils_1.buildTxIDDbKey)(txIds[index]), payload[index]);
        }
        batch.set((0, utils_1.buildTxsBlockIDDbKey)(blockID), Buffer.concat(txIds));
        await this._db.write(batch);
    }
    async getBracketInfo(snapshotBlockID) {
        const encodedBracketInfo = await this._db.get((0, utils_1.buildLegacyBracketDBKey)(snapshotBlockID));
        return (0, codec_2.decodeLegacyChainBracketInfo)(encodedBracketInfo);
    }
    async setBracketInfo(snapshotBlockID, bracketInfo) {
        await this._db.set((0, utils_1.buildLegacyBracketDBKey)(snapshotBlockID), (0, codec_2.encodeLegacyChainBracketInfo)(bracketInfo));
    }
    async hasBracketInfo(snapshotBlockID) {
        try {
            const bracketInfo = await this.getBracketInfo(snapshotBlockID);
            return !!bracketInfo;
        }
        catch (error) {
            if (!(error instanceof lisk_db_1.NotFoundError)) {
                throw error;
            }
            return false;
        }
    }
    async _getBlockIDsBetweenHeights(fromHeight, toHeight) {
        const stream = this._db.createReadStream({
            gte: (0, utils_1.buildBlockHeightDbKey)(fromHeight),
            lte: (0, utils_1.buildBlockHeightDbKey)(toHeight),
            reverse: true,
        });
        return new Promise((resolve, reject) => {
            const ids = [];
            stream
                .on('data', ({ value }) => {
                ids.push(value);
            })
                .on('error', error => {
                reject(error);
            })
                .on('end', () => {
                resolve(ids);
            });
        });
    }
}
exports.Storage = Storage;
//# sourceMappingURL=storage.js.map