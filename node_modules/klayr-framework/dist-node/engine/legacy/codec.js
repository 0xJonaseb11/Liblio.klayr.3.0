"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeLegacyChainBracketInfo = exports.encodeLegacyChainBracketInfo = exports.encodeBlockHeader = exports.encodeBlock = exports.getLegacyTransactionJSONWithSchema = exports.decodeBlockJSON = exports.decodeBlockHeader = exports.decodeBlock = exports.getBlockSchema = exports.blockSchemaMap = void 0;
const codec_1 = require("@klayr/codec");
const cryptography_1 = require("@klayr/cryptography");
const schemas_1 = require("./schemas");
exports.blockSchemaMap = {
    2: {
        block: schemas_1.blockSchemaV2,
        header: schemas_1.blockHeaderSchemaV2,
    },
};
const getBlockSchema = (version) => {
    const blockSchema = exports.blockSchemaMap[version];
    if (!blockSchema) {
        throw new Error(`Legacy block version ${version} is not registered.`);
    }
    return blockSchema;
};
exports.getBlockSchema = getBlockSchema;
const readVersion = () => 2;
const decodeBlock = (data) => {
    const version = readVersion();
    const blockSchema = (0, exports.getBlockSchema)(version);
    const rawBlock = codec_1.codec.decode(blockSchema.block, data);
    const id = cryptography_1.utils.hash(rawBlock.header);
    return {
        block: {
            ...rawBlock,
            header: {
                ...codec_1.codec.decode(blockSchema.header, rawBlock.header),
                id,
            },
        },
        schema: blockSchema,
    };
};
exports.decodeBlock = decodeBlock;
const decodeBlockHeader = (blockHeader) => {
    const version = readVersion();
    const blockSchema = (0, exports.getBlockSchema)(version);
    const id = cryptography_1.utils.hash(blockHeader);
    return {
        ...codec_1.codec.decode(blockSchema.header, blockHeader),
        id,
    };
};
exports.decodeBlockHeader = decodeBlockHeader;
const decodeBlockJSON = (data) => {
    const { block, schema } = (0, exports.decodeBlock)(data);
    return {
        block: {
            header: {
                ...codec_1.codec.toJSON(schema.header, block.header),
                id: block.header.id.toString('hex'),
            },
            payload: block.payload.map(tx => tx.toString('hex')),
        },
        schema,
    };
};
exports.decodeBlockJSON = decodeBlockJSON;
const getLegacyTransactionJSONWithSchema = (data) => {
    const legacyTransaction = codec_1.codec.decode(schemas_1.transactionSchemaV2, data);
    const id = cryptography_1.utils.hash(data);
    return {
        transaction: {
            ...codec_1.codec.toJSON(schemas_1.transactionSchemaV2, legacyTransaction),
            id: id.toString('hex'),
        },
        schema: schemas_1.transactionSchemaV2,
    };
};
exports.getLegacyTransactionJSONWithSchema = getLegacyTransactionJSONWithSchema;
const encodeBlock = (data) => {
    const blockSchema = (0, exports.getBlockSchema)(data.header.version);
    const headerBytes = codec_1.codec.encode(blockSchema.header, data.header);
    return codec_1.codec.encode(blockSchema.block, {
        header: headerBytes,
        payload: data.payload,
    });
};
exports.encodeBlock = encodeBlock;
const encodeBlockHeader = (blockHeader) => {
    const blockSchema = (0, exports.getBlockSchema)(blockHeader.version);
    return codec_1.codec.encode(blockSchema.header, blockHeader);
};
exports.encodeBlockHeader = encodeBlockHeader;
const encodeLegacyChainBracketInfo = (data) => codec_1.codec.encode(schemas_1.legacyChainBracketInfoSchema, data);
exports.encodeLegacyChainBracketInfo = encodeLegacyChainBracketInfo;
const decodeLegacyChainBracketInfo = (data) => codec_1.codec.decode(schemas_1.legacyChainBracketInfoSchema, data);
exports.decodeLegacyChainBracketInfo = decodeLegacyChainBracketInfo;
//# sourceMappingURL=codec.js.map