"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsensusEndpoint = void 0;
const chain_1 = require("@klayr/chain");
const cryptography_1 = require("@klayr/cryptography");
class ConsensusEndpoint {
    constructor(args) {
        this._bftMethod = args.bftMethod;
        this._blockchainDB = args.blockchainDB;
    }
    async getBFTParameters(ctx) {
        const stateStore = new chain_1.StateStore(this._blockchainDB);
        const { certificateThreshold, precommitThreshold, prevoteThreshold, validators, validatorsHash, } = await this._bftMethod.getBFTParameters(stateStore, ctx.params.height);
        const validatorsJSON = validators.map(v => ({
            address: cryptography_1.address.getKlayr32AddressFromAddress(v.address),
            bftWeight: v.bftWeight.toString(),
            blsKey: v.blsKey.toString('hex'),
        }));
        return {
            validators: validatorsJSON,
            certificateThreshold: certificateThreshold.toString(),
            precommitThreshold: precommitThreshold.toString(),
            prevoteThreshold: prevoteThreshold.toString(),
            validatorsHash: validatorsHash.toString('hex'),
        };
    }
    async getBFTParametersActiveValidators(ctx) {
        const stateStore = new chain_1.StateStore(this._blockchainDB);
        const { certificateThreshold, precommitThreshold, prevoteThreshold, validators, validatorsHash, } = await this._bftMethod.getBFTParametersActiveValidators(stateStore, ctx.params.height);
        const validatorsJSON = validators.map(v => ({
            address: cryptography_1.address.getKlayr32AddressFromAddress(v.address),
            bftWeight: v.bftWeight.toString(),
            blsKey: v.blsKey.toString('hex'),
        }));
        return {
            validators: validatorsJSON,
            certificateThreshold: certificateThreshold.toString(),
            precommitThreshold: precommitThreshold.toString(),
            prevoteThreshold: prevoteThreshold.toString(),
            validatorsHash: validatorsHash.toString('hex'),
        };
    }
    async getBFTHeights(_ctx) {
        const stateStore = new chain_1.StateStore(this._blockchainDB);
        const result = await this._bftMethod.getBFTHeights(stateStore);
        return result;
    }
}
exports.ConsensusEndpoint = ConsensusEndpoint;
//# sourceMappingURL=consensus.js.map