"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxpoolEndpoint = void 0;
const chain_1 = require("@klayr/chain");
const validator_1 = require("@klayr/validator");
const cryptography_1 = require("@klayr/cryptography");
const errors_1 = require("../generator/errors");
const schemas_1 = require("../generator/schemas");
const abi_1 = require("../../abi");
class TxpoolEndpoint {
    constructor(args) {
        this._abi = args.abi;
        this._pool = args.pool;
        this._broadcaster = args.broadcaster;
        this._chain = args.chain;
    }
    async postTransaction(ctx) {
        var _a;
        validator_1.validator.validate(schemas_1.postTransactionRequestSchema, ctx.params);
        const req = ctx.params;
        const transaction = chain_1.Transaction.fromBytes(Buffer.from(req.transaction, 'hex'));
        const { result, errorMessage } = await this._abi.verifyTransaction({
            contextID: Buffer.alloc(0),
            transaction: transaction.toObject(),
            header: this._chain.lastBlock.header.toObject(),
            onlyCommand: false,
        });
        if (result === abi_1.TransactionVerifyResult.INVALID) {
            throw new errors_1.InvalidTransactionError(errorMessage, transaction.id);
        }
        if (this._pool.contains(transaction.id)) {
            return {
                transactionId: transaction.id.toString('hex'),
            };
        }
        this._broadcaster.enqueueTransactionId(transaction.id);
        const { error } = await this._pool.add(transaction);
        if (error) {
            ctx.logger.error({ err: error }, 'Failed to add transaction to pool.');
            throw new errors_1.InvalidTransactionError((_a = error.message) !== null && _a !== void 0 ? _a : 'Transaction verification failed.', transaction.id);
        }
        ctx.logger.info({
            id: transaction.id,
            nonce: transaction.nonce.toString(),
            senderPublicKey: transaction.senderPublicKey,
        }, 'Added transaction to pool');
        return {
            transactionId: transaction.id.toString('hex'),
        };
    }
    async getTransactionsFromPool(ctx) {
        validator_1.validator.validate(schemas_1.getTransactionsFromPoolRequestSchema, ctx.params);
        const { address } = ctx.params;
        let transactions = this._pool.getAll();
        if (address) {
            transactions = transactions.filter(transaction => cryptography_1.address.getKlayr32AddressFromPublicKey(transaction.senderPublicKey) === address);
        }
        return transactions.map(transaction => transaction.toJSON());
    }
    async dryRunTransaction(ctx) {
        var _a;
        validator_1.validator.validate(schemas_1.dryRunTransactionRequestSchema, ctx.params);
        const req = ctx.params;
        const transaction = chain_1.Transaction.fromBytes(Buffer.from(req.transaction, 'hex'));
        const header = this._chain.lastBlock.header.toObject();
        if (!req.skipVerify) {
            const strict = (_a = req.strict) !== null && _a !== void 0 ? _a : false;
            const { result, errorMessage } = await this._abi.verifyTransaction({
                contextID: Buffer.alloc(0),
                transaction: transaction.toObject(),
                header,
                onlyCommand: !strict,
            });
            if (result === abi_1.TransactionVerifyResult.INVALID) {
                return {
                    result: abi_1.TransactionVerifyResult.INVALID,
                    events: [],
                    errorMessage,
                };
            }
        }
        const response = await this._abi.executeTransaction({
            contextID: Buffer.alloc(0),
            transaction: transaction.toObject(),
            assets: this._chain.lastBlock.assets.getAll(),
            dryRun: true,
            header,
        });
        return {
            result: response.result,
            events: response.events.map(e => new chain_1.Event(e).toJSON()),
        };
    }
}
exports.TxpoolEndpoint = TxpoolEndpoint;
//# sourceMappingURL=txpool.js.map