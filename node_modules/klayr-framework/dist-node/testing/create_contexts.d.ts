/// <reference types="node" />
/// <reference types="node" />
import { BlockAssets, BlockHeader, BlockHeaderAttrs, StateStore, Transaction } from '@klayr/chain';
import { ModuleEndpointContext } from '../types';
import { Logger } from '../logger';
import { BlockContext, EventQueue, GenesisBlockContext, ImmutableSubStore, InsertAssetContext, MethodContext, TransactionContext } from '../state_machine';
import { WritableBlockAssets } from '../engine/generator/types';
import { StateStore as IStateStore, SubStore } from '../state_machine/types';
import { PrefixedStateReadWriter } from '../state_machine/prefixed_state_read_writer';
import { CCMsg, CrossChainMessageContext, RecoverContext } from '../modules/interoperability/types';
export type CreateGenesisBlockContextParams = {
    header?: BlockHeader;
    stateStore?: PrefixedStateReadWriter;
    eventQueue?: EventQueue;
    assets?: BlockAssets;
    logger?: Logger;
    chainID?: Buffer;
};
export declare const createGenesisBlockContext: (params: CreateGenesisBlockContextParams) => GenesisBlockContext;
export declare const createBlockContext: (params: {
    stateStore?: PrefixedStateReadWriter;
    contextStore?: Map<string, unknown>;
    eventQueue?: EventQueue;
    chainID?: Buffer;
    logger?: Logger;
    header?: BlockHeader;
    assets?: BlockAssets;
    transactions?: Transaction[];
}) => BlockContext;
export declare const createBlockGenerateContext: (params: {
    assets?: WritableBlockAssets | undefined;
    getOffchainStore?: ((moduleID: Buffer, subStorePrefix: Buffer) => SubStore) | undefined;
    logger?: Logger | undefined;
    getMethodContext?: (() => MethodContext) | undefined;
    getStore?: ((moduleID: Buffer, storePrefix: Buffer) => ImmutableSubStore) | undefined;
    header: BlockHeader;
    finalizedHeight?: number | undefined;
    chainID?: Buffer | undefined;
}) => InsertAssetContext;
export declare const createTransactionContext: (params: {
    stateStore?: PrefixedStateReadWriter;
    contextStore?: Map<string, unknown>;
    eventQueue?: EventQueue;
    logger?: Logger;
    header?: BlockHeader;
    assets?: BlockAssets;
    chainID?: Buffer;
    transaction: Transaction;
}) => TransactionContext;
export declare const createTransientMethodContext: (params: {
    stateStore?: PrefixedStateReadWriter;
    contextStore?: Map<string, unknown>;
    eventQueue?: EventQueue;
}) => MethodContext;
export declare const createTransientModuleEndpointContext: (params: {
    stateStore?: PrefixedStateReadWriter | undefined;
    moduleStore?: StateStore | undefined;
    context?: {
        header: BlockHeaderAttrs;
    } | undefined;
    params?: Record<string, unknown> | undefined;
    logger?: Logger | undefined;
    chainID?: Buffer | undefined;
}) => ModuleEndpointContext;
export declare const createCrossChainMessageContext: (params: {
    ccm?: CCMsg | undefined;
    feeAddress?: Buffer | undefined;
    logger?: Logger | undefined;
    chainID?: Buffer | undefined;
    header?: {
        timestamp: number;
        height: number;
    } | undefined;
    transaction?: {
        senderAddress: Buffer;
        fee: bigint;
        params: Buffer;
    } | undefined;
    stateStore?: IStateStore | undefined;
    contextStore?: Map<string, unknown> | undefined;
    eventQueue?: EventQueue | undefined;
    sendingChainID?: Buffer | undefined;
}) => CrossChainMessageContext;
export declare const createBeforeRecoverCCMsgMethodContext: (params: {
    ccm: CCMsg;
    trsSender: Buffer;
    stateStore?: PrefixedStateReadWriter;
    logger?: Logger;
    chainID?: Buffer;
    getMethodContext?: () => MethodContext;
    feeAddress: Buffer;
    eventQueue?: EventQueue;
}) => CrossChainMessageContext;
export declare const createRecoverCCMsgMethodContext: (params: {
    ccm?: CCMsg;
    terminatedChainID: Buffer;
    module: string;
    storePrefix: Buffer;
    storeKey: Buffer;
    storeValue: Buffer;
    stateStore?: PrefixedStateReadWriter;
    logger?: Logger;
    chainID?: Buffer;
    getMethodContext?: () => MethodContext;
    feeAddress: Buffer;
    eventQueue?: EventQueue;
}) => RecoverContext;
