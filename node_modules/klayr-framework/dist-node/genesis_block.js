"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateGenesisBlock = void 0;
const os = require("os");
const path = require("path");
const chain_1 = require("@klayr/chain");
const codec_1 = require("@klayr/codec");
const cryptography_1 = require("@klayr/cryptography");
const lisk_db_1 = require("@liskhq/lisk-db");
const engine_1 = require("./engine");
const state_machine_1 = require("./state_machine");
const prefixed_state_read_writer_1 = require("./state_machine/prefixed_state_read_writer");
const utils_1 = require("./engine/bft/utils");
const GENESIS_BLOCK_VERSION = 0;
const EMPTY_BUFFER = Buffer.alloc(0);
const EMPTY_HASH = cryptography_1.utils.hash(EMPTY_BUFFER);
const generateGenesisBlock = async (stateMachine, logger, input) => {
    var _a, _b, _c;
    const assets = new chain_1.BlockAssets(input.assets.map(asset => ({
        module: asset.module,
        data: codec_1.codec.encode(asset.schema, asset.data),
    })));
    assets.sort();
    const assetRoot = await assets.getRoot();
    const height = (_a = input.height) !== null && _a !== void 0 ? _a : 0;
    const previousBlockID = (_b = input.previousBlockID) !== null && _b !== void 0 ? _b : Buffer.alloc(32, 0);
    const timestamp = (_c = input.timestamp) !== null && _c !== void 0 ? _c : Math.floor(Date.now() / 1000);
    const header = new chain_1.BlockHeader({
        version: GENESIS_BLOCK_VERSION,
        previousBlockID,
        height,
        timestamp,
        generatorAddress: Buffer.alloc(20, 0),
        maxHeightGenerated: 0,
        maxHeightPrevoted: height,
        signature: EMPTY_BUFFER,
        transactionRoot: EMPTY_HASH,
        impliesMaxPrevotes: true,
        assetRoot,
        aggregateCommit: {
            height,
            aggregationBits: EMPTY_BUFFER,
            certificateSignature: EMPTY_BUFFER,
        },
    });
    const tempPath = path.join(os.tmpdir(), cryptography_1.utils.getRandomBytes(3).toString('hex'), Date.now().toString());
    const stateDB = new lisk_db_1.StateDB(tempPath);
    const stateStore = new prefixed_state_read_writer_1.PrefixedStateReadWriter(stateDB.newReadWriter());
    const blockCtx = new state_machine_1.GenesisBlockContext({
        eventQueue: new state_machine_1.EventQueue(height),
        header,
        assets,
        logger,
        stateStore,
        chainID: input.chainID,
    });
    try {
        await stateMachine.executeGenesisBlock(blockCtx);
        const stateRoot = await stateDB.commit(stateStore.inner, height, EMPTY_HASH, {
            checkRoot: false,
            readonly: true,
        });
        header.stateRoot = stateRoot;
    }
    finally {
        stateDB.close();
        stateStore.inner.close();
    }
    const blockEvents = blockCtx.eventQueue.getEvents();
    const eventSMT = new lisk_db_1.SparseMerkleTree(chain_1.EVENT_KEY_LENGTH);
    const data = [];
    for (const e of blockEvents) {
        const pairs = e.keyPair();
        for (const pair of pairs) {
            data.push(pair);
        }
    }
    header.eventRoot = await eventSMT.update(EMPTY_HASH, data);
    (0, utils_1.sortValidatorsByBLSKey)(blockCtx.nextValidators.validators);
    header.validatorsHash = (0, engine_1.computeValidatorsHash)(blockCtx.nextValidators.validators
        .filter(v => v.bftWeight > BigInt(0))
        .map(v => ({ bftWeight: v.bftWeight, blsKey: v.blsKey })), blockCtx.nextValidators.certificateThreshold);
    return new chain_1.Block(header, [], assets);
};
exports.generateGenesisBlock = generateGenesisBlock;
//# sourceMappingURL=genesis_block.js.map