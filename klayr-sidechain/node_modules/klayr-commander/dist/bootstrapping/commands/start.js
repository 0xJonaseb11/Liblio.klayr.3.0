"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartCommand = void 0;
const core_1 = require("@oclif/core");
const fs = require("fs-extra");
const cryptography_1 = require("@klayr/cryptography");
const utils = require("@klayr/utils");
const flags_1 = require("../../utils/flags");
const path_1 = require("../../utils/path");
const LOG_OPTIONS = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];
class StartCommand extends core_1.Command {
    async run() {
        var _a, _b;
        const { flags } = await this.parse(this.constructor);
        const dataPath = flags['data-path']
            ? flags['data-path']
            : (0, path_1.getDefaultPath)(this.config.pjson.name);
        this.log(`Starting Klayr ${this.config.pjson.name} at ${(0, path_1.getFullPath)(dataPath)}.`);
        const defaultNetworkConfigDir = (0, path_1.getConfigDirs)(this.getApplicationConfigDir(), true);
        if (!defaultNetworkConfigDir.includes(flags.network)) {
            this.error(`Network ${flags.network} is not supported, supported networks: ${defaultNetworkConfigDir.join(',')}.`);
        }
        const { basePath: destBasePath, configFilePath, genesisBlockFilePath, } = (0, path_1.getConfigFilesPath)(dataPath);
        const { basePath: srcBasePath, genesisBlockFilePath: srcGenesisBlockPath } = (0, path_1.getNetworkConfigFilesPath)(this.getApplicationConfigDir(), flags.network, true);
        if (fs.existsSync(genesisBlockFilePath)) {
            if (!cryptography_1.utils
                .hash(fs.readFileSync(srcGenesisBlockPath))
                .equals(cryptography_1.utils.hash(fs.readFileSync(genesisBlockFilePath))) &&
                !flags['overwrite-config']) {
                this.error(`Datapath ${dataPath} already contains configs for ${flags.network}. Please use --overwrite-config to overwrite the config.`);
            }
        }
        if (!fs.existsSync(destBasePath) ||
            (fs.existsSync(destBasePath) && flags['overwrite-config'])) {
            (0, path_1.ensureConfigDir)(dataPath);
            fs.copySync(srcBasePath, destBasePath, { overwrite: true });
        }
        let config = await fs.readJSON(configFilePath);
        if (flags.config) {
            const customConfig = await fs.readJSON(flags.config);
            config = utils.objects.mergeDeep({}, config, customConfig);
        }
        config.system.version = this.config.pjson.version;
        config.system.dataPath = dataPath;
        const modes = [];
        if (flags['api-ipc']) {
            modes.push('ipc');
        }
        if (flags['api-ws']) {
            modes.push('ws');
        }
        if (flags['api-http']) {
            modes.push('http');
        }
        if (modes.length) {
            config.rpc = utils.objects.mergeDeep({}, config.rpc, {
                modes,
            });
        }
        if (flags['api-host']) {
            config.rpc = utils.objects.mergeDeep({}, config.rpc, {
                host: flags['api-host'],
            });
        }
        if (flags['api-port']) {
            config.rpc = utils.objects.mergeDeep({}, config.rpc, {
                port: flags['api-port'],
            });
        }
        if (flags.log) {
            config.system.logLevel = flags.log;
        }
        if (flags.port) {
            config.network = (_a = config.network) !== null && _a !== void 0 ? _a : {};
            config.network.port = flags.port;
        }
        if (flags['seed-peers']) {
            config.network = (_b = config.network) !== null && _b !== void 0 ? _b : {};
            config.network.seedPeers = [];
            const peers = flags['seed-peers'].split(',');
            for (const seed of peers) {
                const [ip, port] = seed.split(':');
                if (!ip || !port || Number.isNaN(Number(port))) {
                    this.error('Invalid seed-peers, ip or port is invalid or not specified.');
                }
                config.network.seedPeers.push({ ip, port: Number(port) });
            }
        }
        try {
            const app = await this.getApplication(config);
            await app.run();
        }
        catch (errors) {
            this.error(Array.isArray(errors)
                ? errors.map(err => err.message).join(',')
                : errors);
        }
    }
}
StartCommand.description = 'Start Blockchain Node.';
StartCommand.examples = [
    'start',
    'start --network devnet --data-path /path/to/data-dir --log debug',
    'start --network devnet --api-ws',
    'start --network devnet --api-ws --api-port 8888',
    'start --network devnet --port 9000',
    'start --network devnet --port 9002 --seed-peers 127.0.0.1:9001,127.0.0.1:9000',
    'start --network testnet --overwrite-config',
    'start --network testnet --config ~/my_custom_config.json',
];
StartCommand.flags = {
    'data-path': flags_1.flagsWithParser.dataPath,
    network: flags_1.flagsWithParser.network,
    config: flags_1.flagsWithParser.config,
    'overwrite-config': core_1.Flags.boolean({
        description: 'Overwrite network configs if they exist already',
        default: false,
    }),
    port: core_1.Flags.integer({
        char: 'p',
        description: 'Open port for the peer to peer incoming connections. Environment variable "KLAYR_PORT" can also be used.',
        env: 'KLAYR_PORT',
    }),
    'api-ipc': core_1.Flags.boolean({
        description: 'Enable IPC communication. This will load plugins as a child process and communicate over IPC. Environment variable "KLAYR_API_IPC" can also be used.',
        env: 'KLAYR_API_IPC',
        default: false,
    }),
    'api-ws': core_1.Flags.boolean({
        description: 'Enable websocket communication for api-client. Environment variable "KLAYR_API_WS" can also be used.',
        env: 'KLAYR_API_WS',
        default: false,
    }),
    'api-http': core_1.Flags.boolean({
        description: 'Enable HTTP communication for api-client. Environment variable "KLAYR_API_HTTP" can also be used.',
        env: 'KLAYR_API_HTTP',
        default: false,
    }),
    'api-port': core_1.Flags.integer({
        description: 'Port to be used for api-client. Environment variable "KLAYR_API_PORT" can also be used.',
        env: 'KLAYR_API_WS_PORT',
    }),
    'api-host': core_1.Flags.string({
        description: 'Host to be used for api-client. Environment variable "KLAYR_API_HOST" can also be used.',
        env: 'KLAYR_API_HOST',
    }),
    log: core_1.Flags.string({
        char: 'l',
        description: 'Log level. Environment variable "KLAYR_LOG_LEVEL" can also be used.',
        env: 'KLAYR_LOG_LEVEL',
        options: LOG_OPTIONS,
    }),
    'seed-peers': core_1.Flags.string({
        env: 'KLAYR_SEED_PEERS',
        description: 'Seed peers to initially connect to in format of comma separated "ip:port". IP can be DNS name or IPV4 format. Environment variable "KLAYR_SEED_PEERS" can also be used.',
    }),
};
exports.StartCommand = StartCommand;
//# sourceMappingURL=start.js.map