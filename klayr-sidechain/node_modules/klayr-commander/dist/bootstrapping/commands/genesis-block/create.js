"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseGenesisBlockCommand = void 0;
const utils_1 = require("@klayr/utils");
const core_1 = require("@oclif/core");
const fs = require("fs-extra");
const path_1 = require("path");
const validator_1 = require("@klayr/validator");
const codec_1 = require("@klayr/codec");
const os_1 = require("os");
const genesis_creation_1 = require("../../../utils/genesis_creation");
const flags_1 = require("../../../utils/flags");
const path_2 = require("../../../utils/path");
const constants_1 = require("../../../constants");
class BaseGenesisBlockCommand extends core_1.Command {
    async run() {
        const { flags: { output, config: configFilePath, network, 'assets-file': assetsFile, height, timestamp, 'previous-block-id': previousBlockIDString, 'export-json': exportJSON, }, } = await this.parse(BaseGenesisBlockCommand);
        const regexWhitespace = /\s/g;
        const regexCamelCase = /^([a-z]+)(([A-Z]([a-z]+))+)$/;
        if (regexCamelCase.test(output) || regexWhitespace.test(output)) {
            this.error('Invalid name');
        }
        const { configFilePath: defaultConfigFilepath } = (0, path_2.getNetworkConfigFilesPath)(this.getApplicationConfigDir(), network, true);
        let config = await fs.readJSON(defaultConfigFilepath);
        if (configFilePath) {
            const customConfig = await fs.readJSON((0, path_1.resolve)(configFilePath));
            config = utils_1.objects.mergeDeep(config, customConfig);
        }
        let configPath = output;
        if (output.includes('~')) {
            configPath = configPath.replace('~', (0, os_1.homedir)());
        }
        else if (!(0, path_1.isAbsolute)(output)) {
            configPath = (0, path_1.join)(process.cwd(), output);
        }
        const app = this.getApplication(config);
        const assetsJSON = (await fs.readJSON((0, path_1.resolve)(assetsFile)));
        validator_1.validator.validate(genesis_creation_1.genesisAssetsSchema, assetsJSON);
        const genesisBlock = await app.generateGenesisBlock({
            assets: assetsJSON.assets.map(a => ({
                module: a.module,
                data: codec_1.codec.fromJSON(a.schema, a.data),
                schema: a.schema,
            })),
            chainID: Buffer.from(app.config.genesis.chainID, 'hex'),
            height,
            timestamp,
            previousBlockID: previousBlockIDString
                ? Buffer.from(previousBlockIDString, 'hex')
                : undefined,
        });
        fs.mkdirSync(configPath, { recursive: true });
        fs.writeFileSync((0, path_1.resolve)(configPath, 'genesis_block.blob'), genesisBlock.getBytes(), {
            mode: constants_1.OWNER_READ_WRITE,
        });
        if (exportJSON) {
            fs.writeFileSync((0, path_1.resolve)(configPath, 'genesis_block.json'), JSON.stringify(genesisBlock.toJSON(), undefined, '  '), {
                mode: constants_1.OWNER_READ_WRITE,
            });
        }
        this.log(`Genesis block files saved at: ${configPath}`);
    }
}
BaseGenesisBlockCommand.description = 'Creates genesis block file.';
BaseGenesisBlockCommand.examples = [
    'genesis-block:create --output mydir',
    'genesis-block:create --output mydir --assets-file ./assets.json',
    'genesis-block:create --output mydir --assets-file ./assets.json --height 2 --timestamp 1592924699 --previous-block-id 085d7c9b7bddc8052be9eefe185f407682a495f1b4498677df1480026b74f2e9',
];
BaseGenesisBlockCommand.flags = {
    network: flags_1.flagsWithParser.network,
    config: flags_1.flagsWithParser.config,
    output: core_1.Flags.string({
        char: 'o',
        description: 'Output folder path of the generated genesis block',
        default: 'config',
    }),
    'assets-file': core_1.Flags.string({
        char: 'f',
        description: 'Path to file which contains genesis block asset in JSON format',
        required: true,
    }),
    'export-json': core_1.Flags.boolean({
        description: 'Export genesis block as JSON format along with blob',
        default: false,
    }),
    height: core_1.Flags.integer({
        char: 'h',
        description: 'Genesis block height',
        required: false,
    }),
    timestamp: core_1.Flags.integer({
        char: 't',
        description: 'Timestamp',
        required: false,
    }),
    'previous-block-id': core_1.Flags.string({
        char: 'p',
        description: 'Previous block id',
        required: false,
    }),
};
exports.BaseGenesisBlockCommand = BaseGenesisBlockCommand;
//# sourceMappingURL=create.js.map