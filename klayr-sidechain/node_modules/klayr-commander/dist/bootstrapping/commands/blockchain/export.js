"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExportCommand = void 0;
const core_1 = require("@oclif/core");
const fs = require("fs-extra");
const path_1 = require("path");
const tar = require("tar");
const flags_1 = require("../../../utils/flags");
const path_2 = require("../../../utils/path");
class ExportCommand extends core_1.Command {
    async run() {
        const { flags } = await this.parse(ExportCommand);
        const dataPath = flags['data-path']
            ? flags['data-path']
            : (0, path_2.getDefaultPath)(this.config.pjson.name);
        const inputPath = (0, path_1.join)(dataPath, 'data');
        const exportPath = flags.output ? flags.output : process.cwd();
        fs.ensureDirSync(exportPath);
        this.log('Exporting blockchain:');
        this.log(`   ${(0, path_2.getFullPath)(inputPath)}`);
        const filePath = (0, path_1.join)(exportPath, 'blockchain.tar.gz');
        await tar.create({
            gzip: true,
            file: filePath,
            cwd: inputPath,
        }, ['state.db', 'blockchain.db']);
        this.log('Export completed:');
        this.log(`   ${filePath}`);
    }
}
ExportCommand.description = 'Export to <FILE>.';
ExportCommand.examples = [
    'blockchain:export',
    'blockchain:export --data-path ./data --output ./my/path/',
];
ExportCommand.flags = {
    'data-path': flags_1.flagsWithParser.dataPath,
    output: flags_1.flagsWithParser.output,
};
exports.ExportCommand = ExportCommand;
//# sourceMappingURL=export.js.map