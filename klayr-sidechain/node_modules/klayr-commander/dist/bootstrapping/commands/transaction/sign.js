"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignCommand = void 0;
const core_1 = require("@oclif/core");
const klayr_framework_1 = require("klayr-framework");
const transactions = require("@klayr/transactions");
const chain_1 = require("@klayr/chain");
const codec_1 = require("@klayr/codec");
const flags_1 = require("../../../utils/flags");
const reader_1 = require("../../../utils/reader");
const transaction_1 = require("../../../utils/transaction");
const path_1 = require("../../../utils/path");
const config_1 = require("../../../utils/config");
const commons_1 = require("../../../utils/commons");
const signTransaction = async (flags, registeredSchema, metadata, transactionHexStr, chainID, keys) => {
    var _a;
    const decodedTransaction = (0, transaction_1.decodeTransaction)(registeredSchema, metadata, transactionHexStr);
    const paramsSchema = (0, transaction_1.getParamsSchema)(metadata, decodedTransaction.module, decodedTransaction.command);
    const unsignedTransaction = {
        ...codec_1.codec.fromJSON(registeredSchema.transaction, decodedTransaction),
        params: paramsSchema ? codec_1.codec.fromJSON(paramsSchema, decodedTransaction.params) : {},
    };
    const chainIDBuffer = Buffer.from(chainID, 'hex');
    const passphrase = (_a = flags.passphrase) !== null && _a !== void 0 ? _a : (await (0, reader_1.getPassphraseFromPrompt)('passphrase'));
    const edKeys = await (0, commons_1.deriveKeypair)(passphrase, flags['key-derivation-path']);
    let signedTransaction;
    if (flags['mandatory-keys'] || flags['optional-keys']) {
        signedTransaction = transactions.signMultiSignatureTransaction(unsignedTransaction, chainIDBuffer, edKeys.privateKey, keys, paramsSchema);
    }
    else {
        signedTransaction = transactions.signTransaction(unsignedTransaction, chainIDBuffer, edKeys.privateKey, paramsSchema);
    }
    return {
        ...codec_1.codec.toJSON(registeredSchema.transaction, signedTransaction),
        params: decodedTransaction.params,
        id: signedTransaction.id.toString('hex'),
    };
};
const signTransactionOffline = async (flags, registeredSchema, metadata, transactionHexStr) => {
    const mandatoryKeys = flags['mandatory-keys'];
    const optionalKeys = flags['optional-keys'];
    const keys = {
        mandatoryKeys: mandatoryKeys ? mandatoryKeys.map(k => Buffer.from(k, 'hex')) : [],
        optionalKeys: optionalKeys ? optionalKeys.map(k => Buffer.from(k, 'hex')) : [],
    };
    const signedTransaction = await signTransaction(flags, registeredSchema, metadata, transactionHexStr, flags['chain-id'], keys);
    return signedTransaction;
};
const signTransactionOnline = async (flags, client, registeredSchema, metadata, transactionHexStr) => {
    var _a;
    const transactionObject = (0, transaction_1.decodeTransaction)(registeredSchema, metadata, transactionHexStr);
    const passphrase = (_a = flags.passphrase) !== null && _a !== void 0 ? _a : (await (0, reader_1.getPassphraseFromPrompt)('passphrase'));
    const edKeys = await (0, commons_1.deriveKeypair)(passphrase, flags['key-derivation-path']);
    const signedTransaction = await client.transaction.sign(transactionObject, [
        edKeys.privateKey.toString('hex'),
    ]);
    return signedTransaction;
};
class SignCommand extends core_1.Command {
    async run() {
        var _a;
        const { args, flags } = await this.parse(SignCommand);
        this._dataPath = (_a = flags['data-path']) !== null && _a !== void 0 ? _a : (0, path_1.getDefaultPath)(this.config.pjson.name);
        let signedTransaction;
        if (flags.offline) {
            const app = this.getApplication({ genesis: { chainID: flags['chain-id'] } });
            this._metadata = app.getMetadata();
            this._schema = {
                header: klayr_framework_1.blockHeaderSchema,
                transaction: klayr_framework_1.transactionSchema,
                block: klayr_framework_1.blockSchema,
                asset: chain_1.blockAssetSchema,
                event: chain_1.eventSchema,
            };
            signedTransaction = await signTransactionOffline(flags, this._schema, this._metadata, args.transaction);
        }
        else {
            this._client = await (0, transaction_1.getApiClient)(this._dataPath, this.config.pjson.name);
            this._schema = this._client.schema;
            this._metadata = this._client.metadata;
            signedTransaction = await signTransactionOnline(flags, this._client, this._schema, this._metadata, args.transaction);
        }
        this.printJSON(flags.pretty, {
            transaction: (0, transaction_1.encodeTransactionJSON)(this._schema, this._metadata, signedTransaction, this._client).toString('hex'),
        });
        if (flags.json) {
            this.printJSON(flags.pretty, {
                transaction: signedTransaction,
            });
        }
    }
    printJSON(pretty, message) {
        if (pretty) {
            this.log(JSON.stringify(message, undefined, '  '));
        }
        else {
            this.log(JSON.stringify(message));
        }
    }
    async finally(error) {
        if (error) {
            this.error(error instanceof Error ? error.message : error);
        }
        if (this._client) {
            await this._client.disconnect();
        }
    }
}
SignCommand.description = 'Sign encoded transaction.';
SignCommand.args = [
    {
        name: 'transaction',
        required: true,
        description: 'The transaction to be signed encoded as hex string',
    },
];
SignCommand.flags = {
    passphrase: flags_1.flagsWithParser.passphrase,
    json: flags_1.flagsWithParser.json,
    offline: {
        ...flags_1.flagsWithParser.offline,
        dependsOn: ['chain-id'],
        exclusive: ['data-path'],
    },
    'mandatory-keys': core_1.Flags.string({
        multiple: true,
        description: 'Mandatory publicKey string in hex format.',
    }),
    'optional-keys': core_1.Flags.string({
        multiple: true,
        description: 'Optional publicKey string in hex format.',
    }),
    'chain-id': flags_1.flagsWithParser.chainID,
    'data-path': flags_1.flagsWithParser.dataPath,
    'key-derivation-path': core_1.Flags.string({
        default: config_1.DEFAULT_KEY_DERIVATION_PATH,
        description: 'Key derivation path to use to derive keypair from passphrase',
        char: 'k',
    }),
    pretty: flags_1.flagsWithParser.pretty,
};
SignCommand.examples = [
    'transaction:sign <hex-encoded-binary-transaction>',
    'transaction:sign <hex-encoded-binary-transaction> --network testnet',
];
exports.SignCommand = SignCommand;
//# sourceMappingURL=sign.js.map