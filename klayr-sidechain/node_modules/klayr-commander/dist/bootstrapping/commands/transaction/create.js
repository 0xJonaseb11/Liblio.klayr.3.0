"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateCommand = void 0;
const chain_1 = require("@klayr/chain");
const codec_1 = require("@klayr/codec");
const cryptography = require("@klayr/cryptography");
const transactions = require("@klayr/transactions");
const validator_1 = require("@klayr/validator");
const core_1 = require("@oclif/core");
const klayr_framework_1 = require("klayr-framework");
const commons_1 = require("../../../utils/commons");
const config_1 = require("../../../utils/config");
const flags_1 = require("../../../utils/flags");
const path_1 = require("../../../utils/path");
const reader_1 = require("../../../utils/reader");
const transaction_1 = require("../../../utils/transaction");
const send_1 = require("./send");
const getParamsObject = async (metadata, flags, args) => {
    let params;
    const paramsSchema = (0, transaction_1.getParamsSchema)(metadata, args.module, args.command);
    if (!paramsSchema) {
        return {};
    }
    if (flags.file) {
        params = JSON.parse((0, reader_1.getFileParams)(flags.file));
    }
    else {
        params = flags.params ? JSON.parse(flags.params) : await (0, reader_1.getParamsFromPrompt)(paramsSchema);
    }
    return params;
};
const getKeysFromFlags = async (flags) => {
    var _a;
    let publicKey;
    let privateKey;
    let address;
    if (flags['no-signature']) {
        publicKey = Buffer.from(flags['sender-public-key'], 'hex');
        address = cryptography.address.getAddressFromPublicKey(publicKey);
    }
    else {
        const passphrase = (_a = flags.passphrase) !== null && _a !== void 0 ? _a : (await (0, reader_1.getPassphraseFromPrompt)('passphrase'));
        const keys = await (0, commons_1.deriveKeypair)(passphrase, flags['key-derivation-path']);
        publicKey = keys.publicKey;
        privateKey = keys.privateKey;
        address = cryptography.address.getAddressFromPublicKey(publicKey);
    }
    return { address, publicKey, privateKey };
};
const validateAndSignTransaction = (transaction, schema, metadata, chainID, privateKey, noSignature) => {
    const { params, ...transactionWithoutParams } = transaction;
    const paramsSchema = (0, transaction_1.getParamsSchema)(metadata, transaction.module, transaction.command);
    const txObject = codec_1.codec.fromJSON(schema.transaction, { ...transactionWithoutParams, params: '' });
    validator_1.validator.validate(schema.transaction, txObject);
    const paramsObject = paramsSchema ? codec_1.codec.fromJSON(paramsSchema, params) : {};
    const decodedTx = {
        ...txObject,
        params: paramsObject,
    };
    if (!noSignature) {
        return transactions.signTransaction(decodedTx, Buffer.from(chainID, 'hex'), privateKey, paramsSchema);
    }
    return decodedTx;
};
const createTransactionOffline = async (args, flags, registeredSchema, metadata, transaction) => {
    var _a;
    const params = await getParamsObject(metadata, flags, args);
    const { publicKey, privateKey } = await getKeysFromFlags(flags);
    transaction.nonce = (_a = flags.nonce) !== null && _a !== void 0 ? _a : '0';
    transaction.params = params;
    transaction.senderPublicKey = publicKey.toString('hex');
    return validateAndSignTransaction(transaction, registeredSchema, metadata, flags['chain-id'], privateKey, flags['no-signature']);
};
const createTransactionOnline = async (args, flags, client, registeredSchema, metadata, transaction) => {
    const nodeInfo = await client.node.getNodeInfo();
    const { address, privateKey, publicKey } = await getKeysFromFlags(flags);
    const account = await client.invoke('auth_getAuthAccount', {
        address: cryptography.address.getKlayr32AddressFromAddress(address),
    });
    const params = await getParamsObject(metadata, flags, args);
    if (flags['chain-id'] && flags['chain-id'] !== nodeInfo.chainID) {
        throw new Error(`Invalid chainID specified, actual: ${flags['chain-id']}, expected: ${nodeInfo.chainID}.`);
    }
    if (flags.nonce && BigInt(account.nonce) > BigInt(flags.nonce)) {
        throw new Error(`Invalid nonce specified, actual: ${flags.nonce}, expected: ${account.nonce.toString()}`);
    }
    transaction.nonce = flags.nonce ? flags.nonce : account.nonce;
    transaction.params = params;
    transaction.senderPublicKey = publicKey.toString('hex');
    return validateAndSignTransaction(transaction, registeredSchema, metadata, nodeInfo.chainID, privateKey, flags['no-signature']);
};
class CreateCommand extends core_1.Command {
    async run() {
        var _a;
        const { args, flags } = await this.parse(CreateCommand);
        const incompleteTransaction = {
            module: args.module,
            command: args.command,
            fee: args.fee,
            nonce: '0',
            senderPublicKey: '',
            params: {},
            signatures: [],
        };
        let transactionObject;
        this._dataPath = (_a = flags['data-path']) !== null && _a !== void 0 ? _a : (0, path_1.getDefaultPath)(this.config.pjson.name);
        if (flags.offline) {
            const app = this.getApplication({
                genesis: {
                    chainID: flags['chain-id'],
                },
            });
            this._metadata = app.getMetadata();
            this._schema = {
                header: klayr_framework_1.blockHeaderSchema,
                transaction: klayr_framework_1.transactionSchema,
                block: klayr_framework_1.blockSchema,
                asset: chain_1.blockAssetSchema,
                event: chain_1.eventSchema,
            };
            transactionObject = await createTransactionOffline(args, flags, this._schema, this._metadata, incompleteTransaction);
        }
        else {
            this._client = await (0, transaction_1.getApiClient)(this._dataPath, this.config.pjson.name);
            this._schema = this._client.schema;
            transactionObject = await createTransactionOnline(args, flags, this._client, this._schema, this._client.metadata, incompleteTransaction);
        }
        const encodedTransaction = (0, transaction_1.encodeTransaction)(this._schema, this._metadata, transactionObject, this._client).toString('hex');
        this.printJSON(flags.pretty, {
            transaction: encodedTransaction,
        });
        if (flags.json) {
            this.printJSON(flags.pretty, {
                transaction: (0, transaction_1.transactionToJSON)(this._schema, this._metadata, transactionObject, this._client),
            });
        }
        if (flags.send) {
            await send_1.SendCommand.run([encodedTransaction, `--data-path=${this._dataPath}`], this.config);
        }
    }
    printJSON(pretty, message) {
        if (pretty) {
            this.log(JSON.stringify(message, undefined, '  '));
        }
        else {
            this.log(JSON.stringify(message));
        }
    }
    async finally() {
        if (this._client) {
            await this._client.disconnect();
        }
    }
}
CreateCommand.strict = false;
CreateCommand.description = 'Create transaction which can be broadcasted to the network. Note: fee and amount should be in Beddows!!';
CreateCommand.args = [
    {
        name: 'module',
        required: true,
        description: 'Registered transaction module.',
    },
    {
        name: 'command',
        required: true,
        description: 'Registered transaction command.',
    },
    {
        name: 'fee',
        required: true,
        description: 'Transaction fee in Beddows.',
    },
];
CreateCommand.examples = [
    'transaction:create token transfer 100000000 --params=\'{"amount":100000000,"tokenID":"0400000000000000","recipientAddress":"klyycz7hvr8yfu74bcwxy2n4mopfmjancgdvxq8xz","data":"send token"}\'',
    'transaction:create token transfer 100000000 --params=\'{"amount":100000000,"tokenID":"0400000000000000","recipientAddress":"klyycz7hvr8yfu74bcwxy2n4mopfmjancgdvxq8xz","data":"send token"}\' --json',
    'transaction:create token transfer 100000000 --offline --network mainnet --chain-id 10000000 --nonce 1 --params=\'{"amount":100000000,"tokenID":"0400000000000000","recipientAddress":"klyycz7hvr8yfu74bcwxy2n4mopfmjancgdvxq8xz","data":"send token"}\'',
    'transaction:create token transfer 100000000 --file=/txn_params.json',
    'transaction:create token transfer 100000000 --file=/txn_params.json --json',
];
CreateCommand.flags = {
    passphrase: flags_1.flagsWithParser.passphrase,
    params: core_1.Flags.string({
        char: 'a',
        description: 'Creates transaction with specific params information',
    }),
    json: flags_1.flagsWithParser.json,
    offline: core_1.Flags.boolean({
        ...flags_1.flagsWithParser.offline,
        dependsOn: ['chain-id', 'nonce'],
        exclusive: ['data-path'],
    }),
    send: core_1.Flags.boolean({
        description: 'Create and immediately send transaction to a node',
        exclusive: ['offline'],
    }),
    'no-signature': core_1.Flags.boolean({
        description: 'Creates the transaction without a signature. Your passphrase will therefore not be required',
        dependsOn: ['sender-public-key'],
    }),
    'chain-id': flags_1.flagsWithParser.chainID,
    nonce: core_1.Flags.string({
        description: 'Nonce of the transaction.',
    }),
    'sender-public-key': flags_1.flagsWithParser.senderPublicKey,
    'data-path': flags_1.flagsWithParser.dataPath,
    'key-derivation-path': core_1.Flags.string({
        default: config_1.DEFAULT_KEY_DERIVATION_PATH,
        description: 'Key derivation path to use to derive keypair from passphrase',
        char: 'k',
    }),
    pretty: flags_1.flagsWithParser.pretty,
    file: flags_1.flagsWithParser.file,
};
exports.CreateCommand = CreateCommand;
//# sourceMappingURL=create.js.map