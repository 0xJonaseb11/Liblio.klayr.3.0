"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateCommand = void 0;
const codec_1 = require("@klayr/codec");
const cryptography_1 = require("@klayr/cryptography");
const core_1 = require("@oclif/core");
const flags_1 = require("../../../utils/flags");
const reader_1 = require("../../../utils/reader");
const constants_1 = require("../../../constants");
const output_1 = require("../../../utils/output");
class CreateCommand extends core_1.Command {
    async run() {
        const { flags: { output, passphrase: passphraseSource, 'no-encrypt': noEncrypt, password: passwordSource, count, offset, chainid, 'add-legacy': addLegacy, }, } = await this.parse(CreateCommand);
        const passphrase = passphraseSource !== null && passphraseSource !== void 0 ? passphraseSource : (await (0, reader_1.getPassphraseFromPrompt)('passphrase', true));
        let password = '';
        if (!noEncrypt) {
            password = passwordSource !== null && passwordSource !== void 0 ? passwordSource : (await (0, reader_1.getPasswordFromPrompt)('password', true));
        }
        const keys = [];
        let i = 0;
        if (addLegacy) {
            const legacyKeyPath = 'legacy';
            const { privateKey: accountPrivateKey, publicKey: accountPublicKey } = cryptography_1.legacy.getPrivateAndPublicKeyFromPassphrase(passphrase);
            const address = cryptography_1.address.getAddressFromPublicKey(accountPublicKey);
            const generatorPrivateKey = accountPrivateKey;
            const generatorPublicKey = cryptography_1.ed.getPublicKeyFromPrivateKey(generatorPrivateKey);
            const blsKeyPath = `m/12381/134/${chainid}/99999`;
            const blsPrivateKey = await cryptography_1.bls.getPrivateKeyFromPhraseAndPath(passphrase, blsKeyPath);
            const blsPublicKey = cryptography_1.bls.getPublicKeyFromPrivateKey(blsPrivateKey);
            const result = await this._createEncryptedObject({
                address,
                keyPath: legacyKeyPath,
                accountPrivateKey,
                accountPublicKey,
                generatorKeyPath: legacyKeyPath,
                generatorPrivateKey,
                generatorPublicKey,
                blsKeyPath,
                blsPrivateKey,
                blsPublicKey,
                password,
            }, noEncrypt);
            keys.push(result);
            i += 1;
        }
        for (; i < count; i += 1) {
            const accountKeyPath = `m/44'/134'/${offset + i}'`;
            const generatorKeyPath = `m/25519'/134'/${chainid}'/${offset + i}'`;
            const blsKeyPath = `m/12381/134/${chainid}/${offset + i}`;
            const accountPrivateKey = await cryptography_1.ed.getPrivateKeyFromPhraseAndPath(passphrase, accountKeyPath);
            const accountPublicKey = cryptography_1.ed.getPublicKeyFromPrivateKey(accountPrivateKey);
            const address = cryptography_1.address.getAddressFromPublicKey(accountPublicKey);
            const generatorPrivateKey = await cryptography_1.ed.getPrivateKeyFromPhraseAndPath(passphrase, generatorKeyPath);
            const generatorPublicKey = cryptography_1.ed.getPublicKeyFromPrivateKey(generatorPrivateKey);
            const blsPrivateKey = await cryptography_1.bls.getPrivateKeyFromPhraseAndPath(passphrase, blsKeyPath);
            const blsPublicKey = cryptography_1.bls.getPublicKeyFromPrivateKey(blsPrivateKey);
            const result = await this._createEncryptedObject({
                address,
                keyPath: accountKeyPath,
                accountPrivateKey,
                accountPublicKey,
                generatorKeyPath,
                generatorPrivateKey,
                generatorPublicKey,
                blsKeyPath,
                blsPrivateKey,
                blsPublicKey,
                password,
            }, noEncrypt);
            keys.push(result);
        }
        if (output) {
            const res = await (0, output_1.handleOutputFlag)(output, { keys }, 'keys');
            this.log(res);
        }
        else {
            this.log(JSON.stringify({ keys }, undefined, '  '));
        }
    }
    async _createEncryptedObject(input, noEncrypt) {
        let encryptedMessageObject = {};
        if (!noEncrypt) {
            const plainGeneratorKeyData = {
                generatorKey: input.generatorPublicKey,
                generatorPrivateKey: input.generatorPrivateKey,
                blsKey: input.blsPublicKey,
                blsPrivateKey: input.blsPrivateKey,
            };
            const encodedGeneratorKeys = codec_1.codec.encode(constants_1.plainGeneratorKeysSchema, plainGeneratorKeyData);
            encryptedMessageObject = await cryptography_1.encrypt.encryptMessageWithPassword(encodedGeneratorKeys, input.password);
        }
        return {
            address: cryptography_1.address.getKlayr32AddressFromAddress(input.address),
            keyPath: input.keyPath,
            publicKey: input.accountPublicKey.toString('hex'),
            privateKey: input.accountPrivateKey.toString('hex'),
            plain: {
                generatorKeyPath: input.generatorKeyPath,
                generatorKey: input.generatorPublicKey.toString('hex'),
                generatorPrivateKey: input.generatorPrivateKey.toString('hex'),
                blsKeyPath: input.blsKeyPath,
                blsKey: input.blsPublicKey.toString('hex'),
                blsProofOfPossession: cryptography_1.bls.popProve(input.blsPrivateKey).toString('hex'),
                blsPrivateKey: input.blsPrivateKey.toString('hex'),
            },
            encrypted: encryptedMessageObject,
        };
    }
}
CreateCommand.description = 'Return keys corresponding to the given passphrase.';
CreateCommand.examples = [
    'keys:create',
    'keys:create --passphrase your-passphrase',
    'keys:create --passphrase your-passphrase --no-encrypt',
    'keys:create --passphrase your-passphrase --password your-password',
    'keys:create --passphrase your-passphrase --password your-password --count 2',
    'keys:create --passphrase your-passphrase --no-encrypt --count 2 --offset 1',
    'keys:create --passphrase your-passphrase --no-encrypt --count 2 --offset 1 --chainid 1',
    'keys:create --passphrase your-passphrase --password your-password --count 2 --offset 1 --chainid 1 --output /mypath/keys.json',
];
CreateCommand.flags = {
    output: core_1.Flags.string({
        char: 'o',
        description: 'The output directory. Default will set to current working directory.',
    }),
    passphrase: flags_1.flagsWithParser.passphrase,
    'no-encrypt': core_1.Flags.boolean({
        char: 'n',
        description: 'No encrypted message object to be created',
        default: false,
    }),
    password: flags_1.flagsWithParser.password,
    count: core_1.Flags.integer({
        char: 'c',
        description: 'Number of keys to create',
        default: 1,
    }),
    offset: core_1.Flags.integer({
        char: 'f',
        description: 'Offset for the key derivation path',
        default: 0,
    }),
    chainid: core_1.Flags.integer({
        char: 'i',
        description: 'Chain id',
        default: 0,
    }),
    'add-legacy': core_1.Flags.boolean({
        description: 'Add legacy key derivation path to the result',
    }),
};
exports.CreateCommand = CreateCommand;
//# sourceMappingURL=create.js.map