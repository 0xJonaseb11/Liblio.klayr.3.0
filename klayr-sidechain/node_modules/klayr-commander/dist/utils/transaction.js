"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApiClient = exports.transactionToJSON = exports.encodeTransactionJSON = exports.encodeTransaction = exports.decodeTransaction = exports.getParamsSchema = void 0;
const klayrapiClient = require("@klayr/api-client");
const cryptography = require("@klayr/cryptography");
const codec_1 = require("@klayr/codec");
const path_1 = require("./path");
const application_1 = require("./application");
const getParamsSchema = (metadata, module, command) => {
    const moduleMeta = metadata.find(meta => meta.name === module);
    if (!moduleMeta) {
        throw new Error(`Module: ${module} is not registered.`);
    }
    const commandMeta = moduleMeta.commands.find(meta => meta.name === command);
    if (!commandMeta) {
        throw new Error(`Module: ${module} Command: ${command} is not registered.`);
    }
    return commandMeta.params;
};
exports.getParamsSchema = getParamsSchema;
const decodeTransaction = (schema, metadata, transactionHexStr) => {
    const transactionBytes = Buffer.from(transactionHexStr, 'hex');
    const id = cryptography.utils.hash(transactionBytes);
    const transaction = codec_1.codec.decodeJSON(schema.transaction, transactionBytes);
    const paramsSchema = (0, exports.getParamsSchema)(metadata, transaction.module, transaction.command);
    const params = codec_1.codec.decodeJSON(paramsSchema, Buffer.from(transaction.params, 'hex'));
    return {
        ...transaction,
        params,
        id: id.toString('hex'),
    };
};
exports.decodeTransaction = decodeTransaction;
const encodeTransaction = (schema, metadata, transaction, apiClient) => {
    if (apiClient) {
        return apiClient.transaction.encode(transaction);
    }
    const paramsSchema = (0, exports.getParamsSchema)(metadata, transaction.module, transaction.command);
    const paramsBytes = codec_1.codec.encode(paramsSchema, transaction.params);
    const txBytes = codec_1.codec.encode(schema.transaction, { ...transaction, params: paramsBytes });
    return txBytes;
};
exports.encodeTransaction = encodeTransaction;
const encodeTransactionJSON = (schema, metadata, transaction, apiClient) => {
    if (apiClient) {
        return apiClient.transaction.encode(apiClient.transaction.fromJSON(transaction));
    }
    const paramsSchema = (0, exports.getParamsSchema)(metadata, transaction.module, transaction.command);
    const paramsBytes = codec_1.codec.encodeJSON(paramsSchema, transaction.params);
    const txBytes = codec_1.codec.encodeJSON(schema.transaction, {
        ...transaction,
        params: paramsBytes.toString('hex'),
    });
    return txBytes;
};
exports.encodeTransactionJSON = encodeTransactionJSON;
const transactionToJSON = (schema, metadata, transaction, apiClient) => {
    if (apiClient) {
        return apiClient.transaction.toJSON(transaction);
    }
    const paramsSchema = (0, exports.getParamsSchema)(metadata, transaction.module, transaction.command);
    const paramsJSON = codec_1.codec.toJSON(paramsSchema, transaction.params);
    const { id, params, ...txWithoutParams } = transaction;
    const txJSON = codec_1.codec.toJSON(schema.transaction, txWithoutParams);
    return {
        ...txJSON,
        params: paramsJSON,
        id: Buffer.isBuffer(id) ? id.toString('hex') : undefined,
    };
};
exports.transactionToJSON = transactionToJSON;
const getApiClient = async (appDataPath, name) => {
    const dataPath = appDataPath !== null && appDataPath !== void 0 ? appDataPath : (0, path_1.getDefaultPath)(name);
    if (!(0, application_1.isApplicationRunning)(dataPath)) {
        throw new Error(`Application at data path ${dataPath} is not running.`);
    }
    const client = await klayrapiClient.createIPCClient(dataPath);
    return client;
};
exports.getApiClient = getApiClient;
//# sourceMappingURL=transaction.js.map