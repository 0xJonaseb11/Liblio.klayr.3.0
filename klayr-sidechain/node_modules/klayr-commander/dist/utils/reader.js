"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFileParams = exports.readParamsFile = exports.checkFileExtension = exports.getParamsFromPrompt = exports.readStdIn = exports.readFileSource = exports.isFileSource = exports.getPasswordFromPrompt = exports.getPassphraseFromPrompt = void 0;
const path = require("path");
const fs = require("fs");
const inquirer = require("inquirer");
const readline = require("readline");
const error_1 = require("./error");
const capitalise = (text) => `${text.charAt(0).toUpperCase()}${text.slice(1)}`;
const getPromptVerificationFailError = (displayName) => `${capitalise(displayName)} was not successfully repeated.`;
const splitSource = (source) => {
    const delimiter = ':';
    const sourceParts = source.split(delimiter);
    return {
        sourceType: sourceParts[0],
        sourceIdentifier: sourceParts.slice(1).join(delimiter),
    };
};
const getPassphraseFromPrompt = async (displayName = 'passphrase', shouldConfirm = false) => {
    const questions = [
        {
            type: 'password',
            name: 'passphrase',
            message: `Please enter ${displayName}: `,
        },
    ];
    if (shouldConfirm) {
        questions.push({
            type: 'password',
            name: 'passphraseRepeat',
            message: `Please re-enter ${displayName}: `,
        });
    }
    const { passphrase, passphraseRepeat } = await inquirer.prompt(questions);
    if (!passphrase || (shouldConfirm && passphrase !== passphraseRepeat)) {
        throw new error_1.ValidationError(getPromptVerificationFailError(displayName));
    }
    return passphrase;
};
exports.getPassphraseFromPrompt = getPassphraseFromPrompt;
const getPasswordFromPrompt = async (displayName = 'password', shouldConfirm = false) => {
    const questions = [
        {
            type: 'password',
            name: 'password',
            message: `Please enter ${displayName}: `,
        },
    ];
    if (shouldConfirm) {
        questions.push({
            type: 'password',
            name: 'passwordRepeat',
            message: `Please re-enter ${displayName}: `,
        });
    }
    const { password, passwordRepeat } = await inquirer.prompt(questions);
    if (!password || (shouldConfirm && password !== passwordRepeat)) {
        throw new error_1.ValidationError(getPromptVerificationFailError(displayName));
    }
    return password;
};
exports.getPasswordFromPrompt = getPasswordFromPrompt;
const getFileDoesNotExistError = (filePath) => `File at ${filePath} does not exist.`;
const getFileUnreadableError = (filePath) => `File at ${filePath} could not be read.`;
const getDataFromFile = (filePath) => fs.readFileSync(filePath, 'utf8');
const ERROR_DATA_MISSING = 'No data was provided.';
const ERROR_DATA_SOURCE = 'Unknown data source type.';
const INVALID_JSON_FILE = 'Not a JSON file.';
const FILE_NOT_FOUND = 'No such file or directory.';
const isFileSource = (source) => {
    if (!source) {
        return false;
    }
    const delimiter = ':';
    const sourceParts = source.split(delimiter);
    if (sourceParts.length === 2 && sourceParts[0] === 'file') {
        return true;
    }
    return false;
};
exports.isFileSource = isFileSource;
const readFileSource = async (source) => {
    if (!source) {
        throw new error_1.ValidationError(ERROR_DATA_MISSING);
    }
    const { sourceType, sourceIdentifier: filePath } = splitSource(source);
    if (sourceType !== 'file') {
        throw new error_1.ValidationError(ERROR_DATA_SOURCE);
    }
    try {
        return getDataFromFile(filePath);
    }
    catch (error) {
        const { message } = error;
        if (message.match(/ENOENT/)) {
            throw new error_1.FileSystemError(getFileDoesNotExistError(filePath));
        }
        if (message.match(/EACCES/)) {
            throw new error_1.FileSystemError(getFileUnreadableError(filePath));
        }
        throw error;
    }
};
exports.readFileSource = readFileSource;
const DEFAULT_TIMEOUT = 100;
const readStdIn = async () => {
    const readFromStd = new Promise((resolve, reject) => {
        const lines = [];
        const rl = readline.createInterface({ input: process.stdin });
        setTimeout(() => {
            reject(new Error(`Timed out after ${DEFAULT_TIMEOUT} ms`));
        }, DEFAULT_TIMEOUT);
        const handleClose = () => {
            resolve(lines);
        };
        return rl.on('line', line => lines.push(line)).on('close', handleClose);
    });
    return readFromStd;
};
exports.readStdIn = readStdIn;
const castValue = (val, schemaType) => {
    if (schemaType === 'uint64' || schemaType === 'sint64') {
        return BigInt(val);
    }
    if (schemaType === 'uint32' || schemaType === 'sint32') {
        return Number(val);
    }
    return val;
};
const castArray = (items, schemaType) => {
    if (schemaType === 'uint64' || schemaType === 'sint64') {
        return items.map(i => BigInt(i));
    }
    if (schemaType === 'uint32' || schemaType === 'sint32') {
        return items.map(i => Number(i));
    }
    return items;
};
const getNestedParametersFromPrompt = async (property) => {
    let addMore = false;
    const nestedArray = [];
    const nestedProperties = Object.keys(property.items.properties);
    const nestedPropertiesCsv = nestedProperties.join(',');
    do {
        const nestedPropertiesAnswer = await inquirer.prompt({
            type: 'input',
            name: property.name,
            message: `Please enter: ${property.name}(${nestedPropertiesCsv}): `,
        });
        const properties = nestedPropertiesAnswer[property.name].split(',');
        const nestedObject = {};
        for (let i = 0; i < nestedProperties.length; i += 1) {
            const propertySchema = property.items.properties[nestedProperties[i]];
            nestedObject[nestedProperties[i]] =
                properties[i] === undefined ? '' : castValue(properties[i], propertySchema.dataType);
        }
        nestedArray.push(nestedObject);
        const confirmResponse = await inquirer.prompt({
            type: 'confirm',
            name: 'askAgain',
            message: `Want to enter another ${property.name})`,
        });
        addMore = confirmResponse.askAgain;
    } while (addMore);
    const result = {};
    result[property.name] = nestedArray;
    return result;
};
const getParamsFromPrompt = async (assetSchema) => {
    var _a, _b, _c;
    const result = {};
    for (const propertyName of Object.keys(assetSchema.properties)) {
        const property = assetSchema.properties[propertyName];
        if (property.type === 'array') {
            if (((_a = property.items) === null || _a === void 0 ? void 0 : _a.type) === 'object' && property.items.properties !== undefined) {
                const nestedResult = await getNestedParametersFromPrompt({
                    name: propertyName,
                    items: {
                        properties: property.items.properties,
                    },
                });
                result[propertyName] = nestedResult[propertyName];
            }
            else if (((_b = property.items) === null || _b === void 0 ? void 0 : _b.type) === undefined && ((_c = property.items) === null || _c === void 0 ? void 0 : _c.dataType) !== undefined) {
                const answer = await inquirer.prompt({
                    type: 'input',
                    name: propertyName,
                    message: `Please enter: ${propertyName}(comma separated values (a,b)): `,
                });
                result[propertyName] = castArray(answer[propertyName] === '' ? [] : answer[propertyName].split(','), property.items.dataType);
            }
        }
        else {
            const answer = await inquirer.prompt({
                type: 'input',
                name: propertyName,
                message: `Please enter: ${propertyName}: `,
            });
            result[propertyName] = castValue(answer[propertyName], property.dataType);
        }
    }
    return result;
};
exports.getParamsFromPrompt = getParamsFromPrompt;
const checkFileExtension = (filePath) => {
    const ext = path.extname(filePath);
    if (!ext || ext !== '.json') {
        throw new error_1.ValidationError(INVALID_JSON_FILE);
    }
};
exports.checkFileExtension = checkFileExtension;
const readParamsFile = (filePath) => {
    try {
        const params = fs.readFileSync(filePath, 'utf8');
        return params;
    }
    catch (err) {
        throw new error_1.ValidationError(FILE_NOT_FOUND);
    }
};
exports.readParamsFile = readParamsFile;
const getFileParams = (filePath) => {
    (0, exports.checkFileExtension)(filePath);
    return (0, exports.readParamsFile)(filePath);
};
exports.getFileParams = getFileParams;
//# sourceMappingURL=reader.js.map