"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateGenesisBlockDefaultPoSAssets = exports.genesisAssetsSchema = void 0;
const cryptography_1 = require("@klayr/cryptography");
const klayr_framework_1 = require("klayr-framework");
exports.genesisAssetsSchema = {
    $id: '/genesis/asset/0',
    type: 'object',
    required: ['assets'],
    properties: {
        assets: {
            type: 'array',
            items: {
                type: 'object',
                required: ['module', 'data', 'schema'],
                properties: {
                    module: {
                        type: 'string',
                    },
                    data: {
                        type: 'object',
                    },
                    schema: {
                        type: 'object',
                    },
                },
            },
        },
    },
};
const generateGenesisBlockDefaultPoSAssets = (input) => {
    const localID = Buffer.from([0, 0, 0, 0]).toString('hex');
    const tokenID = `${input.chainID}${localID}`;
    input.keysList.sort((a, b) => cryptography_1.address
        .getAddressFromKlayr32Address(a.address)
        .compare(cryptography_1.address.getAddressFromKlayr32Address(b.address)));
    const genesisAssets = [
        {
            module: new klayr_framework_1.Modules.Token.TokenModule().name,
            data: {
                userSubstore: input.keysList.map(a => ({
                    address: a.address,
                    tokenID,
                    availableBalance: input.tokenDistribution.toString(),
                    lockedBalances: [],
                })),
                supplySubstore: [
                    {
                        tokenID,
                        totalSupply: (input.tokenDistribution * BigInt(input.keysList.length)).toString(),
                    },
                ],
                escrowSubstore: [],
                supportedTokensSubstore: [],
            },
            schema: klayr_framework_1.Modules.Token.genesisTokenStoreSchema,
        },
        {
            module: new klayr_framework_1.Modules.PoS.PoSModule().name,
            data: {
                validators: input.keysList.map((v, i) => ({
                    address: v.address,
                    name: `genesis_${i}`,
                    blsKey: v.plain.blsKey,
                    proofOfPossession: v.plain.blsProofOfPossession,
                    generatorKey: v.plain.generatorKey,
                    lastGeneratedHeight: 0,
                    isBanned: false,
                    reportMisbehaviorHeights: [],
                    consecutiveMissedBlocks: 0,
                    commission: 0,
                    lastCommissionIncreaseHeight: 0,
                    sharingCoefficients: [],
                })),
                stakers: [],
                genesisData: {
                    initRounds: 3,
                    initValidators: input.keysList.slice(0, input.numberOfValidators).map(v => v.address),
                },
            },
            schema: klayr_framework_1.Modules.PoS.genesisStoreSchema,
        },
        {
            module: klayr_framework_1.Modules.Interoperability.MODULE_NAME_INTEROPERABILITY,
            data: {
                ownChainName: '',
                ownChainNonce: 0,
                chainInfos: [],
                terminatedStateAccounts: [],
                terminatedOutboxAccounts: [],
            },
            schema: klayr_framework_1.Modules.Interoperability.genesisInteroperabilitySchema,
        },
    ];
    return {
        genesisAssets,
    };
};
exports.generateGenesisBlockDefaultPoSAssets = generateGenesisBlockDefaultPoSAssets;
//# sourceMappingURL=genesis_creation.js.map