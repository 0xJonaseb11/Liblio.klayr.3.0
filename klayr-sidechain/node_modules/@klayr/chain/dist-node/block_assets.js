"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockAssets = void 0;
const validator_1 = require("@klayr/validator");
const codec_1 = require("@klayr/codec");
const tree_1 = require("@klayr/tree");
const schema_1 = require("./schema");
const constants_1 = require("./constants");
class BlockAssets {
    constructor(assets = []) {
        this._assets = [];
        this._assets = assets;
    }
    static fromBytes(values) {
        const assets = values.map(val => codec_1.codec.decode(schema_1.blockAssetSchema, val));
        const blockAssets = new BlockAssets(assets);
        return blockAssets;
    }
    static fromJSON(values) {
        const assets = values.map(val => codec_1.codec.fromJSON(schema_1.blockAssetSchema, val));
        return new BlockAssets(assets);
    }
    async getRoot() {
        this._assetRoot = await this._calculateRoot();
        return this._assetRoot;
    }
    getBytes() {
        return this._assets.map(asset => codec_1.codec.encode(schema_1.blockAssetSchema, asset));
    }
    getAsset(module) {
        var _a;
        return (_a = this._assets.find(a => a.module === module)) === null || _a === void 0 ? void 0 : _a.data;
    }
    getAll() {
        return [...this._assets];
    }
    toJSON() {
        return this._assets.map(asset => ({
            module: asset.module,
            data: asset.data.toString('hex'),
        }));
    }
    setAsset(module, value) {
        const asset = this.getAsset(module);
        if (asset) {
            throw new Error(`Module asset for "${module}" is already set.`);
        }
        this._assets.push({ module, data: value });
    }
    sort() {
        this._assets.sort((a1, a2) => a1.module.localeCompare(a2.module, 'en'));
    }
    validate() {
        let last = this._assets[0];
        let i = 0;
        for (const asset of this._assets) {
            validator_1.validator.validate(schema_1.blockAssetSchema, asset);
            if (!constants_1.NAME_REGEX.test(asset.module)) {
                throw new Error(`Invalid module name ${asset.module}`);
            }
            if (asset.data.byteLength > constants_1.MAX_ASSET_DATA_SIZE_BYTES) {
                throw new Error(`Module with ID ${asset.module} has data size more than ${constants_1.MAX_ASSET_DATA_SIZE_BYTES} bytes.`);
            }
            if (last.module > asset.module) {
                throw new Error('Assets are not sorted by the module property value in lexicographical order.');
            }
            if (i > 0 && asset.module === last.module) {
                throw new Error(`Module with ID ${this._assets[i].module} has duplicate entries.`);
            }
            i += 1;
            last = asset;
        }
    }
    validateGenesis() {
        let last = this._assets[0];
        let i = 0;
        for (const asset of this._assets) {
            validator_1.validator.validate(schema_1.blockAssetSchema, asset);
            if (last.module > asset.module) {
                throw new Error('Assets are not sorted by the module property value in lexicographical order.');
            }
            if (i > 0 && asset.module === last.module) {
                throw new Error(`Module with ID ${this._assets[i].module} has duplicate entries.`);
            }
            i += 1;
            last = asset;
        }
    }
    async _calculateRoot() {
        const merkleTree = new tree_1.MerkleTree();
        await merkleTree.init(this.getBytes());
        return merkleTree.root;
    }
}
exports.BlockAssets = BlockAssets;
//# sourceMappingURL=block_assets.js.map