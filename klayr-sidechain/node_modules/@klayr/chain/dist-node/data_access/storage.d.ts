/// <reference types="node" />
import { Database, Proof } from '@liskhq/lisk-db';
import { RawBlock, StateDiff } from '../types';
import { Event } from '../event';
import { CurrentState } from '../state_store';
export declare const encodeByteArray: (val: Buffer[]) => Buffer;
interface StorageOption {
    keepEventsForHeights?: number;
    keepInclusionProofsForHeights?: number;
}
export declare class Storage {
    private readonly _db;
    private readonly _keepEventsForHeights;
    private readonly _keepInclusionProofsForHeights;
    constructor(db: Database, options?: StorageOption);
    getBlockHeaderByID(id: Buffer): Promise<Buffer>;
    getBlockHeadersByIDs(arrayOfBlockIds: ReadonlyArray<Buffer>): Promise<Buffer[]>;
    getBlockHeaderByHeight(height: number): Promise<Buffer>;
    getBlockHeadersByHeightBetween(fromHeight: number, toHeight: number): Promise<Buffer[]>;
    getBlockHeadersWithHeights(heightList: ReadonlyArray<number>): Promise<Buffer[]>;
    getLastBlockHeader(): Promise<Buffer>;
    getBlockByID(id: Buffer): Promise<RawBlock>;
    getBlocksByIDs(arrayOfBlockIds: ReadonlyArray<Buffer>): Promise<RawBlock[]>;
    getBlockByHeight(height: number): Promise<RawBlock>;
    getBlocksByHeightBetween(fromHeight: number, toHeight: number): Promise<RawBlock[]>;
    getLastBlock(): Promise<RawBlock>;
    getEvents(height: number): Promise<Event[]>;
    setInclusionProofs(proof: Proof, height: number): Promise<void>;
    getInclusionProofs(height: number): Promise<Proof>;
    getTempBlocks(): Promise<Buffer[]>;
    isTempBlockEmpty(): Promise<boolean>;
    clearTempBlocks(): Promise<void>;
    isBlockPersisted(blockID: Buffer): Promise<boolean>;
    getTransactionByID(id: Buffer): Promise<Buffer>;
    getTransactionsByIDs(arrayOfTransactionIds: ReadonlyArray<Buffer>): Promise<Buffer[]>;
    isTransactionPersisted(transactionId: Buffer): Promise<boolean>;
    getFinalizedHeight(): Promise<number>;
    saveBlock(id: Buffer, height: number, finalizedHeight: number, header: Buffer, transactions: {
        id: Buffer;
        value: Buffer;
    }[], events: Buffer[], assets: Buffer[], state: CurrentState, removeFromTemp?: boolean): Promise<void>;
    deleteBlock(id: Buffer, height: number, txIDs: Buffer[], assets: Buffer[], fullBlock: Buffer, state: CurrentState, saveToTemp?: boolean): Promise<StateDiff>;
    private _cleanUntil;
    private _getBlockAssets;
    private _getTransactions;
    private _clear;
}
export {};
