"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataAccess = void 0;
const lisk_db_1 = require("@liskhq/lisk-db");
const transaction_1 = require("../transaction");
const block_header_1 = require("../block_header");
const block_1 = require("../block");
const cache_1 = require("./cache");
const storage_1 = require("./storage");
const block_assets_1 = require("../block_assets");
class DataAccess {
    constructor({ db, minBlockHeaderCache, maxBlockHeaderCache, keepEventsForHeights, keepInclusionProofsForHeights, }) {
        this._storage = new storage_1.Storage(db, { keepEventsForHeights, keepInclusionProofsForHeights });
        this._blocksCache = new cache_1.BlockCache(minBlockHeaderCache, maxBlockHeaderCache);
    }
    addBlockHeader(blockHeader) {
        return this._blocksCache.add(blockHeader);
    }
    async removeBlockHeader(id) {
        var _a;
        const cachedItems = this._blocksCache.remove(id);
        if (!this._blocksCache.needsRefill) {
            return cachedItems;
        }
        const upperHeightToFetch = ((_a = this._blocksCache.items[0]) === null || _a === void 0 ? void 0 : _a.height) - 1 || 0;
        const lowerHeightToFetch = Math.max(upperHeightToFetch - (this._blocksCache.maxCachedItems - this._blocksCache.minCachedItems), 1);
        if (upperHeightToFetch - lowerHeightToFetch > 0) {
            const blockHeaders = await this.getBlockHeadersByHeightBetween(lowerHeightToFetch, upperHeightToFetch);
            this._blocksCache.refill(blockHeaders.reverse());
        }
        return cachedItems;
    }
    resetBlockHeaderCache() {
        this._blocksCache.empty();
    }
    async getBlockHeaderByID(id) {
        const cachedBlock = this._blocksCache.getByID(id);
        if (cachedBlock) {
            return cachedBlock;
        }
        const blockHeaderBuffer = await this._storage.getBlockHeaderByID(id);
        return block_header_1.BlockHeader.fromBytes(blockHeaderBuffer);
    }
    async blockHeaderExists(id) {
        const cachedBlock = this._blocksCache.getByID(id);
        if (cachedBlock) {
            return true;
        }
        try {
            await this._storage.getBlockHeaderByID(id);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    async getBlockHeadersByIDs(arrayOfBlockIds) {
        const cachedBlocks = this._blocksCache.getByIDs(arrayOfBlockIds);
        if (cachedBlocks.length) {
            return cachedBlocks;
        }
        const blocks = await this._storage.getBlockHeadersByIDs(arrayOfBlockIds);
        return blocks.map(block => block_header_1.BlockHeader.fromBytes(block));
    }
    async getBlockHeaderByHeight(height) {
        const cachedBlock = this._blocksCache.getByHeight(height);
        if (cachedBlock) {
            return cachedBlock;
        }
        const header = await this._storage.getBlockHeaderByHeight(height);
        return block_header_1.BlockHeader.fromBytes(header);
    }
    async getBlockHeadersByHeightBetween(fromHeight, toHeight) {
        const cachedBlocks = this._blocksCache.getByHeightBetween(fromHeight, toHeight);
        if (cachedBlocks.length) {
            return cachedBlocks;
        }
        const blocks = await this._storage.getBlockHeadersByHeightBetween(fromHeight, toHeight);
        return blocks.map(block => block_header_1.BlockHeader.fromBytes(block));
    }
    async getBlockHeadersWithHeights(heightList) {
        const cachedBlocks = this._blocksCache.getByHeights(heightList);
        if (cachedBlocks.length) {
            return cachedBlocks;
        }
        const blocks = await this._storage.getBlockHeadersWithHeights(heightList);
        return blocks.map(block => block_header_1.BlockHeader.fromBytes(block));
    }
    async getLastBlockHeader() {
        const cachedBlock = this._blocksCache.last;
        if (cachedBlock) {
            return cachedBlock;
        }
        const block = await this._storage.getLastBlockHeader();
        return block_header_1.BlockHeader.fromBytes(block);
    }
    async getHighestCommonBlockID(arrayOfBlockIds) {
        var _a;
        const headers = this._blocksCache.getByIDs(arrayOfBlockIds);
        headers.sort((a, b) => b.height - a.height);
        const cachedBlockHeader = headers[0];
        if (cachedBlockHeader) {
            return cachedBlockHeader.id;
        }
        const storageBlockHeaders = [];
        for (const id of arrayOfBlockIds) {
            try {
                const blockHeader = await this.getBlockHeaderByID(id);
                storageBlockHeaders.push(blockHeader);
            }
            catch (error) {
                if (!(error instanceof lisk_db_1.NotFoundError)) {
                    throw error;
                }
            }
        }
        storageBlockHeaders.sort((a, b) => b.height - a.height);
        return (_a = storageBlockHeaders[0]) === null || _a === void 0 ? void 0 : _a.id;
    }
    async getBlockByID(id) {
        const block = await this._storage.getBlockByID(id);
        return this._decodeRawBlock(block);
    }
    async getBlocksByIDs(arrayOfBlockIds) {
        const blocks = await this._storage.getBlocksByIDs(arrayOfBlockIds);
        return blocks.map(block => this._decodeRawBlock(block));
    }
    async getBlockByHeight(height) {
        const block = await this._storage.getBlockByHeight(height);
        return this._decodeRawBlock(block);
    }
    async getBlocksByHeightBetween(fromHeight, toHeight) {
        const blocks = await this._storage.getBlocksByHeightBetween(fromHeight, toHeight);
        return blocks.map(block => this._decodeRawBlock(block));
    }
    async getLastBlock() {
        const block = await this._storage.getLastBlock();
        return this._decodeRawBlock(block);
    }
    async getEvents(height) {
        const events = await this._storage.getEvents(height);
        return events;
    }
    async getInclusionProofs(height) {
        const proofs = await this._storage.getInclusionProofs(height);
        return proofs;
    }
    async setInclusionProofs(proof, height) {
        await this._storage.setInclusionProofs(proof, height);
    }
    async isBlockPersisted(blockId) {
        const isPersisted = await this._storage.isBlockPersisted(blockId);
        return isPersisted;
    }
    async getTempBlocks() {
        const blocks = await this._storage.getTempBlocks();
        return blocks.map(block => block_1.Block.fromBytes(block));
    }
    async isTempBlockEmpty() {
        const isEmpty = await this._storage.isTempBlockEmpty();
        return isEmpty;
    }
    async clearTempBlocks() {
        await this._storage.clearTempBlocks();
    }
    async getTransactionByID(id) {
        const transaction = await this._storage.getTransactionByID(id);
        return transaction_1.Transaction.fromBytes(transaction);
    }
    async getTransactionsByIDs(arrayOfTransactionIds) {
        const transactions = await this._storage.getTransactionsByIDs(arrayOfTransactionIds);
        return transactions.map(transaction => transaction_1.Transaction.fromBytes(transaction));
    }
    async isTransactionPersisted(transactionId) {
        const isPersisted = await this._storage.isTransactionPersisted(transactionId);
        return isPersisted;
    }
    async getFinalizedHeight() {
        return this._storage.getFinalizedHeight();
    }
    async saveBlock(block, events, state, finalizedHeight, removeFromTemp = false) {
        const { id: blockID, height } = block.header;
        const encodedHeader = block.header.getBytes();
        const encodedTransactions = [];
        for (const tx of block.transactions) {
            const txID = tx.id;
            const encodedTx = tx.getBytes();
            encodedTransactions.push({ id: txID, value: encodedTx });
        }
        const encodedEvents = events.map(e => e.getBytes());
        await this._storage.saveBlock(blockID, height, finalizedHeight, encodedHeader, encodedTransactions, encodedEvents, block.assets.getBytes(), state, removeFromTemp);
    }
    async deleteBlock(block, state, saveToTemp = false) {
        const { id: blockID, height } = block.header;
        const txIDs = block.transactions.map(tx => tx.id);
        const encodedBlock = block.getBytes();
        await this._storage.deleteBlock(blockID, height, txIDs, block.assets.getBytes(), encodedBlock, state, saveToTemp);
    }
    _decodeRawBlock(block) {
        const header = block_header_1.BlockHeader.fromBytes(block.header);
        const transactions = block.transactions.map(txBytes => transaction_1.Transaction.fromBytes(txBytes));
        const assets = block_assets_1.BlockAssets.fromBytes(block.assets);
        return new block_1.Block(header, transactions, assets);
    }
}
exports.DataAccess = DataAccess;
//# sourceMappingURL=data_access.js.map