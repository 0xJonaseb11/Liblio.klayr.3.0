"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheDB = void 0;
const utils_1 = require("./utils");
const copyCacheValue = (value) => {
    const copiedValue = (0, utils_1.copyBuffer)(value.value);
    let copiedInit;
    if (value.init) {
        copiedInit = (0, utils_1.copyBuffer)(value.init);
    }
    return {
        init: copiedInit,
        value: copiedValue,
        dirty: value.dirty,
        deleted: value.deleted,
    };
};
class CacheDB {
    constructor() {
        this._data = {};
    }
    add(key, value) {
        const strKey = key.toString('binary');
        this._data[strKey] = {
            value,
            deleted: false,
            dirty: false,
        };
    }
    cache(key, value) {
        const strKey = key.toString('binary');
        const copiedValue = (0, utils_1.copyBuffer)(value);
        this._data[strKey] = {
            init: copiedValue,
            value,
            deleted: false,
            dirty: false,
        };
    }
    set(key, value) {
        const strKey = key.toString('binary');
        const existing = this._data[strKey];
        if (!existing) {
            throw new Error('Key must exist in the cache before calling set');
        }
        existing.dirty = true;
        existing.deleted = false;
        existing.value = value;
    }
    get(key) {
        const strKey = key.toString('binary');
        const existing = this._data[strKey];
        if (!existing) {
            return {
                value: undefined,
                deleted: false,
            };
        }
        if (existing.deleted) {
            return {
                value: undefined,
                deleted: true,
            };
        }
        return {
            value: existing.value,
            deleted: false,
        };
    }
    del(key) {
        const strKey = key.toString('binary');
        const existing = this._data[strKey];
        if (!existing) {
            return;
        }
        if (existing.init === undefined) {
            delete this._data[strKey];
            return;
        }
        existing.deleted = true;
    }
    existAny(key) {
        const strKey = key.toString('binary');
        const existing = this._data[strKey];
        return existing !== undefined;
    }
    exist(key) {
        const strKey = key.toString('binary');
        const existing = this._data[strKey];
        if (!existing) {
            return false;
        }
        if (existing.deleted) {
            return false;
        }
        return true;
    }
    getRange(start, end) {
        const result = [];
        for (const [strKey, value] of Object.entries(this._data)) {
            const key = Buffer.from(strKey, 'binary');
            if (key.compare(start) >= 0 && key.compare(end) <= 0 && !value.deleted) {
                result.push({
                    key,
                    value: value.value,
                });
            }
        }
        return result;
    }
    copy() {
        const newDB = new CacheDB();
        for (const key of Object.keys(this._data)) {
            newDB._data[key] = copyCacheValue(this._data[key]);
        }
        return newDB;
    }
    finalize(batch) {
        const diff = {
            created: [],
            deleted: [],
            updated: [],
        };
        for (const [key, value] of Object.entries(this._data)) {
            const keyBytes = Buffer.from(key, 'binary');
            if (value.init === undefined) {
                diff.created.push(keyBytes);
                batch.set(keyBytes, value.value);
                continue;
            }
            if (value.deleted) {
                diff.deleted.push({
                    key: keyBytes,
                    value: value.init,
                });
                batch.del(keyBytes);
                continue;
            }
            if (value.dirty) {
                diff.updated.push({
                    key: keyBytes,
                    value: value.init,
                });
                batch.set(keyBytes, value.value);
            }
        }
        return diff;
    }
}
exports.CacheDB = CacheDB;
//# sourceMappingURL=cache_db.js.map