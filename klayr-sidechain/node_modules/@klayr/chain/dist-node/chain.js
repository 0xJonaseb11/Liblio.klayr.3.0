"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chain = void 0;
const codec_1 = require("@klayr/codec");
const lisk_db_1 = require("@liskhq/lisk-db");
const createDebug = require("debug");
const tree_1 = require("@klayr/tree");
const constants_1 = require("./constants");
const data_access_1 = require("./data_access");
const schema_1 = require("./schema");
const debug = createDebug('klayr:chain');
class Chain {
    constructor({ maxTransactionsSize, keepEventsForHeights = constants_1.DEFAULT_KEEP_EVENTS_FOR_HEIGHTS, minBlockHeaderCache = constants_1.DEFAULT_MIN_BLOCK_HEADER_CACHE, maxBlockHeaderCache = constants_1.DEFAULT_MAX_BLOCK_HEADER_CACHE, keepInclusionProofsForHeights = constants_1.DEFAULT_KEEP_INCLUSION_PROOFS_FOR_HEIGHTS, }) {
        codec_1.codec.addSchema(schema_1.blockSchema);
        codec_1.codec.addSchema(schema_1.blockHeaderSchema);
        codec_1.codec.addSchema(schema_1.signingBlockHeaderSchema);
        codec_1.codec.addSchema(schema_1.stateDiffSchema);
        this.constants = {
            maxTransactionsSize,
            maxBlockHeaderCache,
            minBlockHeaderCache,
            keepEventsForHeights,
            keepInclusionProofsForHeights,
        };
    }
    get genesisHeight() {
        return this._genesisHeight;
    }
    get lastBlock() {
        if (this._lastBlock === undefined) {
            throw new Error('Chain has not been initialized.');
        }
        return this._lastBlock;
    }
    get finalizedHeight() {
        if (this._finalizedHeight === undefined) {
            throw new Error('Chain has not been initialized.');
        }
        return this._finalizedHeight;
    }
    get chainID() {
        return this._chainID;
    }
    init(args) {
        this._chainID = args.chainID;
        this.dataAccess = new data_access_1.DataAccess({
            db: args.db,
            minBlockHeaderCache: this.constants.minBlockHeaderCache,
            maxBlockHeaderCache: this.constants.maxBlockHeaderCache,
            keepEventsForHeights: this.constants.keepEventsForHeights,
            keepInclusionProofsForHeights: this.constants.keepInclusionProofsForHeights,
        });
    }
    async loadLastBlocks(genesisBlock) {
        let storageLastBlock;
        try {
            storageLastBlock = await this.dataAccess.getLastBlock();
        }
        catch (error) {
            throw new Error('Failed to load last block.');
        }
        if (storageLastBlock.header.height !== genesisBlock.header.height) {
            await this._cacheBlockHeaders(storageLastBlock);
        }
        this._lastBlock = storageLastBlock;
        this._genesisHeight = genesisBlock.header.height;
        this._finalizedHeight = await this.dataAccess.getFinalizedHeight();
    }
    resetBlockHeaderCache() {
        this.dataAccess.resetBlockHeaderCache();
    }
    async genesisBlockExist(genesisBlock) {
        let matchingGenesisBlock;
        try {
            matchingGenesisBlock = await this.dataAccess.getBlockHeaderByID(genesisBlock.header.id);
        }
        catch (error) {
            if (!(error instanceof lisk_db_1.NotFoundError)) {
                throw error;
            }
        }
        let lastBlockHeader;
        try {
            lastBlockHeader = await this.dataAccess.getLastBlockHeader();
        }
        catch (error) {
            if (!(error instanceof lisk_db_1.NotFoundError)) {
                throw error;
            }
        }
        if (lastBlockHeader && !matchingGenesisBlock) {
            throw new Error('Genesis block does not match.');
        }
        if (!lastBlockHeader && !matchingGenesisBlock) {
            return false;
        }
        return true;
    }
    validateBlock(block, inputs) {
        block.validate();
        if (block.header.version !== inputs.version) {
            throw new Error(`Block version must be ${inputs.version}.`);
        }
        const transactionIDs = [];
        let transactionsSize = 0;
        for (const tx of block.transactions) {
            transactionIDs.push(tx.id);
            transactionsSize += tx.getBytes().length;
        }
        if (transactionsSize > this.constants.maxTransactionsSize) {
            throw new Error(`Transactions length is longer than configured length: ${this.constants.maxTransactionsSize}.`);
        }
        const transactionRoot = tree_1.regularMerkleTree.calculateMerkleRootWithLeaves(transactionIDs);
        if (!transactionRoot.equals(block.header.transactionRoot)) {
            throw new Error('Invalid transaction root.');
        }
    }
    async saveBlock(block, events, state, finalizedHeight, { removeFromTempTable } = {
        removeFromTempTable: false,
    }) {
        await this.dataAccess.saveBlock(block, events, state, finalizedHeight, removeFromTempTable);
        this.dataAccess.addBlockHeader(block.header);
        this._finalizedHeight = finalizedHeight;
        this._lastBlock = block;
    }
    async removeBlock(block, state, { saveTempBlock } = { saveTempBlock: false }) {
        if (block.header.version === constants_1.GENESIS_BLOCK_VERSION) {
            throw new Error('Cannot delete genesis block.');
        }
        let secondLastBlock;
        try {
            secondLastBlock = await this.dataAccess.getBlockByID(block.header.previousBlockID);
        }
        catch (error) {
            throw new Error('PreviousBlock is null.');
        }
        await this.dataAccess.deleteBlock(block, state, saveTempBlock);
        await this.dataAccess.removeBlockHeader(block.header.id);
        this._lastBlock = secondLastBlock;
    }
    async _cacheBlockHeaders(storageLastBlock) {
        const fromHeight = Math.max(storageLastBlock.header.height - constants_1.DEFAULT_MAX_BLOCK_HEADER_CACHE, 0);
        const toHeight = storageLastBlock.header.height;
        debug({ h: storageLastBlock.header.height, fromHeight, toHeight }, 'Cache block headers during chain init');
        const blockHeaders = await this.dataAccess.getBlockHeadersByHeightBetween(fromHeight, toHeight);
        const sortedBlockHeaders = [...blockHeaders].sort((a, b) => a.height - b.height);
        for (const blockHeader of sortedBlockHeaders) {
            debug({ height: blockHeader.height }, 'Add block header to cache');
            this.dataAccess.addBlockHeader(blockHeader);
        }
    }
}
exports.Chain = Chain;
//# sourceMappingURL=chain.js.map