"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = exports.transactionSchema = void 0;
const codec_1 = require("@klayr/codec");
const cryptography_1 = require("@klayr/cryptography");
const validator_1 = require("@klayr/validator");
const constants_1 = require("./constants");
exports.transactionSchema = {
    $id: '/klayr/transaction',
    type: 'object',
    required: ['module', 'command', 'nonce', 'fee', 'senderPublicKey', 'params'],
    properties: {
        module: {
            dataType: 'string',
            fieldNumber: 1,
            minLength: 1,
            maxLength: 32,
        },
        command: {
            dataType: 'string',
            fieldNumber: 2,
            minLength: 1,
            maxLength: 32,
        },
        nonce: {
            dataType: 'uint64',
            fieldNumber: 3,
        },
        fee: {
            dataType: 'uint64',
            fieldNumber: 4,
        },
        senderPublicKey: {
            dataType: 'bytes',
            fieldNumber: 5,
            minLength: 32,
            maxLength: 32,
        },
        params: {
            dataType: 'bytes',
            fieldNumber: 6,
        },
        signatures: {
            type: 'array',
            items: {
                dataType: 'bytes',
            },
            fieldNumber: 7,
        },
    },
};
class Transaction {
    constructor(transaction) {
        this.module = transaction.module;
        this.command = transaction.command;
        this.params = transaction.params;
        this.nonce = transaction.nonce;
        this.fee = transaction.fee;
        this.senderPublicKey = transaction.senderPublicKey;
        this.signatures = [...transaction.signatures];
    }
    static fromBytes(bytes) {
        const tx = codec_1.codec.decode(exports.transactionSchema, bytes);
        return new Transaction(tx);
    }
    static fromJSON(value) {
        const tx = codec_1.codec.fromJSON(exports.transactionSchema, value);
        return new Transaction(tx);
    }
    get id() {
        if (!this._id) {
            this._id = cryptography_1.utils.hash(this.getBytes());
        }
        return this._id;
    }
    get senderAddress() {
        if (!this._senderAddress) {
            this._senderAddress = cryptography_1.address.getAddressFromPublicKey(this.senderPublicKey);
        }
        return this._senderAddress;
    }
    getBytes() {
        return codec_1.codec.encode(exports.transactionSchema, this);
    }
    getSigningBytes() {
        const transactionBytes = codec_1.codec.encode(exports.transactionSchema, {
            ...this,
            signatures: [],
        });
        return transactionBytes;
    }
    sign(chainID, privateKey) {
        const signature = cryptography_1.ed.signDataWithPrivateKey(constants_1.TAG_TRANSACTION, chainID, this.getSigningBytes(), privateKey);
        this.signatures.push(signature);
    }
    validate() {
        validator_1.validator.validate(exports.transactionSchema, this);
        if (!constants_1.NAME_REGEX.test(this.module)) {
            throw new Error(`Invalid module name ${this.module}`);
        }
        if (!constants_1.NAME_REGEX.test(this.command)) {
            throw new Error(`Invalid command name ${this.command}`);
        }
        if (this.params.length > constants_1.MAX_PARAMS_SIZE) {
            throw new Error(`Params exceeds max size allowed ${constants_1.MAX_PARAMS_SIZE}.`);
        }
        if (this.signatures.length === 0) {
            throw new Error('Signatures must not be empty');
        }
        for (const signature of this.signatures) {
            if (signature.length !== 0 && signature.length !== 64) {
                throw new Error('Signature must be empty or 64 bytes');
            }
        }
    }
    toJSON() {
        return { ...codec_1.codec.toJSON(exports.transactionSchema, this._getProps()), id: this.id.toString('hex') };
    }
    toObject() {
        return this._getProps();
    }
    _getProps() {
        return {
            module: this.module,
            command: this.command,
            params: this.params,
            nonce: this.nonce,
            fee: this.fee,
            senderPublicKey: this.senderPublicKey,
            signatures: this.signatures,
            id: this._id,
        };
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=transaction.js.map