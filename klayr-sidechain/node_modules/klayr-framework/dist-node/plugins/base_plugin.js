"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePlugin = exports.validatePluginSpec = exports.getPluginExportPath = void 0;
const path_1 = require("path");
const validator_1 = require("@klayr/validator");
const api_client_1 = require("@klayr/api-client");
const utils_1 = require("@klayr/utils");
const system_dirs_1 = require("../system_dirs");
const errors_1 = require("../errors");
const getPluginExportPath = (pluginInstance) => {
    let plugin;
    if (!pluginInstance.nodeModulePath) {
        return undefined;
    }
    try {
        plugin = require(pluginInstance.nodeModulePath);
    }
    catch (error) {
    }
    if (!(plugin === null || plugin === void 0 ? void 0 : plugin[pluginInstance.constructor.name])) {
        return undefined;
    }
    const Klass = plugin[pluginInstance.constructor.name];
    if (typeof Klass !== 'function' || Klass.name !== pluginInstance.constructor.name) {
        return undefined;
    }
    if (!(pluginInstance instanceof Klass)) {
        return undefined;
    }
    return pluginInstance.nodeModulePath;
};
exports.getPluginExportPath = getPluginExportPath;
const validatePluginSpec = (pluginInstance) => {
    if (!pluginInstance.name) {
        throw new errors_1.ImplementationMissingError('Plugin "name" is required.');
    }
    if (!pluginInstance.load) {
        throw new errors_1.ImplementationMissingError('Plugin "load" interface is required.');
    }
    if (!pluginInstance.unload) {
        throw new errors_1.ImplementationMissingError('Plugin "unload" interface is required.');
    }
    if (pluginInstance.configSchema) {
        validator_1.validator.validateSchema(pluginInstance.configSchema);
    }
};
exports.validatePluginSpec = validatePluginSpec;
class BasePlugin {
    get name() {
        const name = this.constructor.name.replace('Plugin', '');
        return name.charAt(0).toLowerCase() + name.substr(1);
    }
    get config() {
        return this._config;
    }
    get appConfig() {
        return this._appConfig;
    }
    get dataPath() {
        const dirs = (0, system_dirs_1.systemDirs)(this.appConfig.system.dataPath);
        return (0, path_1.join)(dirs.plugins, this.name, 'data');
    }
    get events() {
        return [];
    }
    get apiClient() {
        if (!this._apiClient) {
            throw new Error('RPC with IPC protocol must be enabled to use MethodClient.');
        }
        return this._apiClient;
    }
    async init(context) {
        var _a;
        this.logger = context.logger;
        if (this.configSchema) {
            this._config = utils_1.objects.mergeDeep({}, (_a = this.configSchema.default) !== null && _a !== void 0 ? _a : {}, context.config);
            validator_1.validator.validate(this.configSchema, this.config);
        }
        else {
            this._config = {};
        }
        this._appConfig = context.appConfig;
        if (this._appConfig.rpc.modes.includes('ipc')) {
            const dirs = (0, system_dirs_1.systemDirs)(this.appConfig.system.dataPath);
            this._apiClient = await (0, api_client_1.createIPCClient)(dirs.dataPath);
        }
    }
}
exports.BasePlugin = BasePlugin;
//# sourceMappingURL=base_plugin.js.map