"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IPCClient = void 0;
const zeromq_1 = require("zeromq");
const ipc_socket_1 = require("./ipc_socket");
const constants_1 = require("../constants");
class IPCClient extends ipc_socket_1.IPCSocket {
    constructor(options) {
        super(options);
        this._clientRPCSocketPath = options.rpcServerSocketPath;
        this.socketPaths = {
            pub: this._eventSubSocketPath,
            sub: this._eventPubSocketPath,
            rpcServer: this._rpcSeverSocketPath,
            rpcClient: this._clientRPCSocketPath,
        };
    }
    get rpcClient() {
        if (!this._rpcClient) {
            throw new Error('RPC client has not been initialized.');
        }
        return this._rpcClient;
    }
    async start() {
        await super.start();
        this.pubSocket = new zeromq_1.Publisher();
        this.subSocket = new zeromq_1.Subscriber();
        this._rpcClient = new zeromq_1.Dealer();
        try {
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('IPC Pub Socket client connection timeout. Please check if IPC server is running.'));
                }, constants_1.IPC_CONNECTION_TIMEOUT);
                this.pubSocket.events.on('bind:error', err => {
                    reject(err);
                });
                this.pubSocket.events.on('connect', () => {
                    clearTimeout(timeout);
                    resolve();
                });
                this.pubSocket.connect(this._eventSubSocketPath);
            });
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('IPC Sub Socket client connection timeout. Please check if IPC server is running.'));
                }, constants_1.IPC_CONNECTION_TIMEOUT);
                this.subSocket.events.on('bind:error', err => {
                    reject(err);
                });
                this.subSocket.events.on('connect', () => {
                    clearTimeout(timeout);
                    resolve();
                });
                this.subSocket.connect(this._eventPubSocketPath);
            });
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('IPC Sub Socket client connection timeout. Please check if IPC server is running.'));
                }, constants_1.IPC_CONNECTION_TIMEOUT);
                this.rpcClient.events.on('bind:error', err => {
                    reject(err);
                });
                this.rpcClient.events.on('connect', () => {
                    clearTimeout(timeout);
                    resolve();
                });
                this.rpcClient.connect(this._clientRPCSocketPath);
            });
        }
        catch (error) {
            this.pubSocket.close();
            this.subSocket.close();
            this.rpcClient.close();
            throw error;
        }
    }
    stop() {
        super.stop();
        this.rpcClient.close();
    }
}
exports.IPCClient = IPCClient;
//# sourceMappingURL=ipc_client.js.map