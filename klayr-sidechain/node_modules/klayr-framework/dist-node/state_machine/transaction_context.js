"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionContext = void 0;
const codec_1 = require("@klayr/codec");
const method_context_1 = require("./method_context");
const constants_1 = require("./constants");
class TransactionContext {
    constructor(params) {
        this._stateStore = params.stateStore;
        this._contextStore = params.contextStore;
        this._logger = params.logger;
        this._header = params.header;
        this._eventQueue = params.eventQueue;
        this._chainID = params.chainID;
        this._transaction = params.transaction;
        this._assets = params.assets;
    }
    createTransactionVerifyContext() {
        return {
            logger: this._logger,
            chainID: this._chainID,
            stateStore: this._stateStore,
            header: { height: this._header.height, timestamp: this._header.timestamp },
            contextStore: this._contextStore,
            getMethodContext: () => (0, method_context_1.createImmutableMethodContext)(this._stateStore),
            getStore: (moduleID, storePrefix) => this._stateStore.getStore(moduleID, storePrefix),
            transaction: this._transaction,
        };
    }
    createTransactionExecuteContext() {
        if (!this._assets) {
            throw new Error('Transaction Execution requires block assets in the context.');
        }
        const childQueue = this._eventQueue.getChildQueue(Buffer.concat([constants_1.EVENT_TOPIC_TRANSACTION_EXECUTION, this._transaction.id]));
        return {
            logger: this._logger,
            chainID: this._chainID,
            eventQueue: childQueue,
            stateStore: this._stateStore,
            contextStore: this._contextStore,
            getMethodContext: () => (0, method_context_1.createMethodContext)({
                stateStore: this._stateStore,
                eventQueue: childQueue,
                contextStore: this._contextStore,
            }),
            getStore: (moduleID, storePrefix) => this._stateStore.getStore(moduleID, storePrefix),
            header: this._header,
            transaction: this._transaction,
            assets: this._assets,
        };
    }
    createCommandVerifyContext(paramsSchema) {
        return {
            logger: this._logger,
            chainID: this._chainID,
            stateStore: this._stateStore,
            contextStore: this._contextStore,
            header: {
                height: this._header.height,
                timestamp: this._header.timestamp,
            },
            getMethodContext: () => (0, method_context_1.createMethodContext)({
                stateStore: this._stateStore,
                eventQueue: this._eventQueue,
                contextStore: this._contextStore,
            }),
            getStore: (moduleID, storePrefix) => this._stateStore.getStore(moduleID, storePrefix),
            transaction: this._transaction,
            params: (paramsSchema
                ? codec_1.codec.decode(paramsSchema, this._transaction.params)
                : undefined),
        };
    }
    createCommandExecuteContext(paramsSchema) {
        if (!this._header) {
            throw new Error('Transaction Execution requires block header in the context.');
        }
        if (!this._assets) {
            throw new Error('Transaction Execution requires block assets in the context.');
        }
        const childQueue = this._eventQueue.getChildQueue(Buffer.concat([constants_1.EVENT_TOPIC_TRANSACTION_EXECUTION, this._transaction.id]));
        return {
            logger: this._logger,
            chainID: this._chainID,
            eventQueue: childQueue,
            stateStore: this._stateStore,
            contextStore: this._contextStore,
            getMethodContext: () => (0, method_context_1.createMethodContext)({
                stateStore: this._stateStore,
                eventQueue: childQueue,
                contextStore: this._contextStore,
            }),
            getStore: (moduleID, storePrefix) => this._stateStore.getStore(moduleID, storePrefix),
            header: this._header,
            transaction: this._transaction,
            assets: this._assets,
            params: (paramsSchema
                ? codec_1.codec.decode(paramsSchema, this._transaction.params)
                : undefined),
        };
    }
    get transaction() {
        return this._transaction;
    }
    get eventQueue() {
        return this._eventQueue;
    }
    get stateStore() {
        return this._stateStore;
    }
}
exports.TransactionContext = TransactionContext;
//# sourceMappingURL=transaction_context.js.map