"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeLargestSubsetMaxBy = exports.computeBlockHeightsList = exports.restoreBlocksUponStartup = exports.deleteBlocksAfterHeight = exports.clearBlocksTempTable = exports.restoreBlocks = void 0;
const fork_choice_rule_1 = require("../fork_choice/fork_choice_rule");
const restoreBlocks = async (chainModule, processorModule) => {
    const tempBlocks = await chainModule.dataAccess.getTempBlocks();
    if (tempBlocks.length === 0) {
        return false;
    }
    for (const tempBlock of tempBlocks.reverse()) {
        await processorModule.executeValidated(tempBlock, {
            removeFromTempTable: true,
        });
    }
    return true;
};
exports.restoreBlocks = restoreBlocks;
const clearBlocksTempTable = async (chainModule) => chainModule.dataAccess.clearTempBlocks();
exports.clearBlocksTempTable = clearBlocksTempTable;
const deleteBlocksAfterHeight = async (processorModule, chainModule, logger, desiredHeight, backup = false) => {
    let { height: currentHeight } = chainModule.lastBlock.header;
    logger.debug({ desiredHeight, lastBlockHeight: currentHeight }, 'Deleting blocks after height');
    while (desiredHeight < currentHeight) {
        logger.trace({
            height: chainModule.lastBlock.header.height,
            blockId: chainModule.lastBlock.header.id,
        }, 'Deleting block and backing it up to temporary table');
        await processorModule.deleteLastBlock({
            saveTempBlock: backup,
        });
        currentHeight = chainModule.lastBlock.header.height;
    }
};
exports.deleteBlocksAfterHeight = deleteBlocksAfterHeight;
const restoreBlocksUponStartup = async (logger, chainModule, blockExecutor) => {
    const tempBlocks = await chainModule.dataAccess.getTempBlocks();
    const blockLowestHeight = tempBlocks[tempBlocks.length - 1];
    const blockHighestHeight = tempBlocks[0];
    const blockHasPriority = (0, fork_choice_rule_1.isDifferentChain)(chainModule.lastBlock.header, blockHighestHeight.header) ||
        (0, fork_choice_rule_1.isValidBlock)(chainModule.lastBlock.header, blockHighestHeight.header);
    if (blockHasPriority) {
        logger.info('Restoring blocks from temporary table');
        await (0, exports.deleteBlocksAfterHeight)(blockExecutor, chainModule, logger, blockLowestHeight.header.height - 1, false);
        await (0, exports.restoreBlocks)(chainModule, blockExecutor);
        logger.info('Chain successfully restored');
    }
    else {
        await (0, exports.clearBlocksTempTable)(chainModule);
    }
};
exports.restoreBlocksUponStartup = restoreBlocksUponStartup;
const computeBlockHeightsList = (finalizedHeight, activeValidators, listSizeLimit, currentRound) => {
    const startingHeight = Math.max((currentRound - 1) * activeValidators, 0);
    const heightList = new Array(listSizeLimit)
        .fill(0)
        .map((_, i) => startingHeight - i * activeValidators)
        .filter(height => height >= 0);
    const heightListAfterFinalized = heightList.filter(height => height > finalizedHeight);
    return heightList.length !== heightListAfterFinalized.length
        ? [...heightListAfterFinalized, finalizedHeight]
        : heightListAfterFinalized;
};
exports.computeBlockHeightsList = computeBlockHeightsList;
const computeLargestSubsetMaxBy = (arrayOfObjects, propertySelectorFunc) => {
    const comparableValues = arrayOfObjects.map(propertySelectorFunc);
    const absoluteMax = Math.max(...comparableValues);
    const largestSubset = [];
    for (const item of arrayOfObjects) {
        if (propertySelectorFunc(item) === absoluteMax) {
            largestSubset.push(item);
        }
    }
    return largestSubset;
};
exports.computeLargestSubsetMaxBy = computeLargestSubsetMaxBy;
//# sourceMappingURL=utils.js.map