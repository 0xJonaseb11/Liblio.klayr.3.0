"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeValidatorsHash = exports.sortValidatorsByBLSKey = exports.sortValidatorsByAddress = exports.getBlockBFTProperties = exports.areDistinctHeadersContradicting = void 0;
const codec_1 = require("@klayr/codec");
const cryptography_1 = require("@klayr/cryptography");
const schemas_1 = require("./schemas");
const areDistinctHeadersContradicting = (b1, b2) => {
    let earlierBlock = b1;
    let laterBlock = b2;
    const higherMaxHeightGenerated = earlierBlock.maxHeightGenerated > laterBlock.maxHeightGenerated;
    const sameMaxHeightGenerated = earlierBlock.maxHeightGenerated === laterBlock.maxHeightGenerated;
    const higherMaxHeightPrevoted = earlierBlock.maxHeightPrevoted > laterBlock.maxHeightPrevoted;
    const sameMaxHeightPrevoted = earlierBlock.maxHeightPrevoted === laterBlock.maxHeightPrevoted;
    const higherHeight = earlierBlock.height > laterBlock.height;
    if (higherMaxHeightGenerated ||
        (sameMaxHeightGenerated && higherMaxHeightPrevoted) ||
        (sameMaxHeightGenerated && sameMaxHeightPrevoted && higherHeight)) {
        [earlierBlock, laterBlock] = [laterBlock, earlierBlock];
    }
    if (!earlierBlock.generatorAddress.equals(laterBlock.generatorAddress)) {
        return false;
    }
    if (earlierBlock.maxHeightPrevoted === laterBlock.maxHeightPrevoted &&
        earlierBlock.height >= laterBlock.height) {
        return true;
    }
    if (earlierBlock.height > laterBlock.maxHeightGenerated) {
        return true;
    }
    if (earlierBlock.maxHeightPrevoted > laterBlock.maxHeightPrevoted) {
        return true;
    }
    return false;
};
exports.areDistinctHeadersContradicting = areDistinctHeadersContradicting;
const getBlockBFTProperties = (header) => ({
    generatorAddress: header.generatorAddress,
    height: header.height,
    maxHeightGenerated: header.maxHeightGenerated,
    maxHeightPrevoted: header.maxHeightPrevoted,
    precommitWeight: BigInt(0),
    prevoteWeight: BigInt(0),
});
exports.getBlockBFTProperties = getBlockBFTProperties;
const sortValidatorsByAddress = (validators) => validators.sort((a, b) => a.address.compare(b.address));
exports.sortValidatorsByAddress = sortValidatorsByAddress;
const sortValidatorsByBLSKey = (validators) => validators.sort((a, b) => a.blsKey.compare(b.blsKey));
exports.sortValidatorsByBLSKey = sortValidatorsByBLSKey;
const computeValidatorsHash = (activeValidators, certificateThreshold) => {
    const input = {
        activeValidators,
        certificateThreshold,
    };
    const encodedValidatorsHashInput = codec_1.codec.encode(schemas_1.validatorsHashInputSchema, input);
    return cryptography_1.utils.hash(encodedValidatorsHashInput);
};
exports.computeValidatorsHash = computeValidatorsHash;
//# sourceMappingURL=utils.js.map