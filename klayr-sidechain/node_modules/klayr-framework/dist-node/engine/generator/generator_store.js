"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorStore = void 0;
const lisk_db_1 = require("@liskhq/lisk-db");
const utils_1 = require("@klayr/utils");
const errors_1 = require("./errors");
class GeneratorStore {
    constructor(db, prefix, data) {
        this._db = db;
        this._prefix = prefix !== null && prefix !== void 0 ? prefix : Buffer.alloc(0);
        this._data = data !== null && data !== void 0 ? data : new utils_1.dataStructures.BufferMap();
    }
    getGeneratorStore(moduleID) {
        return new GeneratorStore(this._db, moduleID, this._data);
    }
    async get(key) {
        const prefixedKey = this._getKey(key);
        const cachedValue = this._data.get(prefixedKey);
        if (cachedValue) {
            return cachedValue;
        }
        try {
            const storedValue = await this._db.get(prefixedKey);
            this._data.set(prefixedKey, storedValue);
            return storedValue;
        }
        catch (error) {
            if (error instanceof lisk_db_1.NotFoundError) {
                throw new errors_1.NotFoundError();
            }
            throw error;
        }
    }
    async set(key, value) {
        const prefixedKey = this._getKey(key);
        this._data.set(prefixedKey, value);
    }
    async iterate(options) {
        const optionsWithKey = {
            ...options,
            gte: options.gte ? this._getKey(options.gte) : undefined,
            lte: options.lte ? this._getKey(options.lte) : undefined,
        };
        const stream = this._db.iterate(optionsWithKey);
        const result = await new Promise((resolve, reject) => {
            const pairs = [];
            stream
                .on('data', ({ key, value }) => {
                pairs.push({ key: key.subarray(this._prefix.length), value });
            })
                .on('error', error => {
                reject(error);
            })
                .on('end', () => {
                resolve(pairs);
            });
        });
        return result;
    }
    finalize(batch) {
        for (const [key, value] of this._data.entries()) {
            batch.set(key, value);
        }
    }
    _getKey(key) {
        return Buffer.concat([this._prefix, key]);
    }
}
exports.GeneratorStore = GeneratorStore;
//# sourceMappingURL=generator_store.js.map