"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SingleCommitHandler = void 0;
const chain_1 = require("@klayr/chain");
const cryptography_1 = require("@klayr/cryptography");
const metrics_1 = require("../metrics/metrics");
class SingleCommitHandler {
    constructor(logger, chain, consensus, bft, keypairs, blockchainDB) {
        this._metrics = {
            signedCommits: metrics_1.defaultMetrics.counter('generator_signedCommits'),
        };
        this._logger = logger;
        this._chain = chain;
        this._consensus = consensus;
        this._bft = bft;
        this._keypairs = keypairs;
        this._blockchainDB = blockchainDB;
    }
    async initAllSingleCommits() {
        for (const [address] of this._keypairs.entries()) {
            await this.initSingleCommits(address);
        }
    }
    async initSingleCommits(address) {
        const maxRemovalHeight = await this._consensus.getMaxRemovalHeight();
        const stateStore = new chain_1.StateStore(this._blockchainDB);
        const { maxHeightPrecommitted } = await this._bft.method.getBFTHeights(stateStore);
        await Promise.all(this._handleFinalizedHeightChanged(address, maxRemovalHeight, maxHeightPrecommitted));
    }
    async handleFinalizedHeightChanged(from, to) {
        const maxRemovalHeight = await this._consensus.getMaxRemovalHeight();
        const cappedFrom = Math.max(maxRemovalHeight, from);
        if (cappedFrom >= to) {
            return;
        }
        for (const [address] of this._keypairs.entries()) {
            await Promise.all(this._handleFinalizedHeightChanged(address, cappedFrom, to));
        }
    }
    _handleFinalizedHeightChanged(address, from, to) {
        if (from >= to) {
            return [];
        }
        const promises = [];
        const stateStore = new chain_1.StateStore(this._blockchainDB);
        const pairs = this._keypairs.get(address);
        if (!pairs) {
            this._logger.warn({ address: cryptography_1.address.getKlayr32AddressFromAddress(address) }, 'Validator does not have registered BLS key on this node');
            return [];
        }
        for (let height = from + 1; height < to; height += 1) {
            promises.push(this._certifySingleCommitForChangedHeight(stateStore, height, address, pairs.blsPublicKey, pairs.blsSecretKey));
        }
        promises.push(this._certifySingleCommit(stateStore, to, address, pairs.blsPublicKey, pairs.blsSecretKey));
        return promises;
    }
    async _certifySingleCommitForChangedHeight(stateStore, height, generatorAddress, blsPK, blsSK) {
        const paramExist = await this._bft.method.existBFTParameters(stateStore, height + 1);
        if (!paramExist) {
            return;
        }
        await this._certifySingleCommit(stateStore, height, generatorAddress, blsPK, blsSK);
    }
    async _certifySingleCommit(stateStore, height, generatorAddress, blsPK, blsSK) {
        const params = await this._bft.method.getBFTParametersActiveValidators(stateStore, height);
        const registeredValidator = params.validators.find(v => v.address.equals(generatorAddress));
        if (!registeredValidator) {
            return;
        }
        if (!registeredValidator.blsKey.equals(blsPK)) {
            this._logger.warn({ address: cryptography_1.address.getKlayr32AddressFromAddress(generatorAddress) }, 'Validator does not have registered BLS key');
            return;
        }
        const blockHeader = await this._chain.dataAccess.getBlockHeaderByHeight(height);
        const validatorInfo = {
            address: generatorAddress,
            blsPublicKey: blsPK,
            blsSecretKey: blsSK,
        };
        this._consensus.certifySingleCommit(blockHeader, validatorInfo);
        this._logger.debug({
            height,
            generator: cryptography_1.address.getKlayr32AddressFromAddress(generatorAddress),
        }, 'Certified single commit');
        this._metrics.signedCommits.inc(1);
    }
}
exports.SingleCommitHandler = SingleCommitHandler;
//# sourceMappingURL=single_commit_handler.js.map