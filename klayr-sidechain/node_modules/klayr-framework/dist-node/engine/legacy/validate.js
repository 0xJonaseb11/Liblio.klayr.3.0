"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateLegacyBlock = void 0;
const cryptography_1 = require("@klayr/cryptography");
const tree_1 = require("@klayr/tree");
const validator_1 = require("@klayr/validator");
const codec_1 = require("./codec");
const validateLegacyBlock = (receivedBlock, decodedNextBlock) => {
    const { block: decodedBlock, schema: blockSchema } = (0, codec_1.decodeBlock)(receivedBlock);
    validator_1.validator.validate(blockSchema.header, decodedBlock.header);
    if (decodedBlock.header.height + 1 !== decodedNextBlock.header.height) {
        throw new Error(`Received block at height ${decodedBlock.header.height} is not consecutive to next block ${decodedNextBlock.header.height}`);
    }
    if (!decodedBlock.header.id.equals(decodedNextBlock.header.previousBlockID)) {
        throw new Error(`Received block ${decodedBlock.header.id.toString('hex')} is not previous block of ${decodedNextBlock.header.id.toString('hex')}`);
    }
    const transactionRoot = tree_1.regularMerkleTree.calculateMerkleRootWithLeaves(decodedBlock.payload.map(tx => cryptography_1.utils.hash(tx)));
    if (!decodedBlock.header.transactionRoot.equals(transactionRoot)) {
        throw new Error(`Received block has invalid transaction root ${transactionRoot.toString('hex')}. Expected: ${decodedBlock.header.transactionRoot.toString('hex')}`);
    }
};
exports.validateLegacyBlock = validateLegacyBlock;
//# sourceMappingURL=validate.js.map