"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthEndpoint = void 0;
const validator_1 = require("@klayr/validator");
const cryptography_1 = require("@klayr/cryptography");
const state_machine_1 = require("../../state_machine");
const base_endpoint_1 = require("../base_endpoint");
const utils_1 = require("./utils");
const auth_account_1 = require("./stores/auth_account");
const schemas_1 = require("./schemas");
const constants_1 = require("./constants");
class AuthEndpoint extends base_endpoint_1.BaseEndpoint {
    async getAuthAccount(context) {
        const { params: { address }, } = context;
        if (typeof address !== 'string') {
            throw new Error('Invalid address format.');
        }
        cryptography_1.address.validateKlayr32Address(address);
        const accountAddress = cryptography_1.address.getAddressFromKlayr32Address(address);
        const authAccountStore = this.stores.get(auth_account_1.AuthAccountStore);
        const authAccount = await authAccountStore.getOrDefault(context, accountAddress);
        return {
            nonce: authAccount.nonce.toString(),
            numberOfSignatures: authAccount.numberOfSignatures,
            mandatoryKeys: authAccount.mandatoryKeys.map(key => key.toString('hex')),
            optionalKeys: authAccount.optionalKeys.map(key => key.toString('hex')),
        };
    }
    async isValidSignature(context) {
        const { params: { transaction: transactionParameter }, chainID, } = context;
        const transaction = (0, utils_1.getTransactionFromParameter)(transactionParameter);
        const accountAddress = cryptography_1.address.getAddressFromPublicKey(transaction.senderPublicKey);
        const authAccountStore = this.stores.get(auth_account_1.AuthAccountStore);
        const account = await authAccountStore.getOrDefault(context, accountAddress);
        try {
            (0, utils_1.verifySignatures)(transaction, chainID, account);
        }
        catch (error) {
            return { verified: false };
        }
        return { verified: true };
    }
    async isValidNonce(context) {
        const { params: { transaction: transactionParameter }, } = context;
        const transaction = (0, utils_1.getTransactionFromParameter)(transactionParameter);
        const accountAddress = cryptography_1.address.getAddressFromPublicKey(transaction.senderPublicKey);
        const authAccountStore = this.stores.get(auth_account_1.AuthAccountStore);
        const account = await authAccountStore.getOrDefault(context, accountAddress);
        const verificationResult = (0, utils_1.verifyNonce)(transaction, account).status;
        return { verified: verificationResult === state_machine_1.VerifyStatus.OK };
    }
    async getMultiSigRegMsgSchema(_context) {
        return { schema: schemas_1.multisigRegMsgSchema };
    }
    sortMultisignatureGroup(context) {
        validator_1.validator.validate(schemas_1.sortMultisignatureGroupRequestSchema, context.params);
        const mandatory = context.params.mandatory;
        const optional = context.params.optional;
        const compareStrings = (a, b) => (a < b ? -1 : 1);
        const sortedMandatory = mandatory
            .slice()
            .sort((keySignaturePairA, keySignaturePairB) => compareStrings(keySignaturePairA.publicKey, keySignaturePairB.publicKey));
        const sortedOptional = optional
            .slice()
            .sort((keySignaturePairA, keySignaturePairB) => compareStrings(keySignaturePairA.publicKey, keySignaturePairB.publicKey));
        return {
            mandatoryKeys: sortedMandatory.map(keySignaturePair => keySignaturePair.publicKey),
            optionalKeys: sortedOptional.map(keySignaturePair => keySignaturePair.publicKey),
            signatures: sortedMandatory
                .map(keySignaturePair => keySignaturePair.signature)
                .concat(sortedOptional.map(keySignaturePair => keySignaturePair.signature)),
        };
    }
    getMultiSigRegMsgTag() {
        return { tag: constants_1.MESSAGE_TAG_MULTISIG_REG };
    }
}
exports.AuthEndpoint = AuthEndpoint;
//# sourceMappingURL=endpoint.js.map