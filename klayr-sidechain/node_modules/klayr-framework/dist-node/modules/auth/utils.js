"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTransactionFromParameter = exports.verifyNonce = exports.verifySignatures = exports.verifyMultiSignatureTransaction = exports.verifySignature = void 0;
const chain_1 = require("@klayr/chain");
const cryptography_1 = require("@klayr/cryptography");
const validator_1 = require("@klayr/validator");
const state_machine_1 = require("../../state_machine");
const verifySignature = (chainID, publicKey, signature, transactionBytes, id) => {
    const isSignatureValid = cryptography_1.ed.verifyData(chain_1.TAG_TRANSACTION, chainID, transactionBytes, signature, publicKey);
    if (!isSignatureValid) {
        throw new Error(`Failed to validate signature '${signature.toString('hex')}' for transaction with id '${id.toString('hex')}'`);
    }
};
exports.verifySignature = verifySignature;
const verifyMultiSignatureTransaction = (chainID, id, account, signatures, transactionBytes) => {
    const keys = account.mandatoryKeys.concat(account.optionalKeys);
    const mandatoryKeysCount = account.mandatoryKeys.length;
    const nonEmptySignaturesCount = signatures.filter(k => k.length !== 0).length;
    if (nonEmptySignaturesCount !== account.numberOfSignatures || signatures.length !== keys.length) {
        throw new Error(`Transaction signatures does not match required number of signatures: '${account.numberOfSignatures.toString()}' for transaction with id '${id.toString('hex')}'`);
    }
    for (let i = 0; i < keys.length; i += 1) {
        if (signatures[i].length !== 0) {
            (0, exports.verifySignature)(chainID, keys[i], signatures[i], transactionBytes, id);
        }
        else if (signatures[i].length === 0 && i < mandatoryKeysCount) {
            throw new Error('Missing signature for a mandatory key.');
        }
    }
};
exports.verifyMultiSignatureTransaction = verifyMultiSignatureTransaction;
const verifySignatures = (transaction, chainID, account) => {
    if (account.numberOfSignatures !== 0) {
        (0, exports.verifyMultiSignatureTransaction)(chainID, transaction.id, account, transaction.signatures, transaction.getSigningBytes());
    }
    else {
        if (transaction.signatures.length !== 1) {
            throw new Error(`Transactions from a single signature account should have exactly one signature. Found ${transaction.signatures.length} signatures.`);
        }
        (0, exports.verifySignature)(chainID, transaction.senderPublicKey, transaction.signatures[0], transaction.getSigningBytes(), transaction.id);
    }
};
exports.verifySignatures = verifySignatures;
const verifyNonce = (transaction, senderAccount) => {
    if (transaction.nonce < senderAccount.nonce) {
        return { status: state_machine_1.VerifyStatus.FAIL };
    }
    return {
        status: transaction.nonce > senderAccount.nonce ? state_machine_1.VerifyStatus.PENDING : state_machine_1.VerifyStatus.OK,
    };
};
exports.verifyNonce = verifyNonce;
const getTransactionFromParameter = (transactionParameter) => {
    if (!(0, validator_1.isHexString)(transactionParameter)) {
        throw new Error('Transaction parameter must be a string.');
    }
    const transactionBuffer = Buffer.from(transactionParameter, 'hex');
    const transaction = chain_1.Transaction.fromBytes(transactionBuffer);
    transaction.validate();
    return transaction;
};
exports.getTransactionFromParameter = getTransactionFromParameter;
//# sourceMappingURL=utils.js.map