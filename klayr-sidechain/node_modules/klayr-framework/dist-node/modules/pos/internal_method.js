"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalMethod = void 0;
const base_method_1 = require("../base_method");
const constants_1 = require("./constants");
const rewards_assigned_1 = require("./events/rewards_assigned");
const staker_1 = require("./stores/staker");
const utils_1 = require("./utils");
class InternalMethod extends base_method_1.BaseMethod {
    constructor(stores, events, moduleName) {
        super(stores, events);
        this._moduleName = moduleName;
    }
    addDependencies(tokenMethod) {
        this._tokenMethod = tokenMethod;
    }
    async assignStakeRewards(methodContext, stakerAddress, sentStake, validatorData) {
        var _a;
        if (sentStake.validatorAddress.equals(stakerAddress)) {
            return;
        }
        for (const sharingCoefficient of validatorData.sharingCoefficients) {
            const stakeSharingCoefficient = (_a = sentStake.sharingCoefficients.find(coefficient => coefficient.tokenID.equals(sharingCoefficient.tokenID))) !== null && _a !== void 0 ? _a : {
                tokenID: sharingCoefficient.tokenID,
                coefficient: Buffer.alloc(constants_1.MAX_NUMBER_BYTES_Q96),
            };
            const reward = (0, utils_1.calculateStakeRewards)(stakeSharingCoefficient, sentStake.amount, sharingCoefficient);
            if (reward > 0) {
                await this._tokenMethod.unlock(methodContext, sentStake.validatorAddress, this._moduleName, sharingCoefficient.tokenID, reward);
                await this._tokenMethod.transfer(methodContext, sentStake.validatorAddress, stakerAddress, sharingCoefficient.tokenID, reward);
                this.events.get(rewards_assigned_1.RewardsAssignedEvent).log(methodContext, {
                    stakerAddress,
                    validatorAddress: sentStake.validatorAddress,
                    tokenID: sharingCoefficient.tokenID,
                    amount: reward,
                });
            }
        }
    }
    async getLockedStakedAmount(ctx, address) {
        const staker = await this.stores.get(staker_1.StakerStore).getOrDefault(ctx, address);
        let lockedAmount = BigInt(0);
        for (const stakes of staker.stakes) {
            lockedAmount += stakes.amount;
        }
        for (const unlock of staker.pendingUnlocks) {
            lockedAmount += unlock.amount;
        }
        return lockedAmount;
    }
}
exports.InternalMethod = InternalMethod;
//# sourceMappingURL=internal_method.js.map