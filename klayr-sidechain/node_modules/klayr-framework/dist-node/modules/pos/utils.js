"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateStakeRewards = exports.isSharingCoefficientSorted = exports.getValidatorWeight = exports.getModuleConfig = exports.getPunishmentPeriod = exports.getMinPunishedHeight = exports.isCertificateGenerated = exports.isPunished = exports.hasWaited = exports.getPunishTime = exports.getWaitTime = exports.isCurrentlyPunished = exports.selectStandbyValidators = exports.pickStandByValidator = exports.validateSignature = exports.isUsername = exports.isNullCharacterIncluded = exports.equalUnlocking = exports.sortUnlocking = void 0;
const cryptography_1 = require("@klayr/cryptography");
const utils_1 = require("@klayr/utils");
const { q96 } = utils_1.math;
const sortUnlocking = (unlocks) => {
    unlocks.sort((a, b) => {
        if (!a.validatorAddress.equals(b.validatorAddress)) {
            return a.validatorAddress.compare(b.validatorAddress);
        }
        if (a.unstakeHeight !== b.unstakeHeight) {
            return b.unstakeHeight - a.unstakeHeight;
        }
        const diff = b.amount - a.amount;
        if (diff > BigInt(0)) {
            return 1;
        }
        if (diff < BigInt(0)) {
            return -1;
        }
        return 0;
    });
};
exports.sortUnlocking = sortUnlocking;
const equalUnlocking = (a, b) => a.validatorAddress.equals(b.validatorAddress) &&
    a.amount === b.amount &&
    a.unstakeHeight === b.unstakeHeight;
exports.equalUnlocking = equalUnlocking;
const isNullCharacterIncluded = (input) => new RegExp(/\\0|\\u0000|\\x00/).test(input);
exports.isNullCharacterIncluded = isNullCharacterIncluded;
const isUsername = (username) => {
    if ((0, exports.isNullCharacterIncluded)(username)) {
        return false;
    }
    if (username !== username.trim().toLowerCase()) {
        return false;
    }
    return /^[a-z0-9!@$&_.]+$/g.test(username);
};
exports.isUsername = isUsername;
const validateSignature = (tag, chainID, publicKey, signature, bytes) => cryptography_1.ed.verifyData(tag, chainID, bytes, signature, publicKey);
exports.validateSignature = validateSignature;
const pickStandByValidator = (validatorWeights, randomSeed) => {
    const seedNumber = randomSeed.readBigUInt64BE();
    const totalStakeWeight = validatorWeights.reduce((prev, current) => prev + BigInt(current.weight), BigInt(0));
    let threshold = seedNumber % totalStakeWeight;
    for (let i = 0; i < validatorWeights.length; i += 1) {
        const validatorWeight = BigInt(validatorWeights[i].weight);
        if (validatorWeight > threshold) {
            return i;
        }
        threshold -= validatorWeight;
    }
    return -1;
};
exports.pickStandByValidator = pickStandByValidator;
const selectStandbyValidators = (validatorWeights, randomSeed1, randomSeed2) => {
    const numberOfCandidates = 1 + (randomSeed2 !== undefined ? 1 : 0);
    if (validatorWeights.length <= numberOfCandidates) {
        return validatorWeights.map(v => ({
            address: v.address,
            weight: BigInt(0),
        }));
    }
    const result = [];
    const index = (0, exports.pickStandByValidator)(validatorWeights, randomSeed1);
    const [selected] = validatorWeights.splice(index, 1);
    result.push({
        address: selected.address,
        weight: BigInt(0),
    });
    if (!randomSeed2) {
        return result;
    }
    const secondIndex = (0, exports.pickStandByValidator)(validatorWeights, randomSeed2);
    const [secondStandby] = validatorWeights.splice(secondIndex, 1);
    result.push({
        address: secondStandby.address,
        weight: BigInt(0),
    });
    return result;
};
exports.selectStandbyValidators = selectStandbyValidators;
const isCurrentlyPunished = (height, pomHeights, punishmentWindowSelfStaking) => {
    if (pomHeights.length === 0) {
        return false;
    }
    const lastPomHeight = Math.max(...pomHeights);
    if (height - lastPomHeight < punishmentWindowSelfStaking) {
        return true;
    }
    return false;
};
exports.isCurrentlyPunished = isCurrentlyPunished;
const getWaitTime = (senderAddress, validatorAddress, punishmentLockingPeriods) => validatorAddress.equals(senderAddress)
    ? punishmentLockingPeriods.lockingPeriodSelfStaking
    : punishmentLockingPeriods.lockingPeriodStaking;
exports.getWaitTime = getWaitTime;
const getPunishTime = (senderAddress, validatorAddress, punishmentLockingPeriods) => validatorAddress.equals(senderAddress)
    ? punishmentLockingPeriods.punishmentWindowSelfStaking
    : punishmentLockingPeriods.punishmentWindowStaking;
exports.getPunishTime = getPunishTime;
const hasWaited = (unlockingObject, senderAddress, height, punishmentLockingPeriods) => {
    const delayedAvailability = (0, exports.getWaitTime)(senderAddress, unlockingObject.validatorAddress, punishmentLockingPeriods);
    return !(height - unlockingObject.unstakeHeight < delayedAvailability);
};
exports.hasWaited = hasWaited;
const isPunished = (unlockingObject, pomHeights, senderAddress, height, punishmentLockingPeriods) => {
    if (!pomHeights.length) {
        return false;
    }
    const lastPomHeight = pomHeights[pomHeights.length - 1];
    const waitTime = (0, exports.getWaitTime)(senderAddress, unlockingObject.validatorAddress, punishmentLockingPeriods);
    const punishTime = (0, exports.getPunishTime)(senderAddress, unlockingObject.validatorAddress, punishmentLockingPeriods);
    return (height - lastPomHeight < punishTime && lastPomHeight < unlockingObject.unstakeHeight + waitTime);
};
exports.isPunished = isPunished;
const lastHeightOfRound = (height, genesisHeight, roundLength) => {
    const roundNumber = Math.ceil((height - genesisHeight) / roundLength);
    return roundNumber * roundLength + genesisHeight;
};
const isCertificateGenerated = (options) => lastHeightOfRound(options.unlockObject.unstakeHeight + 2 * options.roundLength, options.genesisHeight, options.roundLength) <= options.maxHeightCertified;
exports.isCertificateGenerated = isCertificateGenerated;
const getMinPunishedHeight = (pomHeights, punishmentWindow) => {
    if (pomHeights.length === 0) {
        return 0;
    }
    const lastPomHeight = Math.max(...pomHeights);
    return lastPomHeight + punishmentWindow;
};
exports.getMinPunishedHeight = getMinPunishedHeight;
const getPunishmentPeriod = (senderAddress, validatorAddress, pomHeights, currentHeight, punishmentLockingPeriods) => {
    const punishmentWindow = senderAddress.equals(validatorAddress)
        ? punishmentLockingPeriods.punishmentWindowSelfStaking
        : punishmentLockingPeriods.punishmentWindowStaking;
    const minPunishedHeight = (0, exports.getMinPunishedHeight)(pomHeights, punishmentWindow);
    const remainingBlocks = minPunishedHeight - currentHeight;
    return remainingBlocks < 0 ? 0 : remainingBlocks;
};
exports.getPunishmentPeriod = getPunishmentPeriod;
const getModuleConfig = (config) => {
    const roundLength = config.numberActiveValidators + config.numberStandbyValidators;
    return {
        ...config,
        roundLength,
        minWeightStandby: BigInt(config.minWeightStandby),
        posTokenID: Buffer.from(config.posTokenID, 'hex'),
        validatorRegistrationFee: BigInt(config.validatorRegistrationFee),
        baseStakeAmount: BigInt(config.baseStakeAmount),
        reportMisbehaviorReward: BigInt(config.reportMisbehaviorReward),
        weightScaleFactor: BigInt(config.weightScaleFactor),
    };
};
exports.getModuleConfig = getModuleConfig;
const getValidatorWeight = (factorSelfStakes, selfStake, totalStakeReceived) => {
    const cap = selfStake * BigInt(factorSelfStakes);
    if (cap < totalStakeReceived) {
        return cap;
    }
    return totalStakeReceived;
};
exports.getValidatorWeight = getValidatorWeight;
const isSharingCoefficientSorted = (sharingCoefficients) => {
    const sharingCoefficientsCopy = [...sharingCoefficients];
    sharingCoefficientsCopy.sort((a, b) => a.tokenID.compare(b.tokenID));
    for (let i = 0; i < sharingCoefficients.length; i += 1) {
        if (!sharingCoefficientsCopy[i].tokenID.equals(sharingCoefficients[i].tokenID)) {
            return false;
        }
    }
    return true;
};
exports.isSharingCoefficientSorted = isSharingCoefficientSorted;
const calculateStakeRewards = (stakeSharingCoefficient, amount, validatorSharingCoefficient) => {
    const qAmount = q96(amount);
    const qStakeSharingCoefficient = q96(stakeSharingCoefficient.coefficient);
    const qValidatorSharingCoefficient = q96(validatorSharingCoefficient.coefficient);
    const reward = qValidatorSharingCoefficient.sub(qStakeSharingCoefficient).mul(qAmount);
    return reward.floor();
};
exports.calculateStakeRewards = calculateStakeRewards;
//# sourceMappingURL=utils.js.map