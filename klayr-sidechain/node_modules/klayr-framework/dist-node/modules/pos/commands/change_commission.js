"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangeCommissionCommand = void 0;
const state_machine_1 = require("../../../state_machine");
const base_command_1 = require("../../base_command");
const commission_change_1 = require("../events/commission_change");
const schemas_1 = require("../schemas");
const validator_1 = require("../stores/validator");
class ChangeCommissionCommand extends base_command_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.schema = schemas_1.changeCommissionCommandParamsSchema;
    }
    init(args) {
        this._commissionIncreasePeriod = args.commissionIncreasePeriod;
        this._maxCommissionIncreaseRate = args.maxCommissionIncreaseRate;
    }
    async verify(context) {
        const validatorStore = this.stores.get(validator_1.ValidatorStore);
        const validatorExists = await validatorStore.has(context, context.transaction.senderAddress);
        if (!validatorExists) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error('Transaction sender has not registered as a validator.'),
            };
        }
        const validatorData = await validatorStore.get(context, context.transaction.senderAddress);
        const oldCommission = validatorData.commission;
        const hasIncreasedCommissionRecently = context.header.height - validatorData.lastCommissionIncreaseHeight <
            this._commissionIncreasePeriod;
        if (context.params.newCommission > oldCommission && hasIncreasedCommissionRecently) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error(`Can only increase the commission again ${this._commissionIncreasePeriod} blocks after the last commission increase.`),
            };
        }
        if (context.params.newCommission - oldCommission > this._maxCommissionIncreaseRate) {
            return {
                status: state_machine_1.VerifyStatus.FAIL,
                error: new Error(`Invalid argument: Commission increase larger than ${this._maxCommissionIncreaseRate}.`),
            };
        }
        return {
            status: state_machine_1.VerifyStatus.OK,
        };
    }
    async execute(context) {
        const validatorStore = this.stores.get(validator_1.ValidatorStore);
        const validatorAccount = await validatorStore.get(context, context.transaction.senderAddress);
        const oldCommission = validatorAccount.commission;
        validatorAccount.commission = context.params.newCommission;
        if (validatorAccount.commission >= oldCommission) {
            validatorAccount.lastCommissionIncreaseHeight = context.header.height;
        }
        await validatorStore.set(context, context.transaction.senderAddress, validatorAccount);
        this.events.get(commission_change_1.CommissionChangeEvent).log(context, {
            validatorAddress: context.transaction.senderAddress,
            oldCommission,
            newCommission: context.params.newCommission,
        });
    }
}
exports.ChangeCommissionCommand = ChangeCommissionCommand;
//# sourceMappingURL=change_commission.js.map