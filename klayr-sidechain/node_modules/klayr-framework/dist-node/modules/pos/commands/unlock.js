"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnlockCommand = void 0;
const base_command_1 = require("../../base_command");
const constants_1 = require("../constants");
const validator_1 = require("../stores/validator");
const genesis_1 = require("../stores/genesis");
const staker_1 = require("../stores/staker");
const utils_1 = require("../utils");
class UnlockCommand extends base_command_1.BaseCommand {
    addDependencies(args) {
        this._tokenMethod = args.tokenMethod;
    }
    init(args) {
        this._posTokenID = args.posTokenID;
        this._roundLength = args.roundLength;
        this._punishmentLockingPeriods = args.punishmentLockingPeriods;
    }
    async execute(context) {
        const { transaction: { senderAddress }, getMethodContext, header: { height, aggregateCommit }, } = context;
        const validatorSubstore = this.stores.get(validator_1.ValidatorStore);
        const stakerSubstore = this.stores.get(staker_1.StakerStore);
        const stakerData = await stakerSubstore.get(context, senderAddress);
        const ineligibleUnlocks = [];
        const genesisDataStore = this.stores.get(genesis_1.GenesisDataStore);
        const genesisData = await genesisDataStore.get(context, constants_1.EMPTY_KEY);
        const { height: genesisHeight } = genesisData;
        for (const unlockObject of stakerData.pendingUnlocks) {
            const { reportMisbehaviorHeights } = await validatorSubstore.get(context, unlockObject.validatorAddress);
            if ((0, utils_1.hasWaited)(unlockObject, senderAddress, height, this._punishmentLockingPeriods) &&
                !(0, utils_1.isPunished)(unlockObject, reportMisbehaviorHeights, senderAddress, height, this._punishmentLockingPeriods) &&
                (0, utils_1.isCertificateGenerated)({
                    unlockObject,
                    genesisHeight,
                    maxHeightCertified: aggregateCommit.height,
                    roundLength: this._roundLength,
                })) {
                await this._tokenMethod.unlock(getMethodContext(), senderAddress, constants_1.MODULE_NAME_POS, this._posTokenID, unlockObject.amount);
                continue;
            }
            ineligibleUnlocks.push(unlockObject);
        }
        if (stakerData.pendingUnlocks.length === ineligibleUnlocks.length) {
            throw new Error('No eligible staker data was found for unlocking');
        }
        stakerData.pendingUnlocks = ineligibleUnlocks;
        await stakerSubstore.set(context, senderAddress, stakerData);
    }
}
exports.UnlockCommand = UnlockCommand;
//# sourceMappingURL=unlock.js.map