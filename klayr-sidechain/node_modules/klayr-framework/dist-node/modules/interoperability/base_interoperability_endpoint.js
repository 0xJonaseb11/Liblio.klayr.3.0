"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseInteroperabilityEndpoint = void 0;
const validator_1 = require("@klayr/validator");
const base_endpoint_1 = require("../base_endpoint");
const terminated_state_1 = require("./stores/terminated_state");
const terminated_outbox_1 = require("./stores/terminated_outbox");
const utils_1 = require("./utils");
const chain_validators_1 = require("./stores/chain_validators");
const chain_account_1 = require("./stores/chain_account");
const channel_data_1 = require("./stores/channel_data");
const own_chain_account_1 = require("./stores/own_chain_account");
const constants_1 = require("./constants");
const schemas_1 = require("./schemas");
class BaseInteroperabilityEndpoint extends base_endpoint_1.BaseEndpoint {
    constructor(stores, offchainStores) {
        super(stores, offchainStores);
        this.stores = stores;
        this.offchainStores = offchainStores;
        this.interoperableCCMethods = new Map();
    }
    async getChainAccount(context) {
        validator_1.validator.validate(schemas_1.getChainAccountRequestSchema, context.params);
        const chainID = Buffer.from(context.params.chainID, 'hex');
        return (0, utils_1.chainAccountToJSON)(await this.stores.get(chain_account_1.ChainAccountStore).get(context, chainID));
    }
    async getAllChainAccounts(context) {
        validator_1.validator.validate(schemas_1.getChainAccountRequestSchema, context.params);
        const startChainID = Buffer.from(context.params.chainID, 'hex');
        const chainAccounts = (await this.stores.get(chain_account_1.ChainAccountStore).getAllAccounts(context, startChainID)).map(chainAccount => (0, utils_1.chainAccountToJSON)(chainAccount));
        return { chains: chainAccounts };
    }
    async getChannel(context) {
        validator_1.validator.validate(schemas_1.getChannelRequestSchema, context.params);
        const chainID = Buffer.from(context.params.chainID, 'hex');
        const { inbox, messageFeeTokenID, outbox, partnerChainOutboxRoot, minReturnFeePerByte } = await this.stores.get(channel_data_1.ChannelDataStore).get(context, chainID);
        const inboxJSON = this._toBoxJSON(inbox);
        const outboxJSON = this._toBoxJSON(outbox);
        return {
            messageFeeTokenID: messageFeeTokenID.toString('hex'),
            outbox: outboxJSON,
            inbox: inboxJSON,
            partnerChainOutboxRoot: partnerChainOutboxRoot.toString('hex'),
            minReturnFeePerByte: minReturnFeePerByte.toString(),
        };
    }
    async getOwnChainAccount(context) {
        const { chainID, name, nonce } = await this.stores
            .get(own_chain_account_1.OwnChainAccountStore)
            .get(context, constants_1.EMPTY_BYTES);
        return {
            chainID: chainID.toString('hex'),
            name,
            nonce: nonce.toString(),
        };
    }
    async getTerminatedStateAccount(context) {
        validator_1.validator.validate(schemas_1.getTerminatedStateAccountRequestSchema, context.params);
        const chainID = Buffer.from(context.params.chainID, 'hex');
        const { stateRoot, initialized, mainchainStateRoot } = await this.stores
            .get(terminated_state_1.TerminatedStateStore)
            .get(context, chainID);
        return {
            stateRoot: stateRoot.toString('hex'),
            initialized,
            mainchainStateRoot: mainchainStateRoot.toString('hex'),
        };
    }
    async getTerminatedOutboxAccount(context) {
        validator_1.validator.validate(schemas_1.getTerminatedOutboxAccountRequestSchema, context.params);
        const chainID = Buffer.from(context.params.chainID, 'hex');
        const { outboxRoot, outboxSize, partnerChainInboxSize } = await this.stores
            .get(terminated_outbox_1.TerminatedOutboxStore)
            .get(context, chainID);
        return {
            outboxRoot: outboxRoot.toString('hex'),
            outboxSize,
            partnerChainInboxSize,
        };
    }
    async getChainValidators(context) {
        validator_1.validator.validate(schemas_1.getChainValidatorsRequestSchema, context.params);
        const chainID = Buffer.from(context.params.chainID, 'hex');
        const chainAccountStore = this.stores.get(chain_account_1.ChainAccountStore);
        const chainAccountExists = await chainAccountStore.has(context, chainID);
        if (!chainAccountExists) {
            throw new Error('Chain account does not exist.');
        }
        const chainValidatorsStore = this.stores.get(chain_validators_1.ChainValidatorsStore);
        const validators = await chainValidatorsStore.get(context, chainID);
        return {
            activeValidators: validators.activeValidators.map(v => ({
                blsKey: v.blsKey.toString('hex'),
                bftWeight: v.bftWeight.toString(),
            })),
            certificateThreshold: validators.certificateThreshold.toString(),
        };
    }
    async getCCMSchema(_context) {
        return {
            schema: schemas_1.ccmSchema,
        };
    }
    _toBoxJSON(box) {
        return {
            appendPath: box.appendPath.map(ap => ap.toString('hex')),
            root: box.root.toString('hex'),
            size: box.size,
        };
    }
}
exports.BaseInteroperabilityEndpoint = BaseInteroperabilityEndpoint;
//# sourceMappingURL=base_interoperability_endpoint.js.map