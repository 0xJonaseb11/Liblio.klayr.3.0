"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MainchainInteroperabilityEndpoint = void 0;
const validator_1 = require("@klayr/validator");
const base_interoperability_endpoint_1 = require("../base_interoperability_endpoint");
const constants_1 = require("../constants");
const schemas_1 = require("../schemas");
const chain_account_1 = require("../stores/chain_account");
const own_chain_account_1 = require("../stores/own_chain_account");
const registered_names_1 = require("../stores/registered_names");
const utils_1 = require("../utils");
const errors_1 = require("../errors");
class MainchainInteroperabilityEndpoint extends base_interoperability_endpoint_1.BaseInteroperabilityEndpoint {
    getRegistrationFee() {
        return { fee: constants_1.CHAIN_REGISTRATION_FEE.toString() };
    }
    getMinimumMessageFee() {
        return {
            fee: constants_1.MIN_RETURN_FEE_PER_BYTE_BEDDOWS.toString(),
        };
    }
    async isChainIDAvailable(context) {
        validator_1.validator.validate(schemas_1.isChainIDAvailableRequestSchema, context.params);
        const chainID = Buffer.from(context.params.chainID, 'hex');
        const ownChainAccount = await this.stores.get(own_chain_account_1.OwnChainAccountStore).get(context, constants_1.EMPTY_BYTES);
        const networkID = chainID.subarray(0, 1);
        const ownChainNetworkID = ownChainAccount.chainID.subarray(0, 1);
        if (!networkID.equals(ownChainNetworkID)) {
            return {
                result: false,
            };
        }
        if (chainID.equals(ownChainAccount.chainID)) {
            return {
                result: false,
            };
        }
        const chainAccountStore = this.stores.get(chain_account_1.ChainAccountStore);
        const chainAccountExists = await chainAccountStore.has(context, chainID);
        return { result: !chainAccountExists };
    }
    async isChainNameAvailable(context) {
        validator_1.validator.validate(schemas_1.isChainNameAvailableRequestSchema, context.params);
        const name = context.params.name;
        if (!(0, utils_1.isValidName)(name)) {
            throw new errors_1.InvalidNameError();
        }
        const nameSubstore = this.stores.get(registered_names_1.RegisteredNamesStore);
        const nameExists = await nameSubstore.has(context, Buffer.from(name, 'ascii'));
        return {
            result: !nameExists,
        };
    }
}
exports.MainchainInteroperabilityEndpoint = MainchainInteroperabilityEndpoint;
//# sourceMappingURL=endpoint.js.map