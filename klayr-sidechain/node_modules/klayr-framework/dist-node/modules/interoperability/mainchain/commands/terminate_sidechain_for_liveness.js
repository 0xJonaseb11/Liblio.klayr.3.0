"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TerminateSidechainForLivenessCommand = void 0;
const state_machine_1 = require("../../../../state_machine");
const base_interoperability_command_1 = require("../../base_interoperability_command");
const schemas_1 = require("../../schemas");
const chain_account_1 = require("../../stores/chain_account");
class TerminateSidechainForLivenessCommand extends base_interoperability_command_1.BaseInteroperabilityCommand {
    constructor() {
        super(...arguments);
        this.schema = schemas_1.terminateSidechainForLivenessParamsSchema;
    }
    async verify(context) {
        const { params } = context;
        const chainAccount = await this.stores
            .get(chain_account_1.ChainAccountStore)
            .getOrUndefined(context, params.chainID);
        if (!chainAccount) {
            throw new Error('Chain account does not exist.');
        }
        if (chainAccount.status === 2) {
            throw new Error('Sidechain is already terminated.');
        }
        const live = await this.internalMethod.isLive(context, params.chainID, context.header.timestamp);
        if (live) {
            throw new Error('Sidechain did not violate the liveness condition.');
        }
        return {
            status: state_machine_1.VerifyStatus.OK,
        };
    }
    async execute(context) {
        const { params: { chainID }, } = context;
        await this.internalMethod.terminateChainInternal(context, chainID);
    }
}
exports.TerminateSidechainForLivenessCommand = TerminateSidechainForLivenessCommand;
//# sourceMappingURL=terminate_sidechain_for_liveness.js.map