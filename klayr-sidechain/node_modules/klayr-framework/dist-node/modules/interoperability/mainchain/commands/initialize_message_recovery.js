"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InitializeMessageRecoveryCommand = void 0;
const validator_1 = require("@klayr/validator");
const codec_1 = require("@klayr/codec");
const cryptography_1 = require("@klayr/cryptography");
const lisk_db_1 = require("@liskhq/lisk-db");
const types_1 = require("../../../../state_machine/types");
const base_interoperability_command_1 = require("../../base_interoperability_command");
const utils_1 = require("../../utils");
const constants_1 = require("../../constants");
const schemas_1 = require("../../schemas");
const own_chain_account_1 = require("../../stores/own_chain_account");
const chain_account_1 = require("../../stores/chain_account");
const terminated_state_1 = require("../../stores/terminated_state");
const channel_data_1 = require("../../stores/channel_data");
const terminated_outbox_1 = require("../../stores/terminated_outbox");
const invalid_smt_verification_1 = require("../../events/invalid_smt_verification");
class InitializeMessageRecoveryCommand extends base_interoperability_command_1.BaseInteroperabilityCommand {
    constructor() {
        super(...arguments);
        this.schema = schemas_1.messageRecoveryInitializationParamsSchema;
    }
    async verify(context) {
        const { params } = context;
        const deserializedChannel = codec_1.codec.decode(channel_data_1.channelSchema, params.channel);
        validator_1.validator.validate(channel_data_1.channelSchema, deserializedChannel);
        const ownchainAccount = await this.stores.get(own_chain_account_1.OwnChainAccountStore).get(context, constants_1.EMPTY_BYTES);
        const mainchainID = (0, utils_1.getMainchainID)(ownchainAccount.chainID);
        if (params.chainID.equals(mainchainID) || params.chainID.equals(ownchainAccount.chainID)) {
            return {
                status: types_1.VerifyStatus.FAIL,
                error: new Error('Chain ID is not valid.'),
            };
        }
        const chainAccountExist = await this.stores.get(chain_account_1.ChainAccountStore).has(context, params.chainID);
        if (!chainAccountExist) {
            return {
                status: types_1.VerifyStatus.FAIL,
                error: new Error('Chain is not registered.'),
            };
        }
        const terminatedAccountExists = await this.stores
            .get(terminated_state_1.TerminatedStateStore)
            .has(context, params.chainID);
        if (!terminatedAccountExists) {
            return {
                status: types_1.VerifyStatus.FAIL,
                error: new Error('Terminated state account not present.'),
            };
        }
        const terminatedOutboxAccountExists = await this.stores
            .get(terminated_outbox_1.TerminatedOutboxStore)
            .has(context, params.chainID);
        if (terminatedOutboxAccountExists) {
            return {
                status: types_1.VerifyStatus.FAIL,
                error: new Error('Terminated outbox account already exists.'),
            };
        }
        return {
            status: types_1.VerifyStatus.OK,
        };
    }
    async execute(context) {
        const { params } = context;
        const terminatedAccount = await this.stores
            .get(terminated_state_1.TerminatedStateStore)
            .get(context, params.chainID);
        const queryKey = Buffer.concat([
            this.stores.get(channel_data_1.ChannelDataStore).key,
            cryptography_1.utils.hash(context.chainID),
        ]);
        const query = {
            key: queryKey,
            value: cryptography_1.utils.hash(params.channel),
            bitmap: params.bitmap,
        };
        const smt = new lisk_db_1.SparseMerkleTree();
        const valid = await smt.verifyInclusionProof(terminatedAccount.stateRoot, [queryKey], {
            siblingHashes: params.siblingHashes,
            queries: [query],
        });
        if (!valid) {
            this.events.get(invalid_smt_verification_1.InvalidSMTVerificationEvent).error(context);
            throw new Error('Message recovery initialization proof of inclusion is not valid.');
        }
        const partnerChannel = codec_1.codec.decode(channel_data_1.channelSchema, params.channel);
        const channel = await this.stores.get(channel_data_1.ChannelDataStore).get(context, params.chainID);
        await this.internalMethod.createTerminatedOutboxAccount(context, params.chainID, channel.outbox.root, channel.outbox.size, partnerChannel.inbox.size);
    }
}
exports.InitializeMessageRecoveryCommand = InitializeMessageRecoveryCommand;
//# sourceMappingURL=initialize_message_recovery.js.map