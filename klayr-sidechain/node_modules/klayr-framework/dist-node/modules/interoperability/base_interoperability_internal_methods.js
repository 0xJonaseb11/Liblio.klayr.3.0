"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseInteroperabilityInternalMethod = void 0;
const codec_1 = require("@klayr/codec");
const lisk_db_1 = require("@liskhq/lisk-db");
const cryptography_1 = require("@klayr/cryptography");
const tree_1 = require("@klayr/tree");
const utils_1 = require("@klayr/utils");
const validator_1 = require("@klayr/validator");
const constants_1 = require("./constants");
const schemas_1 = require("./schemas");
const utils_2 = require("./utils");
const own_chain_account_1 = require("./stores/own_chain_account");
const channel_data_1 = require("./stores/channel_data");
const outbox_root_1 = require("./stores/outbox_root");
const terminated_state_1 = require("./stores/terminated_state");
const chain_account_1 = require("./stores/chain_account");
const terminated_outbox_1 = require("./stores/terminated_outbox");
const chain_account_updated_1 = require("./events/chain_account_updated");
const terminated_state_created_1 = require("./events/terminated_state_created");
const BaseInternalMethod_1 = require("../BaseInternalMethod");
const state_machine_1 = require("../../state_machine");
const chain_validators_1 = require("./stores/chain_validators");
const schema_1 = require("../../engine/consensus/certificate_generation/schema");
const ccm_send_fail_1 = require("./events/ccm_send_fail");
const ccm_send_success_1 = require("./events/ccm_send_success");
const constants_2 = require("../token/constants");
const terminated_outbox_created_1 = require("./events/terminated_outbox_created");
const utils_3 = require("../../engine/consensus/certificate_generation/utils");
const invalid_certificate_signature_1 = require("./events/invalid_certificate_signature");
const invalid_smt_verification_1 = require("./events/invalid_smt_verification");
const invalid_outbox_root_verification_1 = require("./events/invalid_outbox_root_verification");
class BaseInteroperabilityInternalMethod extends BaseInternalMethod_1.BaseInternalMethod {
    constructor(stores, events, interoperableModuleMethods) {
        super(stores, events);
        this.interoperableModuleMethods = new Map();
        this.interoperableModuleMethods = interoperableModuleMethods;
    }
    addDependencies(tokenMethod) {
        this._tokenMethod = tokenMethod;
    }
    async appendToInboxTree(context, chainID, appendData) {
        const channelSubstore = this.stores.get(channel_data_1.ChannelDataStore);
        const channel = await channelSubstore.get(context, chainID);
        const updatedInbox = tree_1.regularMerkleTree.calculateMerkleRoot({
            value: cryptography_1.utils.hash(appendData),
            appendPath: channel.inbox.appendPath,
            size: channel.inbox.size,
        });
        await channelSubstore.set(context, chainID, {
            ...channel,
            inbox: updatedInbox,
        });
    }
    async appendToOutboxTree(context, chainID, appendData) {
        const channelSubstore = this.stores.get(channel_data_1.ChannelDataStore);
        const channel = await channelSubstore.get(context, chainID);
        const updatedOutbox = tree_1.regularMerkleTree.calculateMerkleRoot({
            value: cryptography_1.utils.hash(appendData),
            appendPath: channel.outbox.appendPath,
            size: channel.outbox.size,
        });
        await channelSubstore.set(context, chainID, {
            ...channel,
            outbox: updatedOutbox,
        });
    }
    async addToOutbox(context, chainID, ccm) {
        const serializedMessage = codec_1.codec.encode(schemas_1.ccmSchema, ccm);
        await this.appendToOutboxTree(context, chainID, serializedMessage);
        const channelSubstore = this.stores.get(channel_data_1.ChannelDataStore);
        const channel = await channelSubstore.get(context, chainID);
        const outboxRootSubstore = this.stores.get(outbox_root_1.OutboxRootStore);
        await outboxRootSubstore.set(context, chainID, { root: channel.outbox.root });
    }
    async createTerminatedOutboxAccount(context, chainID, outboxRoot, outboxSize, partnerChainInboxSize) {
        const terminatedOutbox = {
            outboxRoot,
            outboxSize,
            partnerChainInboxSize,
        };
        const terminatedOutboxSubstore = this.stores.get(terminated_outbox_1.TerminatedOutboxStore);
        await terminatedOutboxSubstore.set(context, chainID, terminatedOutbox);
        this.events.get(terminated_outbox_created_1.TerminatedOutboxCreatedEvent).log(context, chainID, terminatedOutbox);
    }
    async setTerminatedOutboxAccount(context, chainID, params) {
        if (Object.keys(params).length === 0) {
            return false;
        }
        const terminatedOutboxSubstore = this.stores.get(terminated_outbox_1.TerminatedOutboxStore);
        const doesOutboxExist = await terminatedOutboxSubstore.has(context, chainID);
        if (!doesOutboxExist) {
            return false;
        }
        const account = await terminatedOutboxSubstore.get(context, chainID);
        const terminatedOutbox = {
            ...account,
            ...params,
        };
        await terminatedOutboxSubstore.set(context, chainID, terminatedOutbox);
        return true;
    }
    async createTerminatedStateAccount(context, chainID, stateRoot = constants_1.EMPTY_HASH) {
        const chainSubstore = this.stores.get(chain_account_1.ChainAccountStore);
        let terminatedState;
        const chainAccountExists = await chainSubstore.has(context, chainID);
        if (chainAccountExists) {
            const chainAccount = await chainSubstore.get(context, chainID);
            await chainSubstore.set(context, chainID, {
                ...chainAccount,
                status: 2,
            });
            this.events
                .get(chain_account_updated_1.ChainAccountUpdatedEvent)
                .log({ eventQueue: context.eventQueue }, chainID, chainAccount);
            const outboxRootSubstore = this.stores.get(outbox_root_1.OutboxRootStore);
            await outboxRootSubstore.del(context, chainID);
            terminatedState = {
                stateRoot: stateRoot.equals(constants_1.EMPTY_HASH)
                    ? chainAccount.lastCertificate.stateRoot
                    : stateRoot,
                mainchainStateRoot: constants_1.EMPTY_HASH,
                initialized: true,
            };
        }
        else {
            const ownChainAccount = await this.stores.get(own_chain_account_1.OwnChainAccountStore).get(context, constants_1.EMPTY_BYTES);
            const mainchainID = (0, utils_2.getMainchainID)(ownChainAccount.chainID);
            if (ownChainAccount.chainID.equals(mainchainID)) {
                throw new Error('Chain to be terminated is not valid.');
            }
            const mainchainAccount = await chainSubstore.get(context, mainchainID);
            if (stateRoot.equals(constants_1.EMPTY_HASH)) {
                terminatedState = {
                    stateRoot: constants_1.EMPTY_HASH,
                    mainchainStateRoot: mainchainAccount.lastCertificate.stateRoot,
                    initialized: false,
                };
            }
            else {
                terminatedState = {
                    stateRoot,
                    mainchainStateRoot: constants_1.EMPTY_HASH,
                    initialized: true,
                };
            }
        }
        const terminatedStateSubstore = this.stores.get(terminated_state_1.TerminatedStateStore);
        await terminatedStateSubstore.set(context, chainID, terminatedState);
        this.events
            .get(terminated_state_created_1.TerminatedStateCreatedEvent)
            .log({ eventQueue: context.eventQueue }, chainID, terminatedState);
    }
    async terminateChainInternal(context, chainID) {
        const terminatedStateSubstore = this.stores.get(terminated_state_1.TerminatedStateStore);
        const terminatedStateExists = await terminatedStateSubstore.has(context, chainID);
        if (terminatedStateExists) {
            return;
        }
        await this.sendInternal(context, constants_1.EMPTY_FEE_ADDRESS, constants_1.MODULE_NAME_INTEROPERABILITY, constants_1.CROSS_CHAIN_COMMAND_CHANNEL_TERMINATED, chainID, BigInt(0), constants_2.CCM_STATUS_OK, constants_1.EMPTY_BYTES);
        await this.createTerminatedStateAccount(context, chainID);
    }
    async updateValidators(context, ccu) {
        const chainValidatorsStore = this.stores.get(chain_validators_1.ChainValidatorsStore);
        const currentValidators = await chainValidatorsStore.get(context, ccu.sendingChainID);
        await chainValidatorsStore.set(context, ccu.sendingChainID, {
            activeValidators: (0, utils_2.calculateNewActiveValidators)(currentValidators.activeValidators, ccu.activeValidatorsUpdate.blsKeysUpdate, ccu.activeValidatorsUpdate.bftWeightsUpdate, ccu.activeValidatorsUpdate.bftWeightsUpdateBitmap),
            certificateThreshold: ccu.certificateThreshold,
        });
    }
    async updateCertificate(context, ccu) {
        const certificate = codec_1.codec.decode(schema_1.certificateSchema, ccu.certificate);
        validator_1.validator.validate(schema_1.certificateSchema, certificate);
        const chainAccountStore = this.stores.get(chain_account_1.ChainAccountStore);
        const chainAccount = await chainAccountStore.get(context, ccu.sendingChainID);
        const updatedChainAccount = {
            ...chainAccount,
            lastCertificate: {
                height: certificate.height,
                stateRoot: certificate.stateRoot,
                timestamp: certificate.timestamp,
                validatorsHash: certificate.validatorsHash,
            },
        };
        await chainAccountStore.set(context, ccu.sendingChainID, updatedChainAccount);
        this.events.get(chain_account_updated_1.ChainAccountUpdatedEvent).log(context, ccu.sendingChainID, updatedChainAccount);
    }
    async updatePartnerChainOutboxRoot(context, ccu) {
        await this.stores
            .get(channel_data_1.ChannelDataStore)
            .updatePartnerChainOutboxRoot(context, ccu.sendingChainID, ccu.inboxUpdate.messageWitnessHashes);
    }
    async verifyValidatorsUpdate(context, ccu) {
        var _a;
        if (ccu.certificate.length === 0) {
            throw new Error('Certificate must be non-empty if validators have been updated.');
        }
        const { bftWeightsUpdate, bftWeightsUpdateBitmap, blsKeysUpdate } = ccu.activeValidatorsUpdate;
        if (!utils_1.objects.isBufferArrayOrdered(blsKeysUpdate)) {
            throw new Error('Keys are not sorted in lexicographic order.');
        }
        const { activeValidators } = await this.stores
            .get(chain_validators_1.ChainValidatorsStore)
            .get(context, ccu.sendingChainID);
        const allBLSKeys = [...activeValidators.map(v => v.blsKey), ...blsKeysUpdate];
        allBLSKeys.sort((a, b) => a.compare(b));
        if (!utils_1.objects.bufferArrayUniqueItems(allBLSKeys)) {
            throw new Error('Keys have duplicated entry.');
        }
        const expectedBitmapLength = BigInt(allBLSKeys.length + 7) / BigInt(8);
        if (BigInt(bftWeightsUpdateBitmap.length) !== expectedBitmapLength) {
            throw new Error(`Invalid bftWeightsUpdateBitmap. Expected length ${expectedBitmapLength}.`);
        }
        const bftWeightsUpdateBitmapBin = BigInt(`0x${bftWeightsUpdateBitmap.toString('hex')}`);
        const expectedWeightLength = ((_a = bftWeightsUpdateBitmapBin.toString(2).match(/1/g)) !== null && _a !== void 0 ? _a : []).length;
        if (expectedWeightLength !== bftWeightsUpdate.length) {
            throw new Error('The number of 1s in the bitmap is not equal to the number of new BFT weights.');
        }
        let bftWeightIndex = 0;
        for (let i = 0; i < allBLSKeys.length; i += 1) {
            const blsKey = allBLSKeys[i];
            const digit = (bftWeightsUpdateBitmapBin >> BigInt(i)) & BigInt(1);
            if (utils_1.objects.bufferArrayIncludes(blsKeysUpdate, blsKey)) {
                if (digit !== BigInt(1)) {
                    throw new Error('New validators must have a BFT weight update.');
                }
                if (bftWeightsUpdate[bftWeightIndex] === BigInt(0)) {
                    throw new Error('New validators must have a positive BFT weight.');
                }
            }
            if (digit === BigInt(1)) {
                bftWeightIndex += 1;
            }
        }
        const newActiveValidators = (0, utils_2.calculateNewActiveValidators)(activeValidators, ccu.activeValidatorsUpdate.blsKeysUpdate, ccu.activeValidatorsUpdate.bftWeightsUpdate, ccu.activeValidatorsUpdate.bftWeightsUpdateBitmap);
        if (newActiveValidators.length < 1 || newActiveValidators.length > constants_1.MAX_NUM_VALIDATORS) {
            throw new Error(`Invalid validators array. It must have at least 1 element and at most ${constants_1.MAX_NUM_VALIDATORS} elements.`);
        }
        let totalWeight = BigInt(0);
        for (const currentValidator of newActiveValidators) {
            if (currentValidator.bftWeight === BigInt(0)) {
                throw new Error('Validator bft weight must be positive integer.');
            }
            totalWeight += currentValidator.bftWeight;
            if (totalWeight > constants_1.MAX_UINT64) {
                throw new Error('Total BFT weight exceeds maximum value.');
            }
        }
        const certificate = codec_1.codec.decode(schema_1.certificateSchema, ccu.certificate);
        validator_1.validator.validate(schema_1.certificateSchema, certificate);
        const { certificateThreshold } = ccu;
        if (certificateThreshold < totalWeight / BigInt(3) + BigInt(1)) {
            throw new Error('Certificate threshold is too small.');
        }
        if (certificateThreshold > totalWeight) {
            throw new Error('Certificate threshold is too large.');
        }
        const newValidatorsHash = (0, utils_2.computeValidatorsHash)(newActiveValidators, ccu.certificateThreshold);
        if (!certificate.validatorsHash.equals(newValidatorsHash)) {
            throw new Error('ValidatorsHash in certificate and the computed values do not match.');
        }
    }
    async verifyCertificate(context, params, blockTimestamp) {
        const certificate = codec_1.codec.decode(schema_1.certificateSchema, params.certificate);
        validator_1.validator.validate(schema_1.certificateSchema, certificate);
        const partnerchainAccount = await this.stores
            .get(chain_account_1.ChainAccountStore)
            .get(context, params.sendingChainID);
        if (certificate.height <= partnerchainAccount.lastCertificate.height) {
            throw new Error('Certificate height is not greater than last certificate height.');
        }
        if (certificate.timestamp >= blockTimestamp) {
            throw new Error('Certificate timestamp is not smaller than timestamp of the block including the CCU.');
        }
        const partnerchainValidators = await this.stores
            .get(chain_validators_1.ChainValidatorsStore)
            .get(context, params.sendingChainID);
        if (!certificate.validatorsHash.equals(partnerchainAccount.lastCertificate.validatorsHash) &&
            (0, utils_2.emptyActiveValidatorsUpdate)(params.activeValidatorsUpdate) &&
            params.certificateThreshold === partnerchainValidators.certificateThreshold) {
            throw new Error('Certifying an update to the validators hash requires an active validators update.');
        }
    }
    async verifyCertificateSignature(context, params) {
        const certificate = codec_1.codec.decode(schema_1.certificateSchema, params.certificate);
        validator_1.validator.validate(schema_1.certificateSchema, certificate);
        const chainValidators = await this.stores
            .get(chain_validators_1.ChainValidatorsStore)
            .get(context, params.sendingChainID);
        const verifySignature = (0, utils_3.verifyAggregateCertificateSignature)(chainValidators.activeValidators, chainValidators.certificateThreshold, params.sendingChainID, certificate);
        if (!verifySignature) {
            this.events
                .get(invalid_certificate_signature_1.InvalidCertificateSignatureEvent)
                .add(context, undefined, [params.sendingChainID], true);
            throw new Error('Certificate is not a valid aggregate signature.');
        }
    }
    async sendInternal(context, sendingAddress, module, crossChainCommand, receivingChainID, fee, status, params, timestamp) {
        const ownChainAccount = await this.stores.get(own_chain_account_1.OwnChainAccountStore).get(context, constants_1.EMPTY_BYTES);
        const ccm = {
            module,
            crossChainCommand,
            fee,
            nonce: ownChainAccount.nonce,
            params,
            receivingChainID,
            sendingChainID: ownChainAccount.chainID,
            status,
        };
        try {
            (0, utils_2.validateFormat)(ccm);
        }
        catch (error) {
            this.events.get(ccm_send_fail_1.CcmSentFailedEvent).log(context, {
                ccm: { ...ccm, params: constants_1.EMPTY_BYTES },
                code: 13,
            }, true);
            throw new Error('Invalid CCM format.');
        }
        if (receivingChainID.equals(ownChainAccount.chainID)) {
            this.events.get(ccm_send_fail_1.CcmSentFailedEvent).log(context, {
                ccm: { ...ccm, params: constants_1.EMPTY_BYTES },
                code: 14,
            }, true);
            throw new Error('Sending chain cannot be the receiving chain.');
        }
        let isReceivingChainLive;
        const mainchainID = (0, utils_2.getMainchainID)(ownChainAccount.chainID);
        if (ownChainAccount.chainID.equals(mainchainID)) {
            if (!timestamp) {
                throw new Error('Timestamp must be provided in mainchain context.');
            }
            isReceivingChainLive = await this.isLive(context, receivingChainID, timestamp);
        }
        else {
            isReceivingChainLive = await this.isLive(context, receivingChainID);
        }
        if (!isReceivingChainLive) {
            this.events.get(ccm_send_fail_1.CcmSentFailedEvent).log(context, {
                ccm: { ...ccm, params: constants_1.EMPTY_BYTES },
                code: 1,
            }, true);
            throw new Error('Receiving chain is not live.');
        }
        let receivingChainAccount;
        try {
            receivingChainAccount = await this.stores
                .get(chain_account_1.ChainAccountStore)
                .get(context, receivingChainID);
        }
        catch (error) {
            if (!(error instanceof state_machine_1.NotFoundError)) {
                throw error;
            }
        }
        if (fee > 0) {
            try {
                await this._tokenMethod.payMessageFee(context, sendingAddress, ccm.receivingChainID, fee);
            }
            catch (error) {
                this.events.get(ccm_send_fail_1.CcmSentFailedEvent).log(context, {
                    ccm: { ...ccm, params: constants_1.EMPTY_BYTES },
                    code: 11,
                }, true);
                throw new Error('Failed to pay message fee.');
            }
        }
        let partnerChainID;
        if (ownChainAccount.chainID.equals(mainchainID)) {
            partnerChainID = receivingChainID;
        }
        else {
            if (!receivingChainAccount) {
                partnerChainID = mainchainID;
            }
            else {
                partnerChainID = receivingChainID;
            }
        }
        if (receivingChainAccount && receivingChainAccount.status !== 1) {
            this.events.get(ccm_send_fail_1.CcmSentFailedEvent).log(context, {
                ccm: { ...ccm, params: constants_1.EMPTY_BYTES },
                code: 1,
            }, true);
            throw new Error('Receiving chain is not active.');
        }
        const { ccmID } = (0, utils_2.getEncodedCCMAndID)(ccm);
        await this.addToOutbox(context, partnerChainID, ccm);
        ownChainAccount.nonce += BigInt(1);
        await this.stores.get(own_chain_account_1.OwnChainAccountStore).set(context, constants_1.EMPTY_BYTES, ownChainAccount);
        this.events
            .get(ccm_send_success_1.CcmSendSuccessEvent)
            .log(context, ccm.sendingChainID, ccm.receivingChainID, ccmID, { ccm });
    }
    async getChainValidators(context, chainID) {
        const chainAccountStore = this.stores.get(chain_account_1.ChainAccountStore);
        const chainAccountExists = await chainAccountStore.has(context, chainID);
        if (!chainAccountExists) {
            throw new Error('Chain account does not exist.');
        }
        const chainValidatorsStore = this.stores.get(chain_validators_1.ChainValidatorsStore);
        const validators = await chainValidatorsStore.get(context, chainID);
        return validators;
    }
    verifyOutboxRootWitness(_context, params) {
        const { outboxRootWitness } = params.inboxUpdate;
        if (outboxRootWitness.bitmap.length === 0 && outboxRootWitness.siblingHashes.length > 0) {
            throw new Error('The bitmap in the outbox root witness must be non-empty if the sibling hashes are non-empty.');
        }
        if (outboxRootWitness.bitmap.length !== 0 && outboxRootWitness.siblingHashes.length === 0) {
            throw new Error('The sibling hashes in the outbox root witness must be non-empty if the bitmap is non-empty.');
        }
        if (outboxRootWitness.bitmap.length === 0 && params.certificate.length > 0) {
            throw new Error('The outbox root witness must be non-empty to authenticate the new partnerChainOutboxRoot.');
        }
        if (outboxRootWitness.bitmap.length !== 0 && params.certificate.length === 0) {
            throw new Error('The outbox root witness can be non-empty only if the certificate is non-empty.');
        }
    }
    async verifyPartnerChainOutboxRoot(context, params) {
        const channel = await this.stores.get(channel_data_1.ChannelDataStore).get(context, params.sendingChainID);
        let { appendPath, size } = channel.inbox;
        for (const ccm of params.inboxUpdate.crossChainMessages) {
            const updatedMerkleTree = tree_1.regularMerkleTree.calculateMerkleRoot({
                appendPath,
                size,
                value: cryptography_1.utils.hash(ccm),
            });
            appendPath = updatedMerkleTree.appendPath;
            size = updatedMerkleTree.size;
        }
        const newInboxRoot = tree_1.regularMerkleTree.calculateRootFromRightWitness(size, appendPath, params.inboxUpdate.messageWitnessHashes);
        const { outboxRootWitness } = params.inboxUpdate;
        if (params.certificate.length === 0) {
            if (!newInboxRoot.equals(channel.partnerChainOutboxRoot)) {
                this.events.get(invalid_outbox_root_verification_1.InvalidOutboxRootVerificationEvent).error(context, params.sendingChainID, {
                    inboxRoot: newInboxRoot,
                    partnerChainOutboxRoot: channel.partnerChainOutboxRoot,
                });
                throw new Error('Inbox root does not match partner chain outbox root.');
            }
            return;
        }
        const ownChainAccount = await this.stores.get(own_chain_account_1.OwnChainAccountStore).get(context, constants_1.EMPTY_BYTES);
        const outboxRootStore = this.stores.get(outbox_root_1.OutboxRootStore);
        const outboxKey = Buffer.concat([outboxRootStore.key, cryptography_1.utils.hash(ownChainAccount.chainID)]);
        const proof = {
            siblingHashes: outboxRootWitness.siblingHashes,
            queries: [
                {
                    key: outboxKey,
                    value: cryptography_1.utils.hash(codec_1.codec.encode(outbox_root_1.outboxRootSchema, { root: newInboxRoot })),
                    bitmap: outboxRootWitness.bitmap,
                },
            ],
        };
        const certificate = codec_1.codec.decode(schema_1.certificateSchema, params.certificate);
        validator_1.validator.validate(schema_1.certificateSchema, certificate);
        const smt = new lisk_db_1.SparseMerkleTree();
        const valid = await smt.verifyInclusionProof(certificate.stateRoot, [outboxKey], proof);
        if (!valid) {
            this.events.get(invalid_smt_verification_1.InvalidSMTVerificationEvent).error(context);
            throw new Error('Invalid inclusion proof for inbox update.');
        }
    }
}
exports.BaseInteroperabilityInternalMethod = BaseInteroperabilityInternalMethod;
//# sourceMappingURL=base_interoperability_internal_methods.js.map