"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseCCChannelTerminatedCommand = void 0;
const base_interoperability_cc_commands_1 = require("../base_interoperability_cc_commands");
const constants_1 = require("../constants");
const terminated_state_1 = require("../stores/terminated_state");
class BaseCCChannelTerminatedCommand extends base_interoperability_cc_commands_1.BaseInteroperabilityCCCommand {
    get name() {
        return constants_1.CROSS_CHAIN_COMMAND_CHANNEL_TERMINATED;
    }
    async execute(context) {
        if (!context.ccm) {
            throw new Error(`CCM to execute cross chain command '${constants_1.CROSS_CHAIN_COMMAND_CHANNEL_TERMINATED}' is missing.`);
        }
        if (context.ccm.status !== 0) {
            return;
        }
        const terminatedStateSubstore = this.stores.get(terminated_state_1.TerminatedStateStore);
        const { ccm: { sendingChainID }, } = context;
        const terminatedStateAccountExists = await terminatedStateSubstore.has(context, sendingChainID);
        if (terminatedStateAccountExists) {
            return;
        }
        await this.internalMethods.createTerminatedStateAccount(context, sendingChainID);
    }
}
exports.BaseCCChannelTerminatedCommand = BaseCCChannelTerminatedCommand;
//# sourceMappingURL=channel_terminated.js.map