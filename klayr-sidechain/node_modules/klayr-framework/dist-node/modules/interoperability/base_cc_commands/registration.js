"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseCCRegistrationCommand = void 0;
const codec_1 = require("@klayr/codec");
const constants_1 = require("../constants");
const schemas_1 = require("../schemas");
const base_interoperability_cc_commands_1 = require("../base_interoperability_cc_commands");
const chain_account_updated_1 = require("../events/chain_account_updated");
const own_chain_account_1 = require("../stores/own_chain_account");
const channel_data_1 = require("../stores/channel_data");
const chain_account_1 = require("../stores/chain_account");
const utils_1 = require("../utils");
class BaseCCRegistrationCommand extends base_interoperability_cc_commands_1.BaseInteroperabilityCCCommand {
    constructor() {
        super(...arguments);
        this.schema = schemas_1.registrationCCMParamsSchema;
    }
    get name() {
        return constants_1.CROSS_CHAIN_COMMAND_REGISTRATION;
    }
    async verify(ctx) {
        const { ccm } = ctx;
        if (!ccm) {
            throw new Error('CCM to execute registration cross chain command is missing.');
        }
        const ccuParams = codec_1.codec.decode(schemas_1.crossChainUpdateTransactionParams, ctx.transaction.params);
        const ccmRegistrationParams = codec_1.codec.decode(schemas_1.registrationCCMParamsSchema, ccm.params);
        const ownChainAccount = await this.stores.get(own_chain_account_1.OwnChainAccountStore).get(ctx, constants_1.EMPTY_BYTES);
        const chainAccount = await this.stores.get(chain_account_1.ChainAccountStore).get(ctx, ccm.sendingChainID);
        if (!chainAccount) {
            throw new Error('Registration message must be sent from a registered chain.');
        }
        if (!ccm.sendingChainID.equals(ccuParams.sendingChainID)) {
            throw new Error('Registration message must be sent from a direct channel.');
        }
        if (chainAccount.status !== 0) {
            throw new Error(`Registration message must be sent from a chain with status ${0}.`);
        }
        const channel = await this.stores.get(channel_data_1.ChannelDataStore).get(ctx, ccm.sendingChainID);
        if (channel.inbox.size !== 0) {
            throw new Error('Registration message must be the first message in the inbox.');
        }
        if (ccm.status !== 0) {
            throw new Error(`Registration message must have status ${0}.`);
        }
        if (!ownChainAccount.chainID.equals(ccm.receivingChainID)) {
            throw new Error('Registration message must be sent to the chain account ID of the chain.');
        }
        if (!ownChainAccount.chainID.equals(ccmRegistrationParams.chainID)) {
            throw new Error('Registration message must contain the chain ID of the receiving chain.');
        }
        if (ownChainAccount.name !== ccmRegistrationParams.name) {
            throw new Error('Registration message must contain the name of the registered chain.');
        }
        if (!channel.messageFeeTokenID.equals(ccmRegistrationParams.messageFeeTokenID)) {
            throw new Error('Registration message must contain the same message fee token ID as the channel account.');
        }
        if (channel.minReturnFeePerByte !== ccmRegistrationParams.minReturnFeePerByte) {
            throw new Error('Registration message must contain the same minimum return fee per byte as the channel account.');
        }
        const mainchainID = (0, utils_1.getMainchainID)(ctx.chainID);
        if (ownChainAccount.chainID.equals(mainchainID)) {
            if (ccm.nonce !== BigInt(0)) {
                throw new Error('Registration message must have nonce 0.');
            }
        }
    }
    async execute(ctx) {
        const { ccm } = ctx;
        if (!ccm) {
            throw new Error('CCM to execute registration cross chain command is missing.');
        }
        const chainAccount = await this.stores.get(chain_account_1.ChainAccountStore).get(ctx, ccm.sendingChainID);
        chainAccount.status = 1;
        await this.stores.get(chain_account_1.ChainAccountStore).set(ctx, ccm.sendingChainID, chainAccount);
        this.events.get(chain_account_updated_1.ChainAccountUpdatedEvent).log(ctx, ccm.sendingChainID, chainAccount);
    }
}
exports.BaseCCRegistrationCommand = BaseCCRegistrationCommand;
//# sourceMappingURL=registration.js.map