"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseInteroperabilityMethod = void 0;
const base_method_1 = require("../base_method");
const chain_account_1 = require("./stores/chain_account");
const constants_1 = require("./constants");
const own_chain_account_1 = require("./stores/own_chain_account");
const channel_data_1 = require("./stores/channel_data");
const terminated_state_1 = require("./stores/terminated_state");
const terminated_outbox_1 = require("./stores/terminated_outbox");
const utils_1 = require("./utils");
class BaseInteroperabilityMethod extends base_method_1.BaseMethod {
    constructor(stores, events, interoperableCCMethods = new Map(), internalMethod) {
        super(stores, events);
        this.interoperableCCMethods = interoperableCCMethods;
        this.internalMethod = internalMethod;
    }
    addDependencies(tokenMethod) {
        this._tokenMethod = tokenMethod;
    }
    async getChainAccount(context, chainID) {
        return this.stores.get(chain_account_1.ChainAccountStore).get(context, chainID);
    }
    async getChannel(context, chainID) {
        return this.stores.get(channel_data_1.ChannelDataStore).get(context, chainID);
    }
    async getOwnChainAccount(context) {
        return this.stores.get(own_chain_account_1.OwnChainAccountStore).get(context, constants_1.EMPTY_BYTES);
    }
    async getTerminatedStateAccount(context, chainID) {
        return this.stores.get(terminated_state_1.TerminatedStateStore).get(context, chainID);
    }
    async getTerminatedOutboxAccount(context, chainID) {
        return this.stores.get(terminated_outbox_1.TerminatedOutboxStore).get(context, chainID);
    }
    async _getChannelCommon(context, chainID) {
        const ownChainAccount = await this.getOwnChainAccount(context);
        if (chainID.equals(ownChainAccount.chainID)) {
            throw new Error('Channel with own chain account does not exist.');
        }
        const mainchainID = (0, utils_1.getMainchainID)(chainID);
        const hasChainAccount = await this.stores.get(chain_account_1.ChainAccountStore).has(context, chainID);
        let updatedChainID = chainID;
        if (!ownChainAccount.chainID.equals(mainchainID) && !hasChainAccount) {
            updatedChainID = mainchainID;
        }
        const hasChannel = await this.stores.get(channel_data_1.ChannelDataStore).has(context, updatedChainID);
        if (!hasChannel) {
            throw new Error('Channel does not exist.');
        }
        return this.getChannel(context, updatedChainID);
    }
    async getMessageFeeTokenID(context, chainID) {
        const channel = await this._getChannelCommon(context, chainID);
        return channel.messageFeeTokenID;
    }
    async getMessageFeeTokenIDFromCCM(context, ccm) {
        return this.getMessageFeeTokenID(context, ccm.sendingChainID);
    }
    async getMinReturnFeePerByte(context, chainID) {
        const channel = await this._getChannelCommon(context, chainID);
        return channel.minReturnFeePerByte;
    }
    async send(context, sendingAddress, module, crossChainCommand, receivingChainID, fee, params, timestamp) {
        await this.internalMethod.sendInternal(context, sendingAddress, module, crossChainCommand, receivingChainID, fee, 0, params, timestamp);
    }
    async error(context, ccm, errorStatus) {
        if (errorStatus >= 0 && errorStatus <= constants_1.MAX_RESERVED_ERROR_STATUS) {
            throw new Error(`Error codes from 0 to ${constants_1.MAX_RESERVED_ERROR_STATUS} (inclusive) are reserved to the Interoperability module.`);
        }
        await this.send(context, constants_1.EMPTY_FEE_ADDRESS, ccm.module, ccm.crossChainCommand, ccm.sendingChainID, BigInt(0), ccm.params);
    }
    async terminateChain(context, chainID) {
        if (await this.stores.get(terminated_state_1.TerminatedStateStore).has(context, chainID)) {
            return;
        }
        await this.internalMethod.sendInternal(context, constants_1.EMPTY_FEE_ADDRESS, constants_1.MODULE_NAME_INTEROPERABILITY, constants_1.CROSS_CHAIN_COMMAND_CHANNEL_TERMINATED, chainID, BigInt(0), 0, constants_1.EMPTY_BYTES);
        await this.internalMethod.createTerminatedStateAccount(context, chainID);
    }
}
exports.BaseInteroperabilityMethod = BaseInteroperabilityMethod;
//# sourceMappingURL=base_interoperability_method.js.map