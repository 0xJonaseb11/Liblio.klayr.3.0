"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidatorsEndpoint = void 0;
const cryptography_1 = require("@klayr/cryptography");
const validator_1 = require("@klayr/validator");
const lisk_db_1 = require("@liskhq/lisk-db");
const base_endpoint_1 = require("../base_endpoint");
const schemas_1 = require("./schemas");
const bls_keys_1 = require("./stores/bls_keys");
const validator_keys_1 = require("./stores/validator_keys");
class ValidatorsEndpoint extends base_endpoint_1.BaseEndpoint {
    async validateBLSKey(ctx) {
        validator_1.validator.validate(schemas_1.validateBLSKeyRequestSchema, ctx.params);
        const { proofOfPossession, blsKey } = ctx.params;
        const blsKeyStore = this.stores.get(bls_keys_1.BLSKeyStore);
        if (await blsKeyStore.has(ctx, Buffer.from(blsKey, 'hex'))) {
            return { valid: false };
        }
        return {
            valid: cryptography_1.bls.popVerify(Buffer.from(blsKey, 'hex'), Buffer.from(proofOfPossession, 'hex')),
        };
    }
    async getValidator(ctx) {
        validator_1.validator.validate(schemas_1.getValidatorRequestSchema, ctx.params);
        const validatorsKeysStore = this.stores.get(validator_keys_1.ValidatorKeysStore);
        let validatorKeys;
        try {
            validatorKeys = await validatorsKeysStore.get(ctx, cryptography_1.address.getAddressFromKlayr32Address(ctx.params.address));
        }
        catch (error) {
            if (!(error instanceof lisk_db_1.NotFoundError)) {
                throw error;
            }
            return {
                generatorKey: '',
                blsKey: '',
            };
        }
        return {
            generatorKey: validatorKeys.generatorKey.toString('hex'),
            blsKey: validatorKeys.blsKey.toString('hex'),
        };
    }
}
exports.ValidatorsEndpoint = ValidatorsEndpoint;
//# sourceMappingURL=endpoint.js.map