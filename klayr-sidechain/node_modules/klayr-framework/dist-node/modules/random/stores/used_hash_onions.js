"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsedHashOnionsStore = exports.usedHashOnionsStoreSchema = void 0;
const base_offchain_store_1 = require("../../base_offchain_store");
const state_machine_1 = require("../../../state_machine");
exports.usedHashOnionsStoreSchema = {
    title: 'Used hash onion',
    $id: '/node/forger/usedHashOnion',
    type: 'object',
    required: ['usedHashOnions'],
    properties: {
        usedHashOnions: {
            type: 'array',
            fieldNumber: 1,
            items: {
                type: 'object',
                required: ['count', 'height'],
                properties: {
                    count: {
                        dataType: 'uint32',
                        fieldNumber: 1,
                    },
                    height: {
                        dataType: 'uint32',
                        fieldNumber: 2,
                    },
                },
            },
        },
    },
};
class UsedHashOnionsStore extends base_offchain_store_1.BaseOffchainStore {
    constructor() {
        super(...arguments);
        this.schema = exports.usedHashOnionsStoreSchema;
    }
    async getLatest(ctx, address, height) {
        try {
            const { usedHashOnions } = await this.get(ctx, address);
            return usedHashOnions.reduce((prev, curr) => {
                if (height === undefined) {
                    if (!prev || prev.height < curr.height) {
                        return curr;
                    }
                    return prev;
                }
                if (curr.height < height && (!prev || prev.height < curr.height)) {
                    return curr;
                }
                return prev;
            }, undefined);
        }
        catch (error) {
            if (error instanceof state_machine_1.NotFoundError) {
                return undefined;
            }
            throw error;
        }
    }
    async setLatest(ctx, finalizedHeight, address, usedHashOnion, originalUsedHashOnions) {
        const index = originalUsedHashOnions.findIndex(hashOnion => hashOnion.count === usedHashOnion.count);
        if (index === -1) {
            if (usedHashOnion.count === 0) {
                const newUsedHashOnions = [usedHashOnion];
                await this.set(ctx, address, this._filterUsedHashOnions(newUsedHashOnions, finalizedHeight));
                return;
            }
            originalUsedHashOnions.push(usedHashOnion);
        }
        else {
            originalUsedHashOnions[index] = usedHashOnion;
        }
        await this.set(ctx, address, this._filterUsedHashOnions(originalUsedHashOnions, finalizedHeight));
    }
    _filterUsedHashOnions(usedHashOnions, finalizedHeight) {
        const filteredObject = usedHashOnions.reduce(({ others, highest }, current) => {
            if (highest === null) {
                return {
                    highest: current,
                    others,
                };
            }
            if (highest.height < current.height) {
                others.push(highest);
                return {
                    highest: current,
                    others,
                };
            }
            others.push(current);
            return {
                highest,
                others,
            };
        }, {
            others: [],
            highest: null,
        });
        const filtered = filteredObject.others.filter(ho => ho.height > finalizedHeight);
        filtered.push(filteredObject.highest);
        return {
            usedHashOnions: filtered,
        };
    }
}
exports.UsedHashOnionsStore = UsedHashOnionsStore;
//# sourceMappingURL=used_hash_onions.js.map