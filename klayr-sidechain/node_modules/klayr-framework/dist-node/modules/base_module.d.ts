import { Schema } from '@klayr/codec';
import { GenesisConfig } from '../types';
import { BaseCommand } from './base_command';
import { BaseEndpoint } from './base_endpoint';
import { BaseMethod } from './base_method';
import { InsertAssetContext, BlockAfterExecuteContext, BlockExecuteContext, GenesisBlockExecuteContext, TransactionExecuteContext, TransactionVerifyContext, BlockVerifyContext, VerificationResult } from '../state_machine/types';
import { NamedRegistry } from './named_registry';
export interface ModuleInitArgs {
    genesisConfig: Omit<GenesisConfig, 'modules'>;
    moduleConfig: Record<string, unknown>;
}
export interface ModuleMetadata {
    endpoints: {
        name: string;
        request?: Schema;
        response?: Schema;
    }[];
    events: {
        name: string;
        data: Schema;
    }[];
    commands: {
        name: string;
        params: Schema;
    }[];
    assets: {
        version: number;
        data: Schema;
    }[];
    stores: {
        key: string;
        data?: Schema;
    }[];
}
export type ModuleMetadataJSON = ModuleMetadata & {
    name: string;
};
export declare abstract class BaseModule {
    commands: BaseCommand[];
    events: NamedRegistry;
    stores: NamedRegistry;
    offchainStores: NamedRegistry;
    get name(): string;
    abstract endpoint: BaseEndpoint;
    abstract method: BaseMethod;
    init?(args: ModuleInitArgs): Promise<void>;
    insertAssets?(context: InsertAssetContext): Promise<void>;
    verifyAssets?(context: BlockVerifyContext): Promise<void>;
    verifyTransaction?(context: TransactionVerifyContext): Promise<VerificationResult>;
    beforeCommandExecute?(context: TransactionExecuteContext): Promise<void>;
    afterCommandExecute?(context: TransactionExecuteContext): Promise<void>;
    initGenesisState?(context: GenesisBlockExecuteContext): Promise<void>;
    finalizeGenesisState?(context: GenesisBlockExecuteContext): Promise<void>;
    beforeTransactionsExecute?(context: BlockExecuteContext): Promise<void>;
    afterTransactionsExecute?(context: BlockAfterExecuteContext): Promise<void>;
    abstract metadata(): ModuleMetadata;
    protected baseMetadata(): {
        commands: {
            name: string;
            params: Schema;
        }[];
        events: {
            name: string;
            data: Schema;
        }[];
        stores: {
            key: string;
            data: Schema;
        }[];
        endpoints: never[];
        assets: never[];
    };
}
