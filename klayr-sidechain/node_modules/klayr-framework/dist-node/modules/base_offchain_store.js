"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseOffchainStore = void 0;
const cryptography_1 = require("@klayr/cryptography");
class BaseOffchainStore {
    get key() {
        return Buffer.concat([this._storePrefix, this._subStorePrefix]);
    }
    get name() {
        const name = this.constructor.name.replace('Store', '');
        return name.charAt(0).toLowerCase() + name.substr(1);
    }
    constructor(moduleName, version = 0) {
        this._version = version;
        this._storePrefix = cryptography_1.utils.hash(Buffer.from(moduleName, 'utf-8')).subarray(0, 4);
        this._storePrefix[0] &= 0x7f;
        const versionBuffer = Buffer.alloc(2);
        versionBuffer.writeUInt16BE(this._version, 0);
        this._subStorePrefix = cryptography_1.utils
            .hash(Buffer.concat([Buffer.from(this.name, 'utf-8'), versionBuffer]))
            .subarray(0, 2);
    }
    async get(ctx, key) {
        if (!this.schema) {
            throw new Error('Schema is not set');
        }
        const subStore = ctx.getOffchainStore(this._storePrefix, this._subStorePrefix);
        return subStore.getWithSchema(key, this.schema);
    }
    async has(ctx, key) {
        if (!this.schema) {
            throw new Error('Schema is not set');
        }
        const subStore = ctx.getOffchainStore(this._storePrefix, this._subStorePrefix);
        return subStore.has(key);
    }
    async iterate(ctx, options) {
        if (!this.schema) {
            throw new Error('Schema is not set');
        }
        const subStore = ctx.getOffchainStore(this._storePrefix, this._subStorePrefix);
        return subStore.iterateWithSchema(options, this.schema);
    }
    async set(ctx, key, value) {
        if (!this.schema) {
            throw new Error('Schema is not set');
        }
        const subStore = ctx.getOffchainStore(this._storePrefix, this._subStorePrefix);
        return subStore.setWithSchema(key, value, this.schema);
    }
    async del(ctx, key) {
        if (!this.schema) {
            throw new Error('Schema is not set');
        }
        const subStore = ctx.getOffchainStore(this._storePrefix, this._subStorePrefix);
        return subStore.del(key);
    }
}
exports.BaseOffchainStore = BaseOffchainStore;
//# sourceMappingURL=base_offchain_store.js.map