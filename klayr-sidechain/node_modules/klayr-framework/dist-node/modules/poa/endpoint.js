"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoAEndpoint = void 0;
const validator_1 = require("@klayr/validator");
const cryptography_1 = require("@klayr/cryptography");
const lisk_db_1 = require("@liskhq/lisk-db");
const base_endpoint_1 = require("../base_endpoint");
const validator_2 = require("./stores/validator");
const constants_1 = require("./constants");
const stores_1 = require("./stores");
const schemas_1 = require("./schemas");
class PoAEndpoint extends base_endpoint_1.BaseEndpoint {
    init(authorityRegistrationFee) {
        this._authorityRegistrationFee = authorityRegistrationFee;
    }
    async getValidator(context) {
        const validatorSubStore = this.stores.get(validator_2.ValidatorStore);
        validator_1.validator.validate(schemas_1.getValidatorRequestSchema, context.params);
        const address = context.params.address;
        cryptography_1.address.validateKlayr32Address(address);
        let validatorName;
        try {
            validatorName = await validatorSubStore.get(context, cryptography_1.address.getAddressFromKlayr32Address(address));
        }
        catch (error) {
            if (!(error instanceof lisk_db_1.NotFoundError)) {
                throw error;
            }
            throw new Error(`Validator not found in snapshot for address ${address}`);
        }
        const snapshotStore = this.stores.get(stores_1.SnapshotStore);
        const currentRoundSnapshot = await snapshotStore.get(context, constants_1.KEY_SNAPSHOT_0);
        const validatorInfo = currentRoundSnapshot.validators.find(v => cryptography_1.address.getKlayr32AddressFromAddress(v.address) === address);
        if (!validatorInfo) {
            throw new Error(`Validator not found in snapshot for address ${address}`);
        }
        return {
            ...validatorName,
            address,
            weight: validatorInfo.weight.toString(),
        };
    }
    async getAllValidators(context) {
        const validatorStore = this.stores.get(validator_2.ValidatorStore);
        const startBuf = Buffer.alloc(constants_1.NUM_BYTES_ADDRESS);
        const endBuf = Buffer.alloc(constants_1.NUM_BYTES_ADDRESS, 255);
        const validatorStoreData = await validatorStore.iterate(context, {
            gte: startBuf,
            lte: endBuf,
        });
        const snapshotStore = this.stores.get(stores_1.SnapshotStore);
        const currentRoundSnapshot = await snapshotStore.get(context, constants_1.KEY_SNAPSHOT_0);
        const validatorsData = [];
        for (const data of validatorStoreData) {
            const address = cryptography_1.address.getKlayr32AddressFromAddress(data.key);
            const { value } = data;
            const activeValidator = currentRoundSnapshot.validators.find(v => cryptography_1.address.getKlayr32AddressFromAddress(v.address) === address);
            const v = {
                name: value.name,
                address,
                weight: activeValidator ? activeValidator.weight.toString() : '0',
            };
            validatorsData.push(v);
        }
        validatorsData.sort((v1, v2) => v1.name.localeCompare(v2.name, 'en'));
        return { validators: validatorsData };
    }
    getRegistrationFee() {
        return {
            fee: this._authorityRegistrationFee.toString(),
        };
    }
}
exports.PoAEndpoint = PoAEndpoint;
//# sourceMappingURL=endpoint.js.map