"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoAModule = void 0;
const codec_1 = require("@klayr/codec");
const utils_1 = require("@klayr/utils");
const validator_1 = require("@klayr/validator");
const base_module_1 = require("../base_module");
const method_1 = require("./method");
const endpoint_1 = require("./endpoint");
const authority_update_1 = require("./events/authority_update");
const stores_1 = require("./stores");
const constants_1 = require("./constants");
const utils_2 = require("../utils");
const schemas_1 = require("./schemas");
const register_authority_1 = require("./commands/register_authority");
const update_authority_1 = require("./commands/update_authority");
const update_generator_key_1 = require("./commands/update_generator_key");
class PoAModule extends base_module_1.BaseModule {
    constructor() {
        super();
        this.method = new method_1.PoAMethod(this.stores, this.events);
        this.endpoint = new endpoint_1.PoAEndpoint(this.stores, this.offchainStores);
        this._registerAuthorityCommand = new register_authority_1.RegisterAuthorityCommand(this.stores, this.events);
        this._updateAuthorityCommand = new update_authority_1.UpdateAuthorityCommand(this.stores, this.events);
        this._updateGeneratorKeyCommand = new update_generator_key_1.UpdateGeneratorKeyCommand(this.stores, this.events);
        this.commands = [
            this._registerAuthorityCommand,
            this._updateAuthorityCommand,
            this._updateGeneratorKeyCommand,
        ];
        this.events.register(authority_update_1.AuthorityUpdateEvent, new authority_update_1.AuthorityUpdateEvent(this.name));
        this.stores.register(stores_1.ValidatorStore, new stores_1.ValidatorStore(this.name, constants_1.SUBSTORE_PREFIX_VALIDATOR_INDEX));
        this.stores.register(stores_1.ChainPropertiesStore, new stores_1.ChainPropertiesStore(this.name, constants_1.SUBSTORE_PREFIX_CHAIN_INDEX));
        this.stores.register(stores_1.NameStore, new stores_1.NameStore(this.name, constants_1.SUBSTORE_PREFIX_NAME_INDEX));
        this.stores.register(stores_1.SnapshotStore, new stores_1.SnapshotStore(this.name, constants_1.SUBSTORE_PREFIX_SNAPSHOT_INDEX));
    }
    get name() {
        return constants_1.MODULE_NAME_POA;
    }
    addDependencies(validatorsMethod, feeMethod, randomMethod) {
        this._validatorsMethod = validatorsMethod;
        this._feeMethod = feeMethod;
        this._randomMethod = randomMethod;
        this._registerAuthorityCommand.addDependencies(this._validatorsMethod, this._feeMethod);
        this._updateAuthorityCommand.addDependencies(this._validatorsMethod);
        this._updateGeneratorKeyCommand.addDependencies(this._validatorsMethod);
    }
    metadata() {
        return {
            ...this.baseMetadata(),
            endpoints: [
                {
                    name: this.endpoint.getValidator.name,
                    request: schemas_1.getValidatorRequestSchema,
                    response: schemas_1.getValidatorResponseSchema,
                },
                {
                    name: this.endpoint.getAllValidators.name,
                    response: schemas_1.getAllValidatorsResponseSchema,
                },
                {
                    name: this.endpoint.getRegistrationFee.name,
                    response: schemas_1.getRegistrationFeeResponseSchema,
                },
            ],
            assets: [],
        };
    }
    async init(args) {
        const config = utils_1.objects.mergeDeep({}, { ...constants_1.defaultConfig }, args.moduleConfig);
        validator_1.validator.validate(schemas_1.configSchema, config);
        this._moduleConfig = {
            ...config,
            authorityRegistrationFee: BigInt(config.authorityRegistrationFee),
        };
        this._registerAuthorityCommand.init(this._moduleConfig);
        this.endpoint.init(this._moduleConfig.authorityRegistrationFee);
    }
    async afterTransactionsExecute(context) {
        const chainPropertiesStore = this.stores.get(stores_1.ChainPropertiesStore);
        const chainProperties = await chainPropertiesStore.get(context, constants_1.EMPTY_BYTES);
        if (context.header.height === chainProperties.roundEndHeight) {
            const snapshotStore = this.stores.get(stores_1.SnapshotStore);
            const snapshot0 = await snapshotStore.get(context, constants_1.KEY_SNAPSHOT_0);
            const previousLengthValidators = snapshot0.validators.length;
            const snapshot1 = await snapshotStore.get(context, constants_1.KEY_SNAPSHOT_1);
            await snapshotStore.set(context, constants_1.KEY_SNAPSHOT_0, snapshot1);
            const snapshot2 = await snapshotStore.get(context, constants_1.KEY_SNAPSHOT_2);
            await snapshotStore.set(context, constants_1.KEY_SNAPSHOT_1, snapshot2);
            const roundStartHeight = chainProperties.roundEndHeight - previousLengthValidators + 1;
            const randomSeed = await this._randomMethod.getRandomBytes(context, roundStartHeight, previousLengthValidators);
            const nextValidators = (0, utils_2.shuffleValidatorList)(randomSeed, snapshot1.validators);
            await this._validatorsMethod.setValidatorsParams(context, context, snapshot1.threshold, snapshot1.threshold, nextValidators.map(v => ({
                address: v.address,
                bftWeight: v.weight,
            })));
            chainProperties.roundEndHeight += snapshot1.validators.length;
            await chainPropertiesStore.set(context, constants_1.EMPTY_BYTES, chainProperties);
        }
    }
    async initGenesisState(context) {
        const genesisBlockAssetBytes = context.assets.getAsset(constants_1.MODULE_NAME_POA);
        if (!genesisBlockAssetBytes) {
            return;
        }
        const asset = codec_1.codec.decode(schemas_1.genesisPoAStoreSchema, genesisBlockAssetBytes);
        validator_1.validator.validate(schemas_1.genesisPoAStoreSchema, asset);
        const { validators, snapshotSubstore } = asset;
        const validatorNames = validators.map(v => v.name);
        if (validatorNames.length !== new Set(validatorNames).size) {
            throw new Error('`name` property of all entries in the validators must be distinct.');
        }
        const validatorAddresses = validators.map(v => v.address);
        if (!utils_1.objects.bufferArrayUniqueItems(validatorAddresses)) {
            throw new Error('`address` property of all entries in validators must be distinct.');
        }
        if (!utils_1.objects.isBufferArrayOrdered(validatorAddresses)) {
            throw new Error('`validators` must be ordered lexicographically by address.');
        }
        for (const poaValidator of validators) {
            if (!constants_1.POA_VALIDATOR_NAME_REGEX.test(poaValidator.name)) {
                throw new Error('`name` property is invalid. Must contain only characters a-z0-9!@$&_.');
            }
        }
        const { activeValidators, threshold } = snapshotSubstore;
        const activeValidatorAddresses = activeValidators.map(v => v.address);
        const validatorAddressesString = validatorAddresses.map(a => a.toString('hex'));
        let totalWeight = BigInt(0);
        if (!utils_1.objects.bufferArrayUniqueItems(activeValidatorAddresses)) {
            throw new Error('`address` properties in `activeValidators` must be distinct.');
        }
        if (!utils_1.objects.isBufferArrayOrdered(activeValidatorAddresses)) {
            throw new Error('`activeValidators` must be ordered lexicographically by address property.');
        }
        for (const activeValidator of activeValidators) {
            if (!validatorAddressesString.includes(activeValidator.address.toString('hex'))) {
                throw new Error('`activeValidator` address is missing from validators array.');
            }
            if (activeValidator.weight <= BigInt(0)) {
                throw new Error('`activeValidators` weight must be positive integer.');
            }
            totalWeight += activeValidator.weight;
        }
        if (totalWeight > constants_1.MAX_UINT64) {
            throw new Error('Total weight `activeValidators` exceeds maximum value.');
        }
        if (threshold < totalWeight / BigInt(3) + BigInt(1) || threshold > totalWeight) {
            throw new Error('`threshold` in snapshot substore is not within range.');
        }
        const validatorStore = this.stores.get(stores_1.ValidatorStore);
        const nameStore = this.stores.get(stores_1.NameStore);
        for (const currentValidator of validators) {
            await validatorStore.set(context, currentValidator.address, { name: currentValidator.name });
            await nameStore.set(context, Buffer.from(currentValidator.name, 'utf-8'), {
                address: currentValidator.address,
            });
        }
        const snapshotStore = this.stores.get(stores_1.SnapshotStore);
        await snapshotStore.set(context, constants_1.KEY_SNAPSHOT_0, {
            ...snapshotSubstore,
            validators: activeValidators,
        });
        await snapshotStore.set(context, constants_1.KEY_SNAPSHOT_1, {
            ...snapshotSubstore,
            validators: activeValidators,
        });
        await snapshotStore.set(context, constants_1.KEY_SNAPSHOT_2, {
            ...snapshotSubstore,
            validators: activeValidators,
        });
        const { header } = context;
        const chainPropertiesStore = this.stores.get(stores_1.ChainPropertiesStore);
        await chainPropertiesStore.set(context, constants_1.EMPTY_BYTES, {
            roundEndHeight: header.height,
            validatorsUpdateNonce: 0,
        });
    }
    async finalizeGenesisState(context) {
        const genesisBlockAssetBytes = context.assets.getAsset(constants_1.MODULE_NAME_POA);
        if (!genesisBlockAssetBytes) {
            return;
        }
        const asset = codec_1.codec.decode(schemas_1.genesisPoAStoreSchema, genesisBlockAssetBytes);
        const snapshotStore = this.stores.get(stores_1.SnapshotStore);
        const currentRoundSnapshot = await snapshotStore.get(context, constants_1.KEY_SNAPSHOT_0);
        const chainPropertiesStore = this.stores.get(stores_1.ChainPropertiesStore);
        const chainProperties = await chainPropertiesStore.get(context, constants_1.EMPTY_BYTES);
        await chainPropertiesStore.set(context, constants_1.EMPTY_BYTES, {
            ...chainProperties,
            roundEndHeight: chainProperties.roundEndHeight + currentRoundSnapshot.validators.length,
        });
        const methodContext = context.getMethodContext();
        for (const v of asset.validators) {
            await this._validatorsMethod.registerValidatorKeys(methodContext, v.address, v.blsKey, v.generatorKey, v.proofOfPossession);
        }
        await this._validatorsMethod.setValidatorsParams(methodContext, context, currentRoundSnapshot.threshold, currentRoundSnapshot.threshold, currentRoundSnapshot.validators.map(v => ({ address: v.address, bftWeight: v.weight })));
    }
}
exports.PoAModule = PoAModule;
//# sourceMappingURL=module.js.map