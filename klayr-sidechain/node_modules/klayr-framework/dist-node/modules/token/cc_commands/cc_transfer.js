"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrossChainTransferCommand = void 0;
const codec_1 = require("@klayr/codec");
const base_cc_command_1 = require("../../interoperability/base_cc_command");
const constants_1 = require("../constants");
const schemas_1 = require("../schemas");
const utils_1 = require("../utils");
const supported_tokens_1 = require("../stores/supported_tokens");
const ccm_transfer_1 = require("../events/ccm_transfer");
const user_1 = require("../stores/user");
const escrow_1 = require("../stores/escrow");
const constants_2 = require("../../interoperability/constants");
class CrossChainTransferCommand extends base_cc_command_1.BaseCCCommand {
    constructor() {
        super(...arguments);
        this.schema = schemas_1.crossChainTransferMessageParams;
    }
    get name() {
        return constants_1.CROSS_CHAIN_COMMAND_NAME_TRANSFER;
    }
    init(args) {
        this._tokenMethod = args.tokenMethod;
        this._internalMethod = args.internalMethod;
    }
    async verify(ctx) {
        const { ccm } = ctx;
        const methodContext = ctx.getMethodContext();
        const { sendingChainID } = ccm;
        const params = codec_1.codec.decode(schemas_1.crossChainTransferMessageParams, ccm.params);
        if (ccm.status > constants_2.MAX_RESERVED_ERROR_STATUS) {
            throw new Error('Invalid CCM status code.');
        }
        const { tokenID, amount } = params;
        const [tokenChainID] = (0, utils_1.splitTokenID)(tokenID);
        if (!tokenChainID.equals(ctx.chainID) && !tokenChainID.equals(sendingChainID)) {
            throw new Error('Token must be native to either the sending or the receiving chain.');
        }
        if (tokenChainID.equals(ctx.chainID)) {
            const escrowedAmount = await this._tokenMethod.getEscrowedAmount(methodContext, sendingChainID, tokenID);
            if (escrowedAmount < amount) {
                throw new Error('Insufficient balance in escrow account.');
            }
        }
    }
    async execute(ctx) {
        const { ccm } = ctx;
        const methodContext = ctx.getMethodContext();
        const { sendingChainID, status, receivingChainID } = ccm;
        let recipientAddress;
        const params = codec_1.codec.decode(schemas_1.crossChainTransferMessageParams, ccm.params);
        const { tokenID, amount, senderAddress } = params;
        recipientAddress = params.recipientAddress;
        const [tokenChainID] = (0, utils_1.splitTokenID)(tokenID);
        this.stores.get(supported_tokens_1.SupportedTokensStore).registerOwnChainID(ctx.chainID);
        const supported = await this.stores.get(supported_tokens_1.SupportedTokensStore).isSupported(ctx, tokenID);
        if (!supported) {
            this.events.get(ccm_transfer_1.CcmTransferEvent).error(ctx, {
                senderAddress,
                recipientAddress,
                tokenID,
                amount,
                receivingChainID,
            }, 4);
            throw new Error(`tokenID ${tokenID.toString('hex')} is not supported`);
        }
        if (status !== constants_1.CCM_STATUS_OK) {
            recipientAddress = senderAddress;
        }
        const userStore = this.stores.get(user_1.UserStore);
        const recipientExist = await userStore.has(methodContext, userStore.getKey(recipientAddress, tokenID));
        if (!recipientExist) {
            await this._internalMethod.initializeUserAccount(ctx.getMethodContext(), recipientAddress, tokenID);
        }
        if (tokenChainID.equals(ctx.chainID)) {
            const escrowStore = this.stores.get(escrow_1.EscrowStore);
            const escrowKey = escrowStore.getKey(sendingChainID, tokenID);
            const escrowData = await escrowStore.get(methodContext, escrowKey);
            if (escrowData.amount < amount) {
                throw new Error('Insufficient balance in escrow account.');
            }
            escrowData.amount -= amount;
            await escrowStore.set(methodContext, escrowKey, escrowData);
        }
        await userStore.addAvailableBalance(methodContext, recipientAddress, tokenID, amount);
        this.events.get(ccm_transfer_1.CcmTransferEvent).log(ctx, {
            senderAddress,
            recipientAddress,
            tokenID,
            amount,
            receivingChainID,
        });
    }
}
exports.CrossChainTransferCommand = CrossChainTransferCommand;
//# sourceMappingURL=cc_transfer.js.map