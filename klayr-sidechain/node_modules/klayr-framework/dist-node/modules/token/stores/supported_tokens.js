"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SupportedTokensStore = exports.ALL_SUPPORTED_TOKENS_KEY = exports.supportedTokensStoreSchema = void 0;
const lisk_db_1 = require("@liskhq/lisk-db");
const base_store_1 = require("../../base_store");
const utils_1 = require("../../interoperability/utils");
const constants_1 = require("../constants");
const utils_2 = require("../utils");
exports.supportedTokensStoreSchema = {
    $id: '/token/store/supportedTokens',
    type: 'object',
    required: ['supportedTokenIDs'],
    properties: {
        supportedTokenIDs: {
            type: 'array',
            fieldNumber: 1,
            items: {
                dataType: 'bytes',
                minLength: constants_1.TOKEN_ID_LENGTH,
                maxLength: constants_1.TOKEN_ID_LENGTH,
            },
        },
    },
};
exports.ALL_SUPPORTED_TOKENS_KEY = Buffer.alloc(0);
class SupportedTokensStore extends base_store_1.BaseStore {
    constructor() {
        super(...arguments);
        this.schema = exports.supportedTokensStoreSchema;
    }
    registerOwnChainID(ownChainID) {
        this._ownChainID = ownChainID;
    }
    async allSupported(context) {
        return this.has(context, exports.ALL_SUPPORTED_TOKENS_KEY);
    }
    async isSupported(context, tokenID) {
        if (this._isMainchainOrNative(tokenID)) {
            return true;
        }
        const allSupported = await this.allSupported(context);
        if (allSupported) {
            return true;
        }
        const [chainID] = (0, utils_2.splitTokenID)(tokenID);
        try {
            const supported = await this.get(context, chainID);
            if (supported.supportedTokenIDs.length === 0 ||
                supported.supportedTokenIDs.findIndex(id => id.equals(tokenID)) > -1) {
                return true;
            }
        }
        catch (error) {
            if (!(error instanceof lisk_db_1.NotFoundError)) {
                throw error;
            }
        }
        return false;
    }
    async getAll(context) {
        return this.iterate(context, {
            gte: Buffer.alloc(constants_1.TOKEN_ID_LENGTH, 0),
            lte: Buffer.alloc(constants_1.TOKEN_ID_LENGTH, 255),
        });
    }
    async removeAll(context) {
        const allSupportedTokens = await this.getAll(context);
        for (const { key } of allSupportedTokens) {
            await this.del(context, key);
        }
    }
    async supportAll(context) {
        await this.removeAll(context);
        await this.set(context, exports.ALL_SUPPORTED_TOKENS_KEY, { supportedTokenIDs: [] });
    }
    async supportChain(context, chainID) {
        if (this._isMainchainOrNative(Buffer.concat([chainID, Buffer.alloc(constants_1.LOCAL_ID_LENGTH)]))) {
            return;
        }
        const allSupported = await this.allSupported(context);
        if (allSupported) {
            return;
        }
        await this.set(context, chainID, { supportedTokenIDs: [] });
    }
    async removeSupportForChain(context, chainID) {
        if (this._isMainchainOrNative(Buffer.concat([chainID, Buffer.alloc(constants_1.LOCAL_ID_LENGTH)]))) {
            return;
        }
        const allSupported = await this.allSupported(context);
        if (allSupported) {
            throw new Error('Invalid operation. All tokens from all chains are supported.');
        }
        const supportExist = await this.has(context, chainID);
        if (!supportExist) {
            return;
        }
        await this.del(context, chainID);
    }
    async supportToken(context, tokenID) {
        if (this._isMainchainOrNative(tokenID)) {
            return;
        }
        const allSupported = await this.allSupported(context);
        if (allSupported) {
            return;
        }
        const [chainID] = (0, utils_2.splitTokenID)(tokenID);
        let supported = { supportedTokenIDs: [] };
        try {
            supported = await this.get(context, chainID);
            if (supported.supportedTokenIDs.length === 0) {
                return;
            }
        }
        catch (error) {
            if (!(error instanceof lisk_db_1.NotFoundError)) {
                throw error;
            }
        }
        if (supported.supportedTokenIDs.findIndex(id => id.equals(tokenID)) === -1) {
            supported.supportedTokenIDs.push(tokenID);
            supported.supportedTokenIDs.sort((a, b) => a.compare(b));
            await this.set(context, chainID, supported);
        }
    }
    async removeSupportForToken(context, tokenID) {
        if (this._isMainchainOrNative(tokenID)) {
            throw new Error('Cannot remove support for LSK or native token.');
        }
        const allSupported = await this.allSupported(context);
        if (allSupported) {
            throw new Error('All tokens are supported.');
        }
        const [chainID] = (0, utils_2.splitTokenID)(tokenID);
        const supportExist = await this.has(context, chainID);
        if (!supportExist) {
            return;
        }
        const supported = await this.get(context, chainID);
        if (supported.supportedTokenIDs.length === 0) {
            throw new Error('All tokens from the specified chain are supported.');
        }
        const index = supported.supportedTokenIDs.findIndex(id => id.equals(tokenID));
        if (index >= 0) {
            supported.supportedTokenIDs.splice(index, 1);
            await this.set(context, chainID, supported);
            if (supported.supportedTokenIDs.length === 0) {
                await this.del(context, chainID);
            }
        }
    }
    _isMainchainOrNative(tokenID) {
        const [chainID] = (0, utils_2.splitTokenID)(tokenID);
        if (chainID.equals(this._ownChainID)) {
            return true;
        }
        return (chainID[0] === this._ownChainID[0] &&
            (0, utils_1.getMainchainID)(chainID).equals(chainID) &&
            tokenID.equals(Buffer.concat([Buffer.from([chainID[0], 0, 0, 0]), Buffer.alloc(constants_1.LOCAL_ID_LENGTH, 0)])));
    }
}
exports.SupportedTokensStore = SupportedTokensStore;
//# sourceMappingURL=supported_tokens.js.map