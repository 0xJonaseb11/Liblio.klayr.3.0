"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserStore = exports.userStoreSchema = void 0;
const lisk_db_1 = require("@liskhq/lisk-db");
const base_store_1 = require("../../base_store");
const constants_1 = require("../constants");
exports.userStoreSchema = {
    $id: '/token/store/user',
    type: 'object',
    required: ['availableBalance', 'lockedBalances'],
    properties: {
        availableBalance: { dataType: 'uint64', fieldNumber: 1 },
        lockedBalances: {
            type: 'array',
            fieldNumber: 2,
            items: {
                type: 'object',
                required: ['module', 'amount'],
                properties: {
                    module: {
                        dataType: 'string',
                        fieldNumber: 1,
                        minLength: constants_1.MIN_MODULE_NAME_LENGTH,
                        maxLength: constants_1.MAX_MODULE_NAME_LENGTH,
                    },
                    amount: { dataType: 'uint64', fieldNumber: 2 },
                },
            },
        },
    },
};
class UserStore extends base_store_1.BaseStore {
    constructor() {
        super(...arguments);
        this.schema = exports.userStoreSchema;
    }
    async createDefaultAccount(context, address, tokenID) {
        await this.set(context, this.getKey(address, tokenID), {
            availableBalance: BigInt(0),
            lockedBalances: [],
        });
    }
    async addAvailableBalanceWithCreate(context, address, tokenID, amount) {
        let recipient;
        try {
            recipient = await this.get(context, this.getKey(address, tokenID));
        }
        catch (error) {
            if (!(error instanceof lisk_db_1.NotFoundError)) {
                throw error;
            }
            recipient = {
                availableBalance: BigInt(0),
                lockedBalances: [],
            };
        }
        recipient.availableBalance += amount;
        await this.set(context, this.getKey(address, tokenID), recipient);
    }
    getKey(address, tokenID) {
        return Buffer.concat([address, tokenID]);
    }
    async save(context, address, tokenID, data) {
        const lockedBalances = data.lockedBalances.filter(locked => locked.amount !== BigInt(0));
        lockedBalances.sort((a, b) => a.module.localeCompare(b.module, 'en'));
        await this.set(context, this.getKey(address, tokenID), {
            ...data,
            lockedBalances,
        });
    }
    async addAvailableBalance(context, address, tokenID, amount) {
        const recipient = await this.get(context, this.getKey(address, tokenID));
        recipient.availableBalance += amount;
        await this.set(context, this.getKey(address, tokenID), recipient);
    }
}
exports.UserStore = UserStore;
//# sourceMappingURL=user.js.map