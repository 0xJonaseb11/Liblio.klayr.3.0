"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalMethod = void 0;
const cryptography = require("@klayr/cryptography");
const base_method_1 = require("../base_method");
const initialize_escrow_account_1 = require("./events/initialize_escrow_account");
const initialize_user_account_1 = require("./events/initialize_user_account");
const transfer_1 = require("./events/transfer");
const escrow_1 = require("./stores/escrow");
const user_1 = require("./stores/user");
const errors_1 = require("../../errors");
class InternalMethod extends base_method_1.BaseMethod {
    init(config) {
        this._config = config;
    }
    addDependencies(feeMethod) {
        this._feeMethod = feeMethod;
    }
    async initializeUserAccount(methodContext, address, tokenID) {
        this._feeMethod.payFee(methodContext, this._config.userAccountInitializationFee);
        await this.stores.get(user_1.UserStore).createDefaultAccount(methodContext, address, tokenID);
        this.events.get(initialize_user_account_1.InitializeUserAccountEvent).log(methodContext, {
            address,
            initializationFee: this._config.userAccountInitializationFee,
            tokenID,
        });
    }
    async initializeEscrowAccount(methodContext, chainID, tokenID) {
        this._feeMethod.payFee(methodContext, this._config.escrowAccountInitializationFee);
        await this.stores.get(escrow_1.EscrowStore).createDefaultAccount(methodContext, chainID, tokenID);
        this.events.get(initialize_escrow_account_1.InitializeEscrowAccountEvent).log(methodContext, {
            chainID,
            initializationFee: this._config.escrowAccountInitializationFee,
            tokenID,
        });
    }
    async transfer(methodContext, senderAddress, recipientAddress, tokenID, amount) {
        const userStore = this.stores.get(user_1.UserStore);
        const senderAccountKey = userStore.getKey(senderAddress, tokenID);
        const senderAccount = await userStore.get(methodContext, senderAccountKey);
        if (senderAccount.availableBalance < amount) {
            throw new errors_1.InsufficientBalanceError(cryptography.address.getKlayr32AddressFromAddress(senderAddress), senderAccount.availableBalance.toString(), amount.toString());
        }
        senderAccount.availableBalance -= amount;
        await userStore.save(methodContext, senderAddress, tokenID, senderAccount);
        const recipientAccountKey = userStore.getKey(recipientAddress, tokenID);
        const recipientAccount = await userStore.get(methodContext, recipientAccountKey);
        recipientAccount.availableBalance += amount;
        await userStore.save(methodContext, recipientAddress, tokenID, recipientAccount);
        this.events.get(transfer_1.TransferEvent).log(methodContext, {
            senderAddress,
            recipientAddress,
            tokenID,
            amount,
        });
    }
}
exports.InternalMethod = InternalMethod;
//# sourceMappingURL=internal_method.js.map