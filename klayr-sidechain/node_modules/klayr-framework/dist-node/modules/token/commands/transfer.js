"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferCommand = void 0;
const cryptography = require("@klayr/cryptography");
const base_command_1 = require("../../base_command");
const state_machine_1 = require("../../../state_machine");
const schemas_1 = require("../schemas");
const user_1 = require("../stores/user");
const errors_1 = require("../../../errors");
class TransferCommand extends base_command_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.schema = schemas_1.transferParamsSchema;
    }
    init(args) {
        this._method = args.method;
        this._internalMethod = args.internalMethod;
    }
    async verify(context) {
        const { params } = context;
        const availableBalance = await this._method.getAvailableBalance(context.getMethodContext(), context.transaction.senderAddress, params.tokenID);
        if (availableBalance < params.amount) {
            throw new errors_1.InsufficientBalanceError(cryptography.address.getKlayr32AddressFromAddress(context.transaction.senderAddress), availableBalance.toString(), params.amount.toString());
        }
        return {
            status: state_machine_1.VerifyStatus.OK,
        };
    }
    async execute(context) {
        const { params } = context;
        const userStore = this.stores.get(user_1.UserStore);
        const recipientAccountKey = userStore.getKey(params.recipientAddress, params.tokenID);
        const recipientAccountExists = await userStore.has(context, recipientAccountKey);
        if (!recipientAccountExists) {
            await this._internalMethod.initializeUserAccount(context.getMethodContext(), params.recipientAddress, params.tokenID);
        }
        await this._internalMethod.transfer(context.getMethodContext(), context.transaction.senderAddress, params.recipientAddress, params.tokenID, params.amount);
    }
}
exports.TransferCommand = TransferCommand;
//# sourceMappingURL=transfer.js.map