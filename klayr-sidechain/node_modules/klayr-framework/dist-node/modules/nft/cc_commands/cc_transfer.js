"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrossChainTransferCommand = void 0;
const codec_1 = require("@klayr/codec");
const validator_1 = require("@klayr/validator");
const schemas_1 = require("../schemas");
const nft_1 = require("../stores/nft");
const constants_1 = require("../constants");
const base_cc_command_1 = require("../../interoperability/base_cc_command");
const constants_2 = require("../../interoperability/constants");
const escrow_1 = require("../stores/escrow");
const ccm_transfer_1 = require("../events/ccm_transfer");
class CrossChainTransferCommand extends base_cc_command_1.BaseCCCommand {
    constructor() {
        super(...arguments);
        this.schema = schemas_1.crossChainNFTTransferMessageParamsSchema;
    }
    get name() {
        return constants_1.CROSS_CHAIN_COMMAND_NAME_TRANSFER;
    }
    init(args) {
        this._method = args.method;
        this._internalMethod = args.internalMethod;
        this._feeMethod = args.feeMethod;
    }
    async verify(context) {
        const { ccm, getMethodContext } = context;
        const params = codec_1.codec.decode(schemas_1.crossChainNFTTransferMessageParamsSchema, ccm.params);
        if (ccm.status > constants_2.MAX_RESERVED_ERROR_STATUS) {
            throw new Error('Invalid CCM error code');
        }
        const { nftID } = params;
        const { sendingChainID } = ccm;
        const nftChainID = this._method.getChainID(nftID);
        const ownChainID = context.chainID;
        if (![ownChainID, sendingChainID].some(allowedChainID => nftChainID.equals(allowedChainID))) {
            throw new Error('NFT is not native to either the sending chain or the receiving chain');
        }
        const nftStore = this.stores.get(nft_1.NFTStore);
        const nftExists = await nftStore.has(getMethodContext(), nftID);
        if (nftChainID.equals(ownChainID)) {
            if (!nftExists) {
                throw new Error('Non-existent entry in the NFT substore');
            }
            const nft = await nftStore.get(getMethodContext(), nftID);
            if (!nft.owner.equals(sendingChainID)) {
                throw new Error('NFT has not been properly escrowed');
            }
        }
        if (!nftChainID.equals(ownChainID) &&
            (ccm.status === 2 ||
                ccm.status === 3)) {
            throw new Error('Module or cross-chain command not supported');
        }
        if (!nftChainID.equals(ownChainID) && nftExists) {
            throw new Error('NFT substore entry already exists');
        }
    }
    async execute(context) {
        const { ccm, getMethodContext } = context;
        const params = codec_1.codec.decode(schemas_1.crossChainNFTTransferMessageParamsSchema, ccm.params);
        validator_1.validator.validate(schemas_1.crossChainNFTTransferMessageParamsSchema, params);
        const { sendingChainID, status } = ccm;
        const { nftID, senderAddress, attributesArray: receivedAttributes } = params;
        const nftChainID = this._method.getChainID(nftID);
        const ownChainID = context.chainID;
        const nftStore = this.stores.get(nft_1.NFTStore);
        const escrowStore = this.stores.get(escrow_1.EscrowStore);
        let recipientAddress;
        recipientAddress = params.recipientAddress;
        if (nftChainID.equals(ownChainID)) {
            const storeData = await nftStore.get(getMethodContext(), nftID);
            if (status === constants_1.CCM_STATUS_CODE_OK) {
                const storedAttributes = storeData.attributesArray;
                storeData.attributesArray = this._internalMethod.getNewAttributes(nftID, storedAttributes, receivedAttributes);
            }
            else {
                recipientAddress = senderAddress;
            }
            await this._internalMethod.createNFTEntry(getMethodContext(), recipientAddress, nftID, storeData.attributesArray);
            await this._internalMethod.createUserEntry(getMethodContext(), recipientAddress, nftID);
            await escrowStore.del(getMethodContext(), escrowStore.getKey(sendingChainID, nftID));
        }
        else {
            const isSupported = await this._method.isNFTSupported(getMethodContext(), nftID);
            if (!isSupported) {
                this.events.get(ccm_transfer_1.CcmTransferEvent).error(context, {
                    senderAddress,
                    recipientAddress,
                    nftID,
                    receivingChainID: ccm.receivingChainID,
                    sendingChainID: ccm.sendingChainID,
                }, 3);
                throw new Error('Non-supported NFT');
            }
            this._feeMethod.payFee(getMethodContext(), BigInt(constants_1.FEE_CREATE_NFT));
            if (status !== constants_1.CCM_STATUS_CODE_OK) {
                recipientAddress = senderAddress;
            }
            await this._internalMethod.createNFTEntry(getMethodContext(), recipientAddress, nftID, receivedAttributes);
            await this._internalMethod.createUserEntry(getMethodContext(), recipientAddress, nftID);
        }
        this.events.get(ccm_transfer_1.CcmTransferEvent).log(context, {
            senderAddress,
            recipientAddress,
            nftID,
            receivingChainID: ccm.receivingChainID,
            sendingChainID: ccm.sendingChainID,
        });
    }
}
exports.CrossChainTransferCommand = CrossChainTransferCommand;
//# sourceMappingURL=cc_transfer.js.map