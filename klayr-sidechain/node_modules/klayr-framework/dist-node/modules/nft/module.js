"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NFTModule = void 0;
const utils_1 = require("@klayr/utils");
const codec_1 = require("@klayr/codec");
const validator_1 = require("@klayr/validator");
const interoperability_1 = require("../interoperability");
const cc_method_1 = require("./cc_method");
const endpoint_1 = require("./endpoint");
const all_nfts_from_chain_suported_1 = require("./events/all_nfts_from_chain_suported");
const all_nfts_from_chain_support_removed_1 = require("./events/all_nfts_from_chain_support_removed");
const all_nfts_from_collection_support_removed_1 = require("./events/all_nfts_from_collection_support_removed");
const all_nfts_from_collection_suppported_1 = require("./events/all_nfts_from_collection_suppported");
const all_nfts_support_removed_1 = require("./events/all_nfts_support_removed");
const all_nfts_supported_1 = require("./events/all_nfts_supported");
const ccm_transfer_1 = require("./events/ccm_transfer");
const create_1 = require("./events/create");
const destroy_1 = require("./events/destroy");
const lock_1 = require("./events/lock");
const recover_1 = require("./events/recover");
const set_attributes_1 = require("./events/set_attributes");
const transfer_1 = require("./events/transfer");
const transfer_cross_chain_1 = require("./events/transfer_cross_chain");
const unlock_1 = require("./events/unlock");
const internal_method_1 = require("./internal_method");
const method_1 = require("./method");
const schemas_1 = require("./schemas");
const escrow_1 = require("./stores/escrow");
const nft_1 = require("./stores/nft");
const supported_nfts_1 = require("./stores/supported_nfts");
const user_1 = require("./stores/user");
const cc_transfer_1 = require("./cc_commands/cc_transfer");
const transfer_cross_chain_2 = require("./commands/transfer_cross_chain");
const transfer_2 = require("./commands/transfer");
const constants_1 = require("./constants");
class NFTModule extends interoperability_1.BaseInteroperableModule {
    constructor() {
        super();
        this.method = new method_1.NFTMethod(this.stores, this.events);
        this.endpoint = new endpoint_1.NFTEndpoint(this.stores, this.offchainStores);
        this.crossChainMethod = new cc_method_1.NFTInteroperableMethod(this.stores, this.events);
        this.crossChainTransferCommand = new cc_transfer_1.CrossChainTransferCommand(this.stores, this.events);
        this.crossChainCommand = [this.crossChainTransferCommand];
        this._transferCommand = new transfer_2.TransferCommand(this.stores, this.events);
        this._ccTransferCommand = new transfer_cross_chain_2.TransferCrossChainCommand(this.stores, this.events);
        this._internalMethod = new internal_method_1.InternalMethod(this.stores, this.events);
        this.commands = [this._transferCommand, this._ccTransferCommand];
        this.events.register(transfer_1.TransferEvent, new transfer_1.TransferEvent(this.name));
        this.events.register(transfer_cross_chain_1.TransferCrossChainEvent, new transfer_cross_chain_1.TransferCrossChainEvent(this.name));
        this.events.register(ccm_transfer_1.CcmTransferEvent, new ccm_transfer_1.CcmTransferEvent(this.name));
        this.events.register(create_1.CreateEvent, new create_1.CreateEvent(this.name));
        this.events.register(destroy_1.DestroyEvent, new destroy_1.DestroyEvent(this.name));
        this.events.register(destroy_1.DestroyEvent, new destroy_1.DestroyEvent(this.name));
        this.events.register(lock_1.LockEvent, new lock_1.LockEvent(this.name));
        this.events.register(unlock_1.UnlockEvent, new unlock_1.UnlockEvent(this.name));
        this.events.register(set_attributes_1.SetAttributesEvent, new set_attributes_1.SetAttributesEvent(this.name));
        this.events.register(recover_1.RecoverEvent, new recover_1.RecoverEvent(this.name));
        this.events.register(all_nfts_supported_1.AllNFTsSupportedEvent, new all_nfts_supported_1.AllNFTsSupportedEvent(this.name));
        this.events.register(all_nfts_support_removed_1.AllNFTsSupportRemovedEvent, new all_nfts_support_removed_1.AllNFTsSupportRemovedEvent(this.name));
        this.events.register(all_nfts_from_chain_suported_1.AllNFTsFromChainSupportedEvent, new all_nfts_from_chain_suported_1.AllNFTsFromChainSupportedEvent(this.name));
        this.events.register(all_nfts_from_chain_support_removed_1.AllNFTsFromChainSupportRemovedEvent, new all_nfts_from_chain_support_removed_1.AllNFTsFromChainSupportRemovedEvent(this.name));
        this.events.register(all_nfts_from_collection_suppported_1.AllNFTsFromCollectionSupportedEvent, new all_nfts_from_collection_suppported_1.AllNFTsFromCollectionSupportedEvent(this.name));
        this.events.register(all_nfts_from_collection_support_removed_1.AllNFTsFromCollectionSupportRemovedEvent, new all_nfts_from_collection_support_removed_1.AllNFTsFromCollectionSupportRemovedEvent(this.name));
        this.stores.register(nft_1.NFTStore, new nft_1.NFTStore(this.name, 0));
        this.stores.register(user_1.UserStore, new user_1.UserStore(this.name, 1));
        this.stores.register(escrow_1.EscrowStore, new escrow_1.EscrowStore(this.name, 2));
        this.stores.register(supported_nfts_1.SupportedNFTsStore, new supported_nfts_1.SupportedNFTsStore(this.name, 3));
    }
    get name() {
        return constants_1.MODULE_NAME_NFT;
    }
    addDependencies(interoperabilityMethod, feeMethod, tokenMethod) {
        this._interoperabilityMethod = interoperabilityMethod;
        this._feeMethod = feeMethod;
        this._tokenMethod = tokenMethod;
        this.method.addDependencies(this._internalMethod, feeMethod);
        this._internalMethod.addDependencies(this.method, this._interoperabilityMethod, tokenMethod);
        this.crossChainMethod.addDependencies(interoperabilityMethod);
        this.endpoint.addDependencies(this.method);
    }
    metadata() {
        return {
            ...this.baseMetadata(),
            endpoints: [
                {
                    name: this.endpoint.isCollectionIDSupported.name,
                    request: schemas_1.isCollectionIDSupportedRequestSchema,
                    response: schemas_1.isCollectionIDSupportedResponseSchema,
                },
                {
                    name: this.endpoint.getSupportedCollectionIDs.name,
                    response: schemas_1.getSupportedCollectionIDsResponseSchema,
                },
                {
                    name: this.endpoint.getEscrowedNFTIDs.name,
                    request: schemas_1.getEscrowedNFTIDsRequestSchema,
                    response: schemas_1.getEscrowedNFTIDsResponseSchema,
                },
                {
                    name: this.endpoint.getNFT.name,
                    request: schemas_1.getNFTRequestSchema,
                    response: schemas_1.getNFTResponseSchema,
                },
                {
                    name: this.endpoint.getNFTs.name,
                    request: schemas_1.getNFTsRequestSchema,
                    response: schemas_1.getNFTsResponseSchema,
                },
                {
                    name: this.endpoint.hasNFT.name,
                    request: schemas_1.hasNFTRequestSchema,
                    response: schemas_1.hasNFTResponseSchema,
                },
                {
                    name: this.endpoint.isNFTSupported.name,
                    request: schemas_1.isNFTSupportedRequestSchema,
                    response: schemas_1.isNFTSupportedResponseSchema,
                },
            ],
            assets: [],
        };
    }
    async init(args) {
        const ownChainID = Buffer.from(args.genesisConfig.chainID, 'hex');
        this._internalMethod.init({ ownChainID });
        this.method.init({ ownChainID });
        this.crossChainTransferCommand.init({
            method: this.method,
            internalMethod: this._internalMethod,
            feeMethod: this._feeMethod,
        });
        this._ccTransferCommand.init({
            internalMethod: this._internalMethod,
            interoperabilityMethod: this._interoperabilityMethod,
            nftMethod: this.method,
            tokenMethod: this._tokenMethod,
        });
        this._transferCommand.init({ internalMethod: this._internalMethod });
    }
    async initGenesisState(context) {
        var _a;
        const assetBytes = context.assets.getAsset(this.name);
        if (!assetBytes) {
            return;
        }
        const genesisStore = codec_1.codec.decode(schemas_1.genesisNFTStoreSchema, assetBytes);
        validator_1.validator.validate(schemas_1.genesisNFTStoreSchema, genesisStore);
        const nftIDKeySet = new utils_1.dataStructures.BufferSet();
        for (const nft of genesisStore.nftSubstore) {
            if (![constants_1.LENGTH_CHAIN_ID, constants_1.LENGTH_ADDRESS].includes(nft.owner.length)) {
                throw new Error(`nftID ${nft.nftID.toString('hex')} has invalid owner`);
            }
            if (nftIDKeySet.has(nft.nftID)) {
                throw new Error(`nftID ${nft.nftID.toString('hex')} duplicated`);
            }
            const attributeSet = {};
            for (const attribute of nft.attributesArray) {
                attributeSet[attribute.module] = ((_a = attributeSet[attribute.module]) !== null && _a !== void 0 ? _a : 0) + 1;
                if (attributeSet[attribute.module] > 1) {
                    throw new Error(`nftID ${nft.nftID.toString('hex')} has a duplicate attribute for ${attribute.module} module`);
                }
            }
            nftIDKeySet.add(nft.nftID);
        }
        const allNFTsSupported = genesisStore.supportedNFTsSubstore.some(supportedNFTs => supportedNFTs.chainID.equals(constants_1.ALL_SUPPORTED_NFTS_KEY));
        if (genesisStore.supportedNFTsSubstore.length > 1 && allNFTsSupported) {
            throw new Error('SupportedNFTsSubstore should contain only one entry if all NFTs are supported');
        }
        if (allNFTsSupported &&
            genesisStore.supportedNFTsSubstore[0].supportedCollectionIDArray.length !== 0) {
            throw new Error('supportedCollectionIDArray must be empty if all NFTs are supported');
        }
        const supportedChainsKeySet = new utils_1.dataStructures.BufferSet();
        for (const supportedNFT of genesisStore.supportedNFTsSubstore) {
            if (supportedChainsKeySet.has(supportedNFT.chainID)) {
                throw new Error(`chainID ${supportedNFT.chainID.toString('hex')} duplicated`);
            }
            supportedChainsKeySet.add(supportedNFT.chainID);
        }
        for (const nft of genesisStore.nftSubstore) {
            const { owner, nftID, attributesArray } = nft;
            await this._internalMethod.createNFTEntry(context.getMethodContext(), owner, nftID, attributesArray);
            if (owner.length === constants_1.LENGTH_CHAIN_ID) {
                await this._internalMethod.createEscrowEntry(context.getMethodContext(), owner, nftID);
            }
            else {
                await this._internalMethod.createUserEntry(context.getMethodContext(), owner, nftID);
            }
        }
        for (const supportedNFT of genesisStore.supportedNFTsSubstore) {
            const { chainID, supportedCollectionIDArray } = supportedNFT;
            const supportedNFTsSubstore = this.stores.get(supported_nfts_1.SupportedNFTsStore);
            await supportedNFTsSubstore.save(context, chainID, {
                supportedCollectionIDArray,
            });
        }
    }
}
exports.NFTModule = NFTModule;
//# sourceMappingURL=module.js.map