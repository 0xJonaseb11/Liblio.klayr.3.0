"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalMethod = exports.TransferVerifyError = void 0;
const codec_1 = require("@klayr/codec");
const base_method_1 = require("../base_method");
const nft_1 = require("./stores/nft");
const transfer_1 = require("./events/transfer");
const user_1 = require("./stores/user");
const constants_1 = require("./constants");
const escrow_1 = require("./stores/escrow");
const transfer_cross_chain_1 = require("./events/transfer_cross_chain");
const schemas_1 = require("./schemas");
const error_1 = require("./error");
class TransferVerifyError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
exports.TransferVerifyError = TransferVerifyError;
class InternalMethod extends base_method_1.BaseMethod {
    init(config) {
        this._config = config;
    }
    addDependencies(nftMethod, interoperabilityMethod, tokenMethod) {
        this._nftMethod = nftMethod;
        this._interoperabilityMethod = interoperabilityMethod;
        this._tokenMethod = tokenMethod;
    }
    async createEscrowEntry(methodContext, receivingChainID, nftID) {
        const escrowStore = this.stores.get(escrow_1.EscrowStore);
        await escrowStore.set(methodContext, escrowStore.getKey(receivingChainID, nftID), {});
    }
    async createUserEntry(methodContext, address, nftID) {
        const userStore = this.stores.get(user_1.UserStore);
        await userStore.set(methodContext, userStore.getKey(address, nftID), {
            lockingModule: constants_1.NFT_NOT_LOCKED,
        });
    }
    async createNFTEntry(methodContext, address, nftID, attributesArray) {
        const hasDuplicates = this.hasDuplicateModuleNames(attributesArray);
        if (hasDuplicates) {
            throw new Error('Invalid attributes array provided');
        }
        const nftStore = this.stores.get(nft_1.NFTStore);
        await nftStore.save(methodContext, nftID, {
            owner: address,
            attributesArray,
        });
    }
    hasDuplicateModuleNames(attributesArray) {
        const moduleNames = [];
        for (const item of attributesArray) {
            moduleNames.push(item.module);
        }
        return new Set(moduleNames).size !== attributesArray.length;
    }
    async verifyTransfer(immutableMethodContext, senderAddress, nftID) {
        let nft;
        try {
            nft = await this._nftMethod.getNFT(immutableMethodContext, nftID);
        }
        catch (error) {
            if (error instanceof error_1.NotFoundError) {
                throw new TransferVerifyError('NFT does not exist', 1);
            }
            throw error;
        }
        if (this._nftMethod.isNFTEscrowed(nft)) {
            throw new TransferVerifyError('NFT is escrowed to another chain', 7);
        }
        if (!nft.owner.equals(senderAddress)) {
            throw new TransferVerifyError('Transfer not initiated by the NFT owner', 10);
        }
        if (this._nftMethod.isNFTLocked(nft)) {
            throw new TransferVerifyError('Locked NFTs cannot be transferred', 4);
        }
    }
    async verifyTransferCrossChain(immutableMethodContext, senderAddress, nftID, sendingChainID, receivingChainID, messageFee, data) {
        let nft;
        try {
            nft = await this._nftMethod.getNFT(immutableMethodContext, nftID);
        }
        catch (error) {
            if (error instanceof error_1.NotFoundError) {
                throw new TransferVerifyError('NFT does not exist', 1);
            }
            throw error;
        }
        const nftChainID = this._nftMethod.getChainID(nftID);
        const ownChainID = this.getOwnChainID();
        if (![ownChainID, receivingChainID].some(allowedChainID => nftChainID.equals(allowedChainID))) {
            throw new TransferVerifyError('NFT must be native to either the sending or the receiving chain', 2);
        }
        if (receivingChainID.equals(sendingChainID)) {
            throw new TransferVerifyError('Receiving chain cannot be the sending chain', 14);
        }
        if (data.length > constants_1.MAX_LENGTH_DATA) {
            throw new TransferVerifyError('Data field is too long', 13);
        }
        if (this._nftMethod.isNFTEscrowed(nft)) {
            throw new TransferVerifyError('NFT is escrowed to another chain', 7);
        }
        if (!nft.owner.equals(senderAddress)) {
            throw new TransferVerifyError('Transfer not initiated by the NFT owner', 10);
        }
        if (this._nftMethod.isNFTLocked(nft)) {
            throw new TransferVerifyError('Locked NFTs cannot be transferred', 4);
        }
        const messageFeeTokenID = await this._interoperabilityMethod.getMessageFeeTokenID(immutableMethodContext, receivingChainID);
        const availableBalance = await this._tokenMethod.getAvailableBalance(immutableMethodContext, senderAddress, messageFeeTokenID);
        if (availableBalance < messageFee) {
            throw new TransferVerifyError('Insufficient balance for the message fee', 12);
        }
    }
    async transfer(methodContext, recipientAddress, nftID) {
        const nftStore = this.stores.get(nft_1.NFTStore);
        const userStore = this.stores.get(user_1.UserStore);
        const nft = await nftStore.get(methodContext, nftID);
        const senderAddress = nft.owner;
        nft.owner = recipientAddress;
        await nftStore.set(methodContext, nftID, nft);
        await userStore.del(methodContext, userStore.getKey(senderAddress, nftID));
        await this.createUserEntry(methodContext, recipientAddress, nftID);
        this.events.get(transfer_1.TransferEvent).log(methodContext, {
            senderAddress,
            recipientAddress,
            nftID,
        });
    }
    async transferCrossChain(methodContext, senderAddress, recipientAddress, nftID, receivingChainID, messageFee, data, includeAttributes, timestamp) {
        const chainID = this._nftMethod.getChainID(nftID);
        const nftStore = this.stores.get(nft_1.NFTStore);
        const nft = await nftStore.get(methodContext, nftID);
        if (chainID.equals(this._config.ownChainID)) {
            const escrowStore = this.stores.get(escrow_1.EscrowStore);
            const userStore = this.stores.get(user_1.UserStore);
            nft.owner = receivingChainID;
            await nftStore.save(methodContext, nftID, nft);
            await userStore.del(methodContext, userStore.getKey(senderAddress, nftID));
            const escrowExists = await escrowStore.has(methodContext, escrowStore.getKey(receivingChainID, nftID));
            if (!escrowExists) {
                await this.createEscrowEntry(methodContext, receivingChainID, nftID);
            }
        }
        if (chainID.equals(receivingChainID)) {
            await this._nftMethod.destroy(methodContext, senderAddress, nftID);
        }
        let attributesArray = [];
        if (includeAttributes) {
            attributesArray = nft.attributesArray;
        }
        this.events.get(transfer_cross_chain_1.TransferCrossChainEvent).log(methodContext, {
            senderAddress,
            recipientAddress,
            nftID,
            receivingChainID,
            includeAttributes,
        });
        await this._interoperabilityMethod.send(methodContext, senderAddress, constants_1.MODULE_NAME_NFT, constants_1.CROSS_CHAIN_COMMAND_NAME_TRANSFER, receivingChainID, messageFee, codec_1.codec.encode(schemas_1.crossChainNFTTransferMessageParamsSchema, {
            nftID,
            senderAddress,
            recipientAddress,
            attributesArray,
            data,
        }), timestamp);
    }
    getOwnChainID() {
        return this._config.ownChainID;
    }
    getNewAttributes(_nftID, storedAttributes, _receivedAttributes) {
        return storedAttributes;
    }
}
exports.InternalMethod = InternalMethod;
//# sourceMappingURL=internal_method.js.map