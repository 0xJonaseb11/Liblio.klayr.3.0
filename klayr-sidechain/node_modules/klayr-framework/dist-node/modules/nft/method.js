"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NFTMethod = void 0;
const validator_1 = require("@klayr/validator");
const codec_1 = require("@klayr/codec");
const base_method_1 = require("../base_method");
const nft_1 = require("./stores/nft");
const constants_1 = require("./constants");
const user_1 = require("./stores/user");
const destroy_1 = require("./events/destroy");
const supported_nfts_1 = require("./stores/supported_nfts");
const create_1 = require("./events/create");
const lock_1 = require("./events/lock");
const transfer_1 = require("./events/transfer");
const internal_method_1 = require("./internal_method");
const transfer_cross_chain_1 = require("./events/transfer_cross_chain");
const all_nfts_supported_1 = require("./events/all_nfts_supported");
const all_nfts_support_removed_1 = require("./events/all_nfts_support_removed");
const all_nfts_from_chain_suported_1 = require("./events/all_nfts_from_chain_suported");
const all_nfts_from_collection_suppported_1 = require("./events/all_nfts_from_collection_suppported");
const all_nfts_from_collection_support_removed_1 = require("./events/all_nfts_from_collection_support_removed");
const all_nfts_from_chain_support_removed_1 = require("./events/all_nfts_from_chain_support_removed");
const recover_1 = require("./events/recover");
const escrow_1 = require("./stores/escrow");
const set_attributes_1 = require("./events/set_attributes");
const error_1 = require("./error");
const unlock_1 = require("./events/unlock");
class NFTMethod extends base_method_1.BaseMethod {
    init(config) {
        this._config = config;
    }
    addDependencies(internalMethod, feeMethod) {
        this._internalMethod = internalMethod;
        this._feeMethod = feeMethod;
    }
    getChainID(nftID) {
        if (nftID.length !== constants_1.LENGTH_NFT_ID) {
            throw new Error(`NFT ID must have length ${constants_1.LENGTH_NFT_ID}`);
        }
        return nftID.subarray(0, constants_1.LENGTH_CHAIN_ID);
    }
    isNFTEscrowed(nft) {
        return nft.owner.length !== constants_1.LENGTH_ADDRESS;
    }
    isNFTLocked(nft) {
        if (!nft.lockingModule) {
            return false;
        }
        return nft.lockingModule !== constants_1.NFT_NOT_LOCKED;
    }
    async getNFT(methodContext, nftID) {
        const nftStore = this.stores.get(nft_1.NFTStore);
        const nftExists = await nftStore.has(methodContext, nftID);
        if (!nftExists) {
            throw new error_1.NotFoundError('NFT substore entry does not exist');
        }
        const data = await nftStore.get(methodContext, nftID);
        const { owner } = data;
        if (owner.length === constants_1.LENGTH_ADDRESS) {
            const userStore = this.stores.get(user_1.UserStore);
            const userExists = await userStore.has(methodContext, userStore.getKey(owner, nftID));
            if (!userExists) {
                throw new error_1.NotFoundError('User substore entry does not exist');
            }
            const userData = await userStore.get(methodContext, userStore.getKey(owner, nftID));
            return { ...data, lockingModule: userData.lockingModule };
        }
        return data;
    }
    async destroy(methodContext, address, nftID) {
        let nft;
        try {
            nft = await this.getNFT(methodContext, nftID);
        }
        catch (error) {
            if (error instanceof error_1.NotFoundError) {
                this.events.get(destroy_1.DestroyEvent).error(methodContext, {
                    address,
                    nftID,
                }, 1);
                throw new Error('NFT does not exist');
            }
            throw error;
        }
        if (this.isNFTEscrowed(nft)) {
            this.events.get(destroy_1.DestroyEvent).error(methodContext, {
                address,
                nftID,
            }, 7);
            throw new Error('NFT is escrowed to another chain');
        }
        if (!nft.owner.equals(address)) {
            this.events.get(destroy_1.DestroyEvent).error(methodContext, {
                address,
                nftID,
            }, 10);
            throw new Error('Not initiated by the NFT owner');
        }
        if (this.isNFTLocked(nft)) {
            this.events.get(destroy_1.DestroyEvent).error(methodContext, {
                address,
                nftID,
            }, 4);
            throw new Error('Locked NFTs cannot be destroyed');
        }
        const nftStore = this.stores.get(nft_1.NFTStore);
        const userStore = this.stores.get(user_1.UserStore);
        await nftStore.del(methodContext, nftID);
        await userStore.del(methodContext, userStore.getKey(nft.owner, nftID));
        this.events.get(destroy_1.DestroyEvent).log(methodContext, {
            address,
            nftID,
        });
    }
    getCollectionID(nftID) {
        return nftID.subarray(constants_1.LENGTH_CHAIN_ID, constants_1.LENGTH_CHAIN_ID + constants_1.LENGTH_COLLECTION_ID);
    }
    async isNFTSupported(methodContext, nftID) {
        const nftChainID = this.getChainID(nftID);
        if (nftChainID.equals(this._config.ownChainID)) {
            return true;
        }
        const supportedNFTsStore = this.stores.get(supported_nfts_1.SupportedNFTsStore);
        const supportForAllKeysExists = await supportedNFTsStore.has(methodContext, constants_1.ALL_SUPPORTED_NFTS_KEY);
        if (supportForAllKeysExists) {
            return true;
        }
        const supportForNftChainIdExists = await supportedNFTsStore.has(methodContext, nftChainID);
        if (supportForNftChainIdExists) {
            const supportedNFTsStoreData = await supportedNFTsStore.get(methodContext, nftChainID);
            if (supportedNFTsStoreData.supportedCollectionIDArray.length === 0) {
                return true;
            }
            const collectionID = this.getCollectionID(nftID);
            if (supportedNFTsStoreData.supportedCollectionIDArray.some(id => collectionID.equals(id.collectionID))) {
                return true;
            }
        }
        return false;
    }
    async getNextAvailableIndex(methodContext, collectionID) {
        const nftStore = this.stores.get(nft_1.NFTStore);
        const nftStoreData = await nftStore.iterate(methodContext, {
            gte: Buffer.concat([this._config.ownChainID, collectionID, Buffer.alloc(constants_1.LENGTH_INDEX, 0)]),
            lte: Buffer.concat([this._config.ownChainID, collectionID, Buffer.alloc(constants_1.LENGTH_INDEX, 255)]),
        });
        if (nftStoreData.length === 0) {
            return BigInt(0);
        }
        const latestKey = nftStoreData[nftStoreData.length - 1].key;
        const indexBytes = latestKey.subarray(constants_1.LENGTH_CHAIN_ID + constants_1.LENGTH_COLLECTION_ID, constants_1.LENGTH_NFT_ID);
        const index = indexBytes.readBigUInt64BE();
        const largestIndex = BigInt(BigInt(2 ** 64) - BigInt(1));
        if (index === largestIndex) {
            throw new Error('No more available indexes');
        }
        return index + BigInt(1);
    }
    async create(methodContext, address, collectionID, attributesArray) {
        const index = await this.getNextAvailableIndex(methodContext, collectionID);
        const indexBytes = Buffer.alloc(constants_1.LENGTH_INDEX);
        indexBytes.writeBigInt64BE(index);
        const nftID = Buffer.concat([this._config.ownChainID, collectionID, indexBytes]);
        this._feeMethod.payFee(methodContext, BigInt(constants_1.FEE_CREATE_NFT));
        await this._internalMethod.createNFTEntry(methodContext, address, nftID, attributesArray);
        await this._internalMethod.createUserEntry(methodContext, address, nftID);
        this.events.get(create_1.CreateEvent).log(methodContext, {
            address,
            nftID,
        });
    }
    async lock(methodContext, module, nftID) {
        if (module === constants_1.NFT_NOT_LOCKED) {
            throw new Error('Cannot be locked by NFT module');
        }
        let nft;
        try {
            nft = await this.getNFT(methodContext, nftID);
        }
        catch (error) {
            if (error instanceof error_1.NotFoundError) {
                this.events.get(lock_1.LockEvent).error(methodContext, {
                    module,
                    nftID,
                }, 1);
                throw new Error('NFT does not exist');
            }
            throw error;
        }
        if (this.isNFTEscrowed(nft)) {
            this.events.get(lock_1.LockEvent).error(methodContext, {
                module,
                nftID,
            }, 7);
            throw new Error('NFT is escrowed to another chain');
        }
        if (this.isNFTLocked(nft)) {
            this.events.get(lock_1.LockEvent).error(methodContext, {
                module,
                nftID,
            }, 4);
            throw new Error('NFT is already locked');
        }
        const userStore = this.stores.get(user_1.UserStore);
        await userStore.set(methodContext, userStore.getKey(nft.owner, nftID), {
            lockingModule: module,
        });
        this.events.get(lock_1.LockEvent).log(methodContext, {
            module,
            nftID,
        });
    }
    async unlock(methodContext, module, nftID) {
        let nft;
        try {
            nft = await this.getNFT(methodContext, nftID);
        }
        catch (error) {
            if (error instanceof error_1.NotFoundError) {
                this.events.get(unlock_1.UnlockEvent).error(methodContext, {
                    module,
                    nftID,
                }, 1);
                throw new Error('NFT does not exist');
            }
            throw error;
        }
        if (this.isNFTEscrowed(nft)) {
            throw new Error('NFT is escrowed to another chain');
        }
        if (!this.isNFTLocked(nft)) {
            this.events.get(unlock_1.UnlockEvent).error(methodContext, {
                module,
                nftID,
            }, 5);
            throw new Error('NFT is not locked');
        }
        if (nft.lockingModule !== module) {
            this.events.get(unlock_1.UnlockEvent).error(methodContext, {
                module,
                nftID,
            }, 6);
            throw new Error('Unlocking NFT via module that did not lock it');
        }
        const userStore = this.stores.get(user_1.UserStore);
        await userStore.set(methodContext, userStore.getKey(nft.owner, nftID), {
            lockingModule: constants_1.NFT_NOT_LOCKED,
        });
        this.events.get(unlock_1.UnlockEvent).log(methodContext, {
            module,
            nftID,
        });
    }
    async transfer(methodContext, senderAddress, recipientAddress, nftID) {
        try {
            await this._internalMethod.verifyTransfer(methodContext, senderAddress, nftID);
        }
        catch (error) {
            if (error instanceof internal_method_1.TransferVerifyError) {
                this.events.get(transfer_1.TransferEvent).error(methodContext, {
                    senderAddress,
                    recipientAddress,
                    nftID,
                }, error.code);
            }
            throw error;
        }
        await this._internalMethod.transfer(methodContext, recipientAddress, nftID);
    }
    async transferCrossChain(methodContext, senderAddress, recipientAddress, nftID, receivingChainID, messageFee, data, includeAttributes) {
        try {
            await this._internalMethod.verifyTransferCrossChain(methodContext, senderAddress, nftID, this._internalMethod.getOwnChainID(), receivingChainID, messageFee, data);
        }
        catch (error) {
            if (error instanceof internal_method_1.TransferVerifyError) {
                this.events.get(transfer_cross_chain_1.TransferCrossChainEvent).error(methodContext, {
                    senderAddress,
                    recipientAddress,
                    receivingChainID,
                    nftID,
                    includeAttributes,
                }, error.code);
            }
            throw error;
        }
        await this._internalMethod.transferCrossChain(methodContext, senderAddress, recipientAddress, nftID, receivingChainID, messageFee, data, includeAttributes);
    }
    async supportAllNFTs(methodContext) {
        const supportedNFTsStore = this.stores.get(supported_nfts_1.SupportedNFTsStore);
        const alreadySupported = await supportedNFTsStore.has(methodContext, constants_1.ALL_SUPPORTED_NFTS_KEY);
        if (alreadySupported) {
            return;
        }
        const allSupportedNFTs = await supportedNFTsStore.getAll(methodContext);
        for (const { key } of allSupportedNFTs) {
            await supportedNFTsStore.del(methodContext, key);
        }
        await supportedNFTsStore.set(methodContext, constants_1.ALL_SUPPORTED_NFTS_KEY, {
            supportedCollectionIDArray: [],
        });
        this.events.get(all_nfts_supported_1.AllNFTsSupportedEvent).log(methodContext);
    }
    async removeSupportAllNFTs(methodContext) {
        const supportedNFTsStore = this.stores.get(supported_nfts_1.SupportedNFTsStore);
        const allSupportedNFTs = await supportedNFTsStore.getAll(methodContext);
        for (const { key } of allSupportedNFTs) {
            await supportedNFTsStore.del(methodContext, key);
        }
        await supportedNFTsStore.del(methodContext, constants_1.ALL_SUPPORTED_NFTS_KEY);
        this.events.get(all_nfts_support_removed_1.AllNFTsSupportRemovedEvent).log(methodContext);
    }
    async supportAllNFTsFromChain(methodContext, chainID) {
        if (chainID.equals(this._config.ownChainID)) {
            return;
        }
        const supportedNFTsStore = this.stores.get(supported_nfts_1.SupportedNFTsStore);
        const allNFTsSuppported = await supportedNFTsStore.has(methodContext, constants_1.ALL_SUPPORTED_NFTS_KEY);
        if (allNFTsSuppported) {
            return;
        }
        const chainSupportExists = await supportedNFTsStore.has(methodContext, chainID);
        if (chainSupportExists) {
            const supportedCollections = await supportedNFTsStore.get(methodContext, chainID);
            if (supportedCollections.supportedCollectionIDArray.length === 0) {
                return;
            }
        }
        await supportedNFTsStore.save(methodContext, chainID, {
            supportedCollectionIDArray: [],
        });
        this.events.get(all_nfts_from_chain_suported_1.AllNFTsFromChainSupportedEvent).log(methodContext, chainID);
    }
    async removeSupportAllNFTsFromChain(methodContext, chainID) {
        if (chainID.equals(this._config.ownChainID)) {
            throw new Error('Support for native NFTs cannot be removed');
        }
        const supportedNFTsStore = this.stores.get(supported_nfts_1.SupportedNFTsStore);
        const allNFTsSupported = await supportedNFTsStore.has(methodContext, constants_1.ALL_SUPPORTED_NFTS_KEY);
        if (allNFTsSupported) {
            throw new Error('All NFTs from all chains are supported');
        }
        const isChainSupported = await supportedNFTsStore.has(methodContext, chainID);
        if (!isChainSupported) {
            return;
        }
        await supportedNFTsStore.del(methodContext, chainID);
        this.events.get(all_nfts_from_chain_support_removed_1.AllNFTsFromChainSupportRemovedEvent).log(methodContext, chainID);
    }
    async supportAllNFTsFromCollection(methodContext, chainID, collectionID) {
        if (chainID.equals(this._config.ownChainID)) {
            return;
        }
        const supportedNFTsStore = this.stores.get(supported_nfts_1.SupportedNFTsStore);
        const allNFTsSupported = await supportedNFTsStore.has(methodContext, constants_1.ALL_SUPPORTED_NFTS_KEY);
        if (allNFTsSupported) {
            return;
        }
        const isChainSupported = await supportedNFTsStore.has(methodContext, chainID);
        let supportedChainData;
        if (isChainSupported) {
            supportedChainData = await supportedNFTsStore.get(methodContext, chainID);
            if (supportedChainData.supportedCollectionIDArray.length === 0) {
                return;
            }
            if (supportedChainData.supportedCollectionIDArray.some(collection => collection.collectionID.equals(collectionID))) {
                return;
            }
            supportedChainData.supportedCollectionIDArray.push({ collectionID });
            await supportedNFTsStore.save(methodContext, chainID, supportedChainData);
            this.events.get(all_nfts_from_collection_suppported_1.AllNFTsFromCollectionSupportedEvent).log(methodContext, {
                chainID,
                collectionID,
            });
            return;
        }
        await supportedNFTsStore.save(methodContext, chainID, {
            supportedCollectionIDArray: [
                {
                    collectionID,
                },
            ],
        });
        this.events.get(all_nfts_from_collection_suppported_1.AllNFTsFromCollectionSupportedEvent).log(methodContext, {
            chainID,
            collectionID,
        });
    }
    async removeSupportAllNFTsFromCollection(methodContext, chainID, collectionID) {
        if (chainID.equals(this._config.ownChainID)) {
            throw new Error('Invalid operation. Support for native NFTs cannot be removed');
        }
        const supportedNFTsStore = this.stores.get(supported_nfts_1.SupportedNFTsStore);
        const allNFTsSupported = await supportedNFTsStore.has(methodContext, constants_1.ALL_SUPPORTED_NFTS_KEY);
        if (allNFTsSupported) {
            throw new Error('All NFTs from all chains are supported');
        }
        const isChainSupported = await supportedNFTsStore.has(methodContext, chainID);
        if (!isChainSupported) {
            return;
        }
        const supportedChainData = await supportedNFTsStore.get(methodContext, chainID);
        if (supportedChainData.supportedCollectionIDArray.length === 0) {
            throw new Error('All NFTs from the specified chain are supported');
        }
        if (supportedChainData.supportedCollectionIDArray.some(supportedCollection => supportedCollection.collectionID.equals(collectionID))) {
            supportedChainData.supportedCollectionIDArray =
                supportedChainData.supportedCollectionIDArray.filter(supportedCollection => !supportedCollection.collectionID.equals(collectionID));
        }
        if (supportedChainData.supportedCollectionIDArray.length === 0) {
            await supportedNFTsStore.del(methodContext, chainID);
        }
        else {
            await supportedNFTsStore.save(methodContext, chainID, {
                ...supportedChainData,
            });
        }
        this.events.get(all_nfts_from_collection_support_removed_1.AllNFTsFromCollectionSupportRemovedEvent).log(methodContext, {
            chainID,
            collectionID,
        });
    }
    async recover(methodContext, terminatedChainID, substorePrefix, nftID, nft) {
        const nftStore = this.stores.get(nft_1.NFTStore);
        let isValidInput = true;
        let decodedValue;
        try {
            decodedValue = codec_1.codec.decode(nft_1.nftStoreSchema, nft);
            validator_1.validator.validate(nft_1.nftStoreSchema, decodedValue);
        }
        catch (error) {
            isValidInput = false;
        }
        if (!substorePrefix.equals(nftStore.subStorePrefix) ||
            nftID.length !== constants_1.LENGTH_NFT_ID ||
            !isValidInput) {
            this.events.get(recover_1.RecoverEvent).error(methodContext, {
                terminatedChainID,
                nftID,
            }, 11);
            throw new Error('Invalid inputs');
        }
        const nftChainID = this.getChainID(nftID);
        const ownChainID = this._internalMethod.getOwnChainID();
        if (!nftChainID.equals(ownChainID)) {
            this.events.get(recover_1.RecoverEvent).error(methodContext, {
                terminatedChainID,
                nftID,
            }, 9);
            throw new Error('Recovery called by a foreign chain');
        }
        let nftData;
        try {
            nftData = await this.getNFT(methodContext, nftID);
        }
        catch (error) {
            if (error instanceof error_1.NotFoundError) {
                this.events.get(recover_1.RecoverEvent).error(methodContext, {
                    terminatedChainID,
                    nftID,
                }, 1);
                throw new Error('NFT substore entry does not exist');
            }
            throw error;
        }
        if (!nftData.owner.equals(terminatedChainID)) {
            this.events.get(recover_1.RecoverEvent).error(methodContext, {
                terminatedChainID,
                nftID,
            }, 8);
            throw new Error('NFT was not escrowed to terminated chain');
        }
        const storeValueOwner = decodedValue.owner;
        if (storeValueOwner.length !== constants_1.LENGTH_ADDRESS) {
            this.events.get(recover_1.RecoverEvent).error(methodContext, {
                terminatedChainID,
                nftID,
            }, 15);
            throw new Error('Invalid account information');
        }
        const escrowStore = this.stores.get(escrow_1.EscrowStore);
        nftData.owner = storeValueOwner;
        const storedAttributes = nftData.attributesArray;
        const receivedAttributes = decodedValue.attributesArray;
        nftData.attributesArray = this._internalMethod.getNewAttributes(nftID, storedAttributes, receivedAttributes);
        await this._internalMethod.createNFTEntry(methodContext, nftData.owner, nftID, nftData.attributesArray);
        await this._internalMethod.createUserEntry(methodContext, nftData.owner, nftID);
        await escrowStore.del(methodContext, escrowStore.getKey(terminatedChainID, nftID));
        this.events.get(recover_1.RecoverEvent).log(methodContext, {
            terminatedChainID,
            nftID,
        });
    }
    async setAttributes(methodContext, module, nftID, attributes) {
        const nftStore = this.stores.get(nft_1.NFTStore);
        const nftExists = await nftStore.has(methodContext, nftID);
        if (!nftExists) {
            this.events.get(set_attributes_1.SetAttributesEvent).error(methodContext, {
                nftID,
                attributes,
            }, 1);
            throw new Error('NFT substore entry does not exist');
        }
        const nft = await nftStore.get(methodContext, nftID);
        const index = nft.attributesArray.findIndex(attr => attr.module === module);
        if (index > -1) {
            nft.attributesArray[index] = { module, attributes };
        }
        else {
            nft.attributesArray.push({ module, attributes });
        }
        await this._internalMethod.createNFTEntry(methodContext, nft.owner, nftID, nft.attributesArray);
        this.events.get(set_attributes_1.SetAttributesEvent).log(methodContext, {
            nftID,
            attributes,
        });
    }
}
exports.NFTMethod = NFTMethod;
//# sourceMappingURL=method.js.map