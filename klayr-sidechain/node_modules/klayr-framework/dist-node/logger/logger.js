"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLogger = exports.createDirIfNotExist = void 0;
const path = require("path");
const fs = require("fs");
const bunyan = require("bunyan");
const util = require("util");
const createDirIfNotExist = (filePath) => {
    const dir = path.dirname(filePath);
    if (fs.existsSync(dir)) {
        return;
    }
    fs.mkdirSync(dir, { recursive: true });
};
exports.createDirIfNotExist = createDirIfNotExist;
const levelToName = {
    10: 'TRACE',
    20: 'DEBUG',
    30: 'INFO',
    40: 'WARN',
    50: 'ERROR',
    60: 'FATAL',
};
const parseStructData = (input, trace, err) => {
    const keys = Object.keys(input);
    if (keys.length === 0 && !err) {
        return '';
    }
    const pairs = [];
    for (const key of keys) {
        const value = input[key];
        switch (typeof value) {
            case 'string':
            case 'number':
                pairs.push(`${key}=${value}`);
                break;
            case 'bigint':
                pairs.push(`${key}=${value.toString()}`);
                break;
            case 'boolean':
                pairs.push(`${key}=${value ? 'true' : 'false'}`);
                break;
            case 'object':
                if (Buffer.isBuffer(value)) {
                    pairs.push(`${key}=${value.toString('hex')}`);
                }
                if (value instanceof Error) {
                    pairs.push(`error=${value.message}`);
                }
                break;
            default:
                continue;
        }
    }
    if (err) {
        pairs.push(`err=${err.message}`);
        if (err.stack && trace) {
            pairs.push(`trace=${err.stack}`);
        }
    }
    return pairs.length > 0 ? ` [${pairs.join(' ')}]` : '';
};
class ConsoleLog {
    constructor(_trace = false) {
        this._trace = _trace;
    }
    write(rec) {
        try {
            const { time, level, name, msg, module, err, hostname, pid, src, v, ...others } = rec;
            const structData = parseStructData(others, this._trace, err);
            const log = util.format('%s %s %s %s %d%s %s\n', new Date(time).toISOString(), levelToName[level], hostname, name, pid, structData, msg);
            if (level >= 40) {
                process.stderr.write(log);
            }
            else {
                process.stdout.write(log);
            }
        }
        catch (err) {
            console.error('Failed on logging', err);
        }
    }
}
const createLogger = ({ logLevel, name }) => {
    const consoleStream = logLevel !== 'none'
        ? [
            {
                type: 'raw',
                level: logLevel,
                stream: new ConsoleLog(logLevel === 'trace'),
            },
        ]
        : [];
    return bunyan.createLogger({
        name,
        streams: consoleStream,
        serializers: { err: bunyan.stdSerializers.err },
    });
};
exports.createLogger = createLogger;
//# sourceMappingURL=logger.js.map