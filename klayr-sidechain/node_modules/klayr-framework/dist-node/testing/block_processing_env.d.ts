/// <reference types="node" />
import { Block, Chain, DataAccess, BlockHeader, Transaction, StateStore } from '@klayr/chain';
import { Database } from '@liskhq/lisk-db';
import { BaseModule } from '../modules';
import { Keys } from './fixtures';
import { EventJSON, GenesisConfig } from '../types';
import { Consensus } from '../engine/consensus';
import { MethodContext } from '../state_machine';
import { Generator } from '../engine/generator';
type Options = {
    genesis?: GenesisConfig;
    modules?: Record<string, Record<string, unknown>>;
    databasePath?: string;
    passphrase?: string;
};
interface BlockProcessingParams {
    modules?: BaseModule[];
    options?: Options;
    initValidators?: Buffer[];
    logLevel?: string;
}
type DecodedEventJSON = EventJSON & {
    decodedData: Record<string, unknown>;
};
export interface BlockProcessingEnv {
    createBlock: (transactions?: Transaction[], timestamp?: number) => Promise<Block>;
    getConsensus: () => Consensus;
    getConsensusStore: () => StateStore;
    getGenerator: () => Generator;
    getGenesisBlock: () => Block;
    getChain: () => Chain;
    getMethodContext: () => MethodContext;
    getBlockchainDB: () => Database;
    process: (block: Block) => Promise<void>;
    processUntilHeight: (height: number) => Promise<void>;
    getLastBlock: () => Block;
    getNextValidatorKeys: (blockHeader: BlockHeader, distance?: number) => Promise<Keys>;
    getDataAccess: () => DataAccess;
    getEvents: (height: number, module?: string, name?: string) => Promise<DecodedEventJSON[]>;
    getChainID: () => Buffer;
    invoke: <T = void>(path: string, params?: Record<string, unknown>) => Promise<T>;
    cleanup: (config: Options) => void;
}
export declare const getBlockProcessingEnv: (params: BlockProcessingParams) => Promise<BlockProcessingEnv>;
export {};
