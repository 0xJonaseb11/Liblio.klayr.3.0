"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlock = exports.createFakeBlockHeader = exports.createBlockHeaderWithDefaults = void 0;
const chain_1 = require("@klayr/chain");
const cryptography_1 = require("@klayr/cryptography");
const tree_1 = require("@klayr/tree");
const createBlockHeaderWithDefaults = (header) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    return new chain_1.BlockHeader({
        version: (_a = header === null || header === void 0 ? void 0 : header.version) !== null && _a !== void 0 ? _a : 2,
        timestamp: (_b = header === null || header === void 0 ? void 0 : header.timestamp) !== null && _b !== void 0 ? _b : 0,
        height: (_c = header === null || header === void 0 ? void 0 : header.height) !== null && _c !== void 0 ? _c : 1,
        impliesMaxPrevotes: (_d = header === null || header === void 0 ? void 0 : header.impliesMaxPrevotes) !== null && _d !== void 0 ? _d : true,
        previousBlockID: (_e = header === null || header === void 0 ? void 0 : header.previousBlockID) !== null && _e !== void 0 ? _e : cryptography_1.utils.hash(cryptography_1.utils.getRandomBytes(4)),
        transactionRoot: (_f = header === null || header === void 0 ? void 0 : header.transactionRoot) !== null && _f !== void 0 ? _f : cryptography_1.utils.hash(cryptography_1.utils.getRandomBytes(4)),
        stateRoot: (_g = header === null || header === void 0 ? void 0 : header.stateRoot) !== null && _g !== void 0 ? _g : cryptography_1.utils.hash(cryptography_1.utils.getRandomBytes(4)),
        eventRoot: (_h = header === null || header === void 0 ? void 0 : header.eventRoot) !== null && _h !== void 0 ? _h : cryptography_1.utils.hash(cryptography_1.utils.getRandomBytes(4)),
        generatorAddress: (_j = header === null || header === void 0 ? void 0 : header.generatorAddress) !== null && _j !== void 0 ? _j : cryptography_1.utils.getRandomBytes(32),
        aggregateCommit: (_k = header === null || header === void 0 ? void 0 : header.aggregateCommit) !== null && _k !== void 0 ? _k : {
            height: 0,
            aggregationBits: Buffer.alloc(0),
            certificateSignature: Buffer.alloc(0),
        },
        maxHeightGenerated: (_l = header === null || header === void 0 ? void 0 : header.maxHeightGenerated) !== null && _l !== void 0 ? _l : 0,
        maxHeightPrevoted: (_m = header === null || header === void 0 ? void 0 : header.maxHeightPrevoted) !== null && _m !== void 0 ? _m : 0,
        assetRoot: (_o = header === null || header === void 0 ? void 0 : header.assetRoot) !== null && _o !== void 0 ? _o : cryptography_1.utils.hash(cryptography_1.utils.getRandomBytes(4)),
        validatorsHash: (_p = header === null || header === void 0 ? void 0 : header.validatorsHash) !== null && _p !== void 0 ? _p : cryptography_1.utils.hash(cryptography_1.utils.getRandomBytes(4)),
    });
};
exports.createBlockHeaderWithDefaults = createBlockHeaderWithDefaults;
const createFakeBlockHeader = (header) => {
    const headerWithDefault = (0, exports.createBlockHeaderWithDefaults)(header);
    const { privateKey } = cryptography_1.legacy.getPrivateAndPublicKeyFromPassphrase(cryptography_1.utils.getRandomBytes(10).toString('hex'));
    headerWithDefault.sign(cryptography_1.utils.getRandomBytes(32), privateKey);
    return headerWithDefault;
};
exports.createFakeBlockHeader = createFakeBlockHeader;
const createBlock = async ({ privateKey, chainID, timestamp, previousBlockID, transactions, assets, header, }) => {
    var _a, _b;
    const publicKey = cryptography_1.ed.getPublicKeyFromPrivateKey(privateKey);
    const txTree = new tree_1.MerkleTree();
    await txTree.init((_a = transactions === null || transactions === void 0 ? void 0 : transactions.map(tx => tx.id)) !== null && _a !== void 0 ? _a : []);
    const blockHeader = (0, exports.createBlockHeaderWithDefaults)({
        previousBlockID,
        timestamp,
        transactionRoot: (_b = header === null || header === void 0 ? void 0 : header.transactionRoot) !== null && _b !== void 0 ? _b : txTree.root,
        eventRoot: header === null || header === void 0 ? void 0 : header.eventRoot,
        stateRoot: header === null || header === void 0 ? void 0 : header.stateRoot,
        generatorAddress: cryptography_1.address.getAddressFromPublicKey(publicKey),
        ...header,
    });
    blockHeader.sign(chainID, privateKey);
    return new chain_1.Block(blockHeader, transactions !== null && transactions !== void 0 ? transactions : [], assets !== null && assets !== void 0 ? assets : new chain_1.BlockAssets());
};
exports.createBlock = createBlock;
//# sourceMappingURL=create_block.js.map