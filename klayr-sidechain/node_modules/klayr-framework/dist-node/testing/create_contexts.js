"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRecoverCCMsgMethodContext = exports.createBeforeRecoverCCMsgMethodContext = exports.createCrossChainMessageContext = exports.createTransientModuleEndpointContext = exports.createTransientMethodContext = exports.createTransactionContext = exports.createBlockGenerateContext = exports.createBlockContext = exports.createGenesisBlockContext = void 0;
const chain_1 = require("@klayr/chain");
const cryptography_1 = require("@klayr/cryptography");
const lisk_db_1 = require("@liskhq/lisk-db");
const codec_1 = require("@klayr/codec");
const state_machine_1 = require("../state_machine");
const mocks_1 = require("./mocks");
const prefixed_state_read_writer_1 = require("../state_machine/prefixed_state_read_writer");
const in_memory_prefixed_state_1 = require("./in_memory_prefixed_state");
const interoperability_1 = require("../modules/interoperability");
const createTestHeader = () => new chain_1.BlockHeader({
    height: 0,
    generatorAddress: cryptography_1.utils.getRandomBytes(20),
    previousBlockID: Buffer.alloc(0),
    timestamp: Math.floor(Date.now() / 1000),
    version: 0,
    transactionRoot: cryptography_1.utils.hash(Buffer.alloc(0)),
    stateRoot: cryptography_1.utils.hash(Buffer.alloc(0)),
    maxHeightGenerated: 0,
    maxHeightPrevoted: 0,
    impliesMaxPrevotes: true,
    assetRoot: cryptography_1.utils.hash(Buffer.alloc(0)),
    aggregateCommit: {
        height: 0,
        aggregationBits: Buffer.alloc(0),
        certificateSignature: Buffer.alloc(0),
    },
    validatorsHash: cryptography_1.utils.hash(Buffer.alloc(0)),
});
const createGenesisBlockContext = (params) => {
    var _a, _b, _c, _d, _e, _f;
    const logger = (_a = params.logger) !== null && _a !== void 0 ? _a : mocks_1.loggerMock;
    const stateStore = (_b = params.stateStore) !== null && _b !== void 0 ? _b : new prefixed_state_read_writer_1.PrefixedStateReadWriter(new in_memory_prefixed_state_1.InMemoryPrefixedStateDB());
    const eventQueue = (_c = params.eventQueue) !== null && _c !== void 0 ? _c : new state_machine_1.EventQueue(params.header ? params.header.height : 0);
    const header = (_d = params.header) !== null && _d !== void 0 ? _d : createTestHeader();
    return new state_machine_1.GenesisBlockContext({
        eventQueue,
        stateStore,
        header,
        assets: (_e = params.assets) !== null && _e !== void 0 ? _e : new chain_1.BlockAssets(),
        logger,
        chainID: (_f = params.chainID) !== null && _f !== void 0 ? _f : Buffer.from('10000000', 'hex'),
    });
};
exports.createGenesisBlockContext = createGenesisBlockContext;
const createBlockContext = (params) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const logger = (_a = params.logger) !== null && _a !== void 0 ? _a : mocks_1.loggerMock;
    const stateStore = (_b = params.stateStore) !== null && _b !== void 0 ? _b : new prefixed_state_read_writer_1.PrefixedStateReadWriter(new in_memory_prefixed_state_1.InMemoryPrefixedStateDB());
    const contextStore = (_c = params.contextStore) !== null && _c !== void 0 ? _c : new Map();
    const eventQueue = (_d = params.eventQueue) !== null && _d !== void 0 ? _d : new state_machine_1.EventQueue(params.header ? params.header.height : 0);
    const header = (_e = params.header) !== null && _e !== void 0 ? _e : createTestHeader();
    return new state_machine_1.BlockContext({
        stateStore,
        contextStore,
        logger,
        eventQueue,
        transactions: (_f = params.transactions) !== null && _f !== void 0 ? _f : [],
        header,
        assets: (_g = params.assets) !== null && _g !== void 0 ? _g : new chain_1.BlockAssets(),
        chainID: (_h = params.chainID) !== null && _h !== void 0 ? _h : cryptography_1.utils.getRandomBytes(4),
    });
};
exports.createBlockContext = createBlockContext;
const createBlockGenerateContext = (params) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const db = new lisk_db_1.InMemoryDatabase();
    const generatorStore = new chain_1.StateStore(db);
    const getOffchainStore = (moduleID, subStorePrefix) => generatorStore.getStore(moduleID, subStorePrefix);
    const header = (_a = params.header) !== null && _a !== void 0 ? _a : createTestHeader();
    const stateStore = new prefixed_state_read_writer_1.PrefixedStateReadWriter(new in_memory_prefixed_state_1.InMemoryPrefixedStateDB());
    const contextStore = new Map();
    const getStore = (moduleID, storePrefix) => stateStore.getStore(moduleID, storePrefix);
    return {
        stateStore,
        contextStore,
        assets: (_b = params.assets) !== null && _b !== void 0 ? _b : new chain_1.BlockAssets([]),
        getOffchainStore: (_c = params.getOffchainStore) !== null && _c !== void 0 ? _c : getOffchainStore,
        logger: (_d = params.logger) !== null && _d !== void 0 ? _d : mocks_1.loggerMock,
        chainID: (_e = params.chainID) !== null && _e !== void 0 ? _e : cryptography_1.utils.getRandomBytes(32),
        getMethodContext: (_f = params.getMethodContext) !== null && _f !== void 0 ? _f : (() => ({
            getStore,
            eventQueue: new state_machine_1.EventQueue(params.header ? params.header.height : 0),
            contextStore: new Map(),
        })),
        getStore: (_g = params.getStore) !== null && _g !== void 0 ? _g : getStore,
        getFinalizedHeight: () => { var _a; return (_a = params.finalizedHeight) !== null && _a !== void 0 ? _a : 0; },
        header,
    };
};
exports.createBlockGenerateContext = createBlockGenerateContext;
const createTransactionContext = (params) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const logger = (_a = params.logger) !== null && _a !== void 0 ? _a : mocks_1.loggerMock;
    const stateStore = (_b = params.stateStore) !== null && _b !== void 0 ? _b : new prefixed_state_read_writer_1.PrefixedStateReadWriter(new in_memory_prefixed_state_1.InMemoryPrefixedStateDB());
    const contextStore = (_c = params.contextStore) !== null && _c !== void 0 ? _c : new Map();
    const eventQueue = (_d = params.eventQueue) !== null && _d !== void 0 ? _d : new state_machine_1.EventQueue(params.header ? params.header.height : 0);
    const header = (_e = params.header) !== null && _e !== void 0 ? _e : createTestHeader();
    return new state_machine_1.TransactionContext({
        stateStore,
        contextStore,
        logger,
        eventQueue,
        header,
        assets: (_f = params.assets) !== null && _f !== void 0 ? _f : new chain_1.BlockAssets(),
        chainID: (_g = params.chainID) !== null && _g !== void 0 ? _g : cryptography_1.utils.getRandomBytes(32),
        transaction: params.transaction,
    });
};
exports.createTransactionContext = createTransactionContext;
const createTransientMethodContext = (params) => {
    var _a, _b, _c;
    const stateStore = (_a = params.stateStore) !== null && _a !== void 0 ? _a : new prefixed_state_read_writer_1.PrefixedStateReadWriter(new in_memory_prefixed_state_1.InMemoryPrefixedStateDB());
    const contextStore = (_b = params.contextStore) !== null && _b !== void 0 ? _b : new Map();
    const eventQueue = (_c = params.eventQueue) !== null && _c !== void 0 ? _c : new state_machine_1.EventQueue(0);
    return (0, state_machine_1.createMethodContext)({ stateStore, eventQueue, contextStore });
};
exports.createTransientMethodContext = createTransientMethodContext;
const createTransientModuleEndpointContext = (params) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const stateStore = (_a = params.stateStore) !== null && _a !== void 0 ? _a : new prefixed_state_read_writer_1.PrefixedStateReadWriter(new in_memory_prefixed_state_1.InMemoryPrefixedStateDB());
    const moduleStore = (_b = params.moduleStore) !== null && _b !== void 0 ? _b : new chain_1.StateStore(new lisk_db_1.InMemoryDatabase());
    const parameters = (_c = params.params) !== null && _c !== void 0 ? _c : {};
    const logger = (_d = params.logger) !== null && _d !== void 0 ? _d : mocks_1.loggerMock;
    const chainID = (_e = params.chainID) !== null && _e !== void 0 ? _e : Buffer.alloc(0);
    return {
        getStore: (moduleID, storePrefix) => stateStore.getStore(moduleID, storePrefix),
        getOffchainStore: (moduleID, storePrefix) => moduleStore.getStore(moduleID, storePrefix),
        getImmutableMethodContext: () => (0, state_machine_1.createImmutableMethodContext)(stateStore),
        params: parameters,
        header: (_g = (_f = params.context) === null || _f === void 0 ? void 0 : _f.header) !== null && _g !== void 0 ? _g : createTestHeader(),
        logger,
        chainID,
    };
};
exports.createTransientModuleEndpointContext = createTransientModuleEndpointContext;
const createCrossChainMessageContext = (params) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const stateStore = (_a = params.stateStore) !== null && _a !== void 0 ? _a : new prefixed_state_read_writer_1.PrefixedStateReadWriter(new in_memory_prefixed_state_1.InMemoryPrefixedStateDB());
    const contextStore = (_b = params.contextStore) !== null && _b !== void 0 ? _b : new Map();
    const logger = (_c = params.logger) !== null && _c !== void 0 ? _c : mocks_1.loggerMock;
    const chainID = (_d = params.chainID) !== null && _d !== void 0 ? _d : Buffer.alloc(0);
    const eventQueue = (_e = params.eventQueue) !== null && _e !== void 0 ? _e : new state_machine_1.EventQueue(0);
    const getStore = (moduleID, storePrefix) => stateStore.getStore(moduleID, storePrefix);
    return {
        header: (_f = params.header) !== null && _f !== void 0 ? _f : { timestamp: 0, height: 0 },
        ccm: (_g = params.ccm) !== null && _g !== void 0 ? _g : {
            nonce: BigInt(0),
            module: 'token',
            crossChainCommand: 'crossChainTransfer',
            sendingChainID: Buffer.from([0, 0, 0, 2]),
            receivingChainID: Buffer.from([0, 0, 0, 3]),
            fee: BigInt(20000),
            status: 0,
            params: Buffer.alloc(0),
        },
        contextStore,
        chainID,
        eventQueue,
        getMethodContext: () => (0, state_machine_1.createMethodContext)({ eventQueue, stateStore, contextStore }),
        getStore,
        logger,
        stateStore,
        transaction: (_h = params.transaction) !== null && _h !== void 0 ? _h : {
            senderAddress: cryptography_1.utils.getRandomBytes(20),
            fee: BigInt(100000000),
            params: codec_1.codec.encode(interoperability_1.ccuParamsSchema, {
                activeValidatorsUpdate: {
                    blsKeysUpdate: [],
                    bftWeightsUpdate: [],
                    bftWeightsUpdateBitmap: Buffer.alloc(0),
                },
                certificate: Buffer.alloc(1),
                certificateThreshold: BigInt(1),
                inboxUpdate: {
                    crossChainMessages: [],
                    messageWitnessHashes: [],
                    outboxRootWitness: {
                        bitmap: Buffer.alloc(1),
                        siblingHashes: [],
                    },
                },
                sendingChainID: (_j = params.sendingChainID) !== null && _j !== void 0 ? _j : Buffer.from('04000001', 'hex'),
            }),
        },
    };
};
exports.createCrossChainMessageContext = createCrossChainMessageContext;
const createBeforeRecoverCCMsgMethodContext = (params) => (0, exports.createCrossChainMessageContext)(params);
exports.createBeforeRecoverCCMsgMethodContext = createBeforeRecoverCCMsgMethodContext;
const createRecoverCCMsgMethodContext = (params) => ({
    ...(0, exports.createCrossChainMessageContext)(params),
    terminatedChainID: params.terminatedChainID,
    module: params.module,
    substorePrefix: params.storePrefix,
    storeKey: params.storeKey,
    storeValue: params.storeValue,
});
exports.createRecoverCCMsgMethodContext = createRecoverCCMsgMethodContext;
//# sourceMappingURL=create_contexts.js.map